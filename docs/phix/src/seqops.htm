<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Sequence Operations</h1>
      <div id="mainSection">
        Equivalent functions exist to apply all of the relational, logical and arithmetic operators described above,
        as well as the math routines described in
       <a href="library.htm">Library Routines</a>, to entire <a href="sequence.htm">sequences</a> as 
        well as to single numbers (<a href="atom.htm">atoms</a>).
       <br>
       <br>
        The sq_uminus() function applies the unary (one operand) minus operator to each element of a sequence to yield 
        a sequence of results of the same length. If one of these elements is itself a sequence then the same rule
        is applied again recursively. e.g.
       <br>
<!--eucode>
    x = sq_uminus({1, 2, 3, {4, 5}}) -- x is {-1, -2, -3, {-4, -5}}
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_uminus</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">4</font><font color="#0000FF">,</font><font color="#000000"> 5</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">)</font><font color="#000080"><i> -- x is {-1, -2, -3, {-4, -5}}</i></font>
</pre>
        If a binary (two-operand) operator function is passed two sequences then
        they must be of the same length. The binary operation is then
        applied to corresponding elements taken from the two sequences to get a
        sequence of results, with the function applied recursively if required. e.g.
       <br>
<!--eucode>
    x = sq_add({5, 6, 7, {8, 9}}, {10, 20, 30, {40, 50}}) -- x is {15, 26, 37, {48, 59}}
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_add</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000"> 6</font><font color="#0000FF">,</font><font color="#000000"> 7</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">8</font><font color="#0000FF">,</font><font color="#000000"> 9</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000"> {</font><font color="#000000">10</font><font color="#0000FF">,</font><font color="#000000"> 20</font><font color="#0000FF">,</font><font color="#000000"> 30</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">40</font><font color="#0000FF">,</font><font color="#000000"> 50</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">)</font><font color="#000080"><i> -- x is {15, 26, 37, {48, 59}}</i></font>
</pre>
        If a binary operator function is passed one sequence while the other parameter is a
        single number (atom) then the single number is effectively repeated to
        form a sequence of equal length to the sequence operand. The rules for
        operating on two sequences then apply. Some examples:
       <br>
<!--eucode>
    x = sq_add({5, 6, 7, {8, 9}}, {10, 20, 30, 40})     -- x is {15, 26, 37, {48, 49}}
    x = sq_add({5, 6, 7, {8, 9}}, 10)                   -- x is {15, 16, 17, {18, 19}}

    x = {1, 2, 3}
    y = {4, 5, 6}
    w = sq_mul(5,y)                     -- w is {20, 25, 30}
    z = sq_add(x,y)                        -- z is {5, 7, 9}
    z = sq_lt(x,y)                         -- z is {1, 1, 1}
    w = {{1, 2}, {3, 4}, {5}}
    w = sq_mul(w,y)         -- w is {{4, 8}, {15, 20}, {30}}

    w = sq_and({1, 0, 0, 1},{1, 1, 1, 0})    -- {1, 0, 0, 0}
    w = sq_not({1, 5, -2, 0, 0})     -- w is {0, 0, 0, 1, 1}
    w = sq_eq({1, 2, 3},{1, 2, 4})   -- w is {1, 1, 0}
    w = ({1, 2, 3} = {1, 2, 4})      -- w is 0 (a singular false)
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_add</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000"> 6</font><font color="#0000FF">,</font><font color="#000000"> 7</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">8</font><font color="#0000FF">,</font><font color="#000000"> 9</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000"> {</font><font color="#000000">10</font><font color="#0000FF">,</font><font color="#000000"> 20</font><font color="#0000FF">,</font><font color="#000000"> 30</font><font color="#0000FF">,</font><font color="#000000"> 40</font><font color="#800000">}</font><font color="#0000FF">)    </font><font color="#000080"><i> -- x is {15, 26, 37, {48, 49}}
</i></font><font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_add</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000"> 6</font><font color="#0000FF">,</font><font color="#000000"> 7</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">8</font><font color="#0000FF">,</font><font color="#000000"> 9</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#000000"> 10</font><font color="#0000FF">)                  </font><font color="#000080"><i> -- x is {15, 16, 17, {18, 19}}

</i></font><font color="#000000">    x</font><font color="#0000FF"> = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#0000FF">}
</font><font color="#000000">    y</font><font color="#0000FF"> = {</font><font color="#000000">4</font><font color="#0000FF">,</font><font color="#000000"> 5</font><font color="#0000FF">,</font><font color="#000000"> 6</font><font color="#0000FF">}
</font><font color="#000000">    w</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_mul</font><font color="#0000FF">(</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000">y</font><font color="#0000FF">)                    </font><font color="#000080"><i> -- w is {20, 25, 30}
</i></font><font color="#000000">    z</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_add</font><font color="#0000FF">(</font><font color="#000000">x</font><font color="#0000FF">,</font><font color="#000000">y</font><font color="#0000FF">)                       </font><font color="#000080"><i> -- z is {5, 7, 9}
</i></font><font color="#000000">    z</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_lt</font><font color="#0000FF">(</font><font color="#000000">x</font><font color="#0000FF">,</font><font color="#000000">y</font><font color="#0000FF">)                        </font><font color="#000080"><i> -- z is {1, 1, 1}
</i></font><font color="#000000">    w</font><font color="#0000FF"> = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000"> {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000"> 4</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000"> {</font><font color="#000000">5</font><font color="#800000">}</font><font color="#0000FF">}
</font><font color="#000000">    w</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_mul</font><font color="#0000FF">(</font><font color="#000000">w</font><font color="#0000FF">,</font><font color="#000000">y</font><font color="#0000FF">)        </font><font color="#000080"><i> -- w is {{4, 8}, {15, 20}, {30}}

</i></font><font color="#000000">    w</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_and</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#800000">}</font><font color="#0000FF">)   </font><font color="#000080"><i> -- {1, 0, 0, 0}
</i></font><font color="#000000">    w</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_not</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 5</font><font color="#0000FF">, -</font><font color="#000000">2</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#800000">}</font><font color="#0000FF">)    </font><font color="#000080"><i> -- w is {0, 0, 0, 1, 1}
</i></font><font color="#000000">    w</font><font color="#0000FF"> =</font><font color="#5E005E"> sq_eq</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 4</font><font color="#800000">}</font><font color="#0000FF">)  </font><font color="#000080"><i> -- w is {1, 1, 0}
</i></font><font color="#000000">    w</font><font color="#0000FF"> = (</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#800000">}</font><font color="#0000FF"> =</font><font color="#800000"> {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 4</font><font color="#800000">}</font><font color="#0000FF">)     </font><font color="#000080"><i> -- w is 0 (a singular false)</i></font>
</pre>
        The functions listed below accept either sequence or atom argument(s), unlike the "sq_"-less functions and infix operators which
        only accept atoms (apart from the first two columns, however those infix operators/sq-less functions always yield a single boolean result). 
        You can find their actual implementations in builtins\psqop.e, which is automatically included when needed.
       <br>
       <br>
       <table>
        <tr>
       <table>
        <tr>
         <td><a href="relops.htm">sq_eq</a></td>
         <td><a href="integer.htm">sq_int</a></td>
         <td><a href="arithops.htm">sq_add</a></td>
         <td><a href="logicops.htm">sq_and</a></td>
         <td><a href="and_bits.htm">sq_and_bits</a></td>
         <td><a href="cos.htm">sq_cos</a></td>
         <td><a href="remainder.htm">sq_rmdr</a></td>
         <td><a href="abs.htm">sq_abs</a></td>
        </tr>
        <tr>
         <td><a href="relops.htm">sq_ne</a></td>
         <td><a href="atom.htm">sq_atom</a></td>
         <td><a href="arithops.htm">sq_sub</a></td>
         <td><a href="logicops.htm">sq_not</a></td>
         <td><a href="or_bits.htm">sq_or_bits</a></td>
         <td><a href="sin.htm">sq_sin</a></td>
         <td><a href="arithops.htm">sq_uminus</a></td>
         <td><a href="round.htm">sq_round</a></td>
        </tr>
        <tr>
         <td><a href="relops.htm">sq_lt</a></td>
         <td><a href="string.htm">sq_str</a></td>
         <td><a href="arithops.htm">sq_mul</a></td>
         <td><a href="logicops.htm">sq_or</a></td>
         <td><a href="xor_bits.htm">sq_xor_bits</a></td>
         <td><a href="tan.htm">sq_tan</a></td>
         <td><a href="rand.htm">sq_rand</a></td>
         <td><a href="ceil.htm">sq_ceil</a></td>
        </tr>
        <tr>
         <td><a href="relops.htm">sq_le</a></td>
         <td><a href="sequence.htm">sq_seq</a></td>
         <td><a href="arithops.htm">sq_div</a></td>
         <td><a href="logicops.htm">sq_xor</a></td>
         <td><a href="not_bits.htm">sq_not_bits</a></td>
         <td><a href="arccos.htm">sq_arccos</a></td>
         <td><a href="log.htm">sq_log[10]</a></td>
         <td><a href="sign.htm">sq_sign</a></td>
        </tr>
        <tr>
         <td><a href="relops.htm">sq_gt</a></td>
         <td>           </td>
         <td><a href="floor.htm">sq_floor</a></td>
         <td>           </td>
         <td>           </td>
         <td><a href="arcsin.htm">sq_arcsin</a></td>
         <td><a href="power.htm">sq_power</a></td>
         <td><a href="mod.htm">sq_mod</a></td>
        </tr>
        <tr>
         <td><a href="relops.htm">sq_ge</a></td>
         <td>           </td>
         <td><a href="floor.htm">sq_floor_div</a></td>
         <td>           </td>
         <td>           </td>
         <td><a href="arctan.htm">sq_arctan</a></td>
         <td><a href="sqrt.htm">sq_sqrt</a></td>
         <td><a href="trunc.htm">sq_trunc</a></td>
        </tr>
       </table>
        </tr>
       <table>
        <tr>
        <tr id="Technicalia" style="display:none;">
         <td valign=top>
          <a href="glossary.htm#technicalia">
           <b>Compatibility Notes</b>
          </a>
         </td>
         <td>
            RDS Euphoria and OpenEu allow implicit sequence ops whereas Phix requires explicit (functional style) sequence ops. 
            The simple choice is between infix sequence ops and infix comparison operators; try to have both and the syntax 
            collapses and/or becomes ambiguous. For example, assuming you need a boolean result, does the inner comparison in a 
            condition such as (tag="lx")=(flags="rw") reduce to equal(false,false)[T] or equal({1,0},{0,1})[F]? 
            <br>
            <br>
            It depends on how you treat the outer two "=": as sequence operators, or as equality operators. 
            <br>
            <br>
            Both interpretations could be perfectly reasonable, which would result in an ambiguous and 
            therefore fundamentally broken programming language.
            <br>
            <br>
            In RDS and OpenEu you <i>can</i> write {1,2,3}+5, which tends to generate a compile time warning or runtime error
            in Phix, however you <i>cannot</i> write conditions such as name="pete" and name1&lt;name2 but must instead use 
            equal(name,"pete") and compare(name1,name2)&lt;0, whereas <i>all four forms are perfectly valid in Phix</i>.
            <br>
            <br>
            Analysis of existing source code revealed that comparison was far more common than infix sequence maths, 
            the latter averaging at just once per ten thousand lines of code(!).
            Apart from upper/lower, which were horribly slow anyway, I found no other uses of infix sequence relational ops.
            <br>
            <br>
            Hence the design decision was made that phix would allow infix comparison ops but require (the explicit) 
            sq_add({1,2,3},5) instead of (the implicit) {1,2,3}+5.<br>
            I fully accept that some_long_variable_name = sq_add(some_long_variable_name,1) is less elegant than 
            some_long_variable_name += 1, but I <i>am</i> just going to say 
            "yes, but you don't need equal() and compare() <i>absolutely ****** everywhere!</i>"
            <br>
            <br>
            The phix compiler does a pretty reasonable job of identifying implicit infix operators that ought to be
            explicit (function style) and issues "warning: sequence op (sq_xxx) assumed" messages. Particularly when
            working with legacy RDS Eu/OpenEuphoria code, as you modify it to get rid of such warnings you should 
            take the opportunity to look nearby for any that the compiler might have missed.
         </td>
        </tr>
       </table>
        </tr>
       </table>
       <img src="images/sprites/tech.open.png" title="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
        &nbsp;
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
