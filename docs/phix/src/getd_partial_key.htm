<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">getd_partial_key</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          <b>Definition:</b>
         </td>
         <td>
          <a href="object.htm">object</a> key = getd_partial_key(<a href="object.htm">object</a> pkey,
                                                                 <a href="integer.htm">integer</a> tid=1,
                                                                 <a href="integer.htm#bool">bool</a> rev=false)
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Description:</b>
         </td>
         <td>
            Retrieve the first key equal to or greater than (or less than if rev is true) the specified partial key.
            <br>
            <br>
            tid can be omitted, to use the default dictionary, or the result of a previous <a href="new_dict.htm">new_dict</a>() call.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Comments:</b>
         </td>
         <td>
            As per <a href="getd.htm">getd</a>()/<a href="getd_by_index.htm">getd_by_index</a>(), this function can return 
            0/the <a href="setd_default.htm">setd_default</a>() value for non-existent keys and may need similar logic.
            <br>
            <br>
            Equally, as per the example below, it is up to the calling program to decide whether "this" is of any use,
            when it does not actually start with the partial key, in that case "the".
            <br>
            <br>
            This routine is a "single-shot" variant of <a href="traverse_dict_partial_key.htm">traverse_dict_partial_key</a>();
            obviously the latter must be used should you want to "carry on" in any way.
            <br>
            <br>
            This function is not thread-safe: locking must be used if two threads are not to over-clobber each others results,
            even when reading from entirely separate dictionaries.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Example:</b>
         </td>
         <td>
<!--eucode>
setd("this",0)
setd("that",0)
setd("those",0)
?getd_partial_key("the")    -- prints "this"
</eucode-->
<pre>
<font color="#000000"></font><font color="#5E005E">setd</font><font color="#0000FF">(</font><font color="#008000">"this"</font><font color="#0000FF">,</font><font color="#000000">0</font><font color="#0000FF">)
</font><font color="#5E005E">setd</font><font color="#0000FF">(</font><font color="#008000">"that"</font><font color="#0000FF">,</font><font color="#000000">0</font><font color="#0000FF">)
</font><font color="#5E005E">setd</font><font color="#0000FF">(</font><font color="#008000">"those"</font><font color="#0000FF">,</font><font color="#000000">0</font><font color="#0000FF">)
?</font><font color="#5E005E">getd_partial_key</font><font color="#0000FF">(</font><font color="#008000">"the"</font><font color="#0000FF">)   </font><font color="#000080"><i> -- prints "this"</i></font>
</pre>
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>See Also:</b>
         </td>
         <td>
          <a href="getd.htm">getd</a>,
          <a href="setd_default.htm">setd_default</a>,
          <a href="getd_index.htm">getd_index</a>,
          <a href="traverse_dict_partial_key.htm">traverse_dict_partial_key</a>
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
