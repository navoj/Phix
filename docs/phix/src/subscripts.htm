<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Subscripts</h1>
      <div id="mainSection">
        A single element of a <a href="sequence.htm">sequence</a> may be selected by giving the element number
        in square brackets. Element numbers start at 1. Non-integer subscripts are
        rounded down to an integer.
       <br>
       <br>
        For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2. Suppose we
        assign something different to x[2]:
<!--eucode>
     x[2] = {11,22,33}
</eucode-->
<pre>
<font color="#000000">     x</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">] = {</font><font color="#000000">11</font><font color="#0000FF">,</font><font color="#000000">22</font><font color="#0000FF">,</font><font color="#000000">33</font><font color="#0000FF">}</font>
</pre>
       Then x becomes: {5, {11,22,33}, 9, 0.5, 13}. Now if we ask for x[2] we get
        {11,22,33} and if we ask for x[2][3] we get the atom 33. If you try to
        subscript with a number that is outside of the range 1 to the number of
        elements, you will get a subscript error. For example x[0], x[-99] or
        x[6] will cause errors. So will x[1][3] since x[1] is not a sequence. There
        is no limit to the number of subscripts that may follow a variable, but
        the variable must contain sequences that are nested deeply enough. The
        two dimensional array, common in other languages, can be easily represented
        with a sequence of sequences:
<!--eucode>
    x = {
         {5, 6, 7, 8, 9},      -- x[1]
         {1, 2, 3, 4, 5},      -- x[2]
         {0, 1, 0, 1, 0}       -- x[3]
        }
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> = {
</font><font color="#800000">         {</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000"> 6</font><font color="#0000FF">,</font><font color="#000000"> 7</font><font color="#0000FF">,</font><font color="#000000"> 8</font><font color="#0000FF">,</font><font color="#000000"> 9</font><font color="#800000">}</font><font color="#0000FF">,     </font><font color="#000080"><i> -- x[1]
</i></font><font color="#800000">         {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#0000FF">,</font><font color="#000000"> 4</font><font color="#0000FF">,</font><font color="#000000"> 5</font><font color="#800000">}</font><font color="#0000FF">,     </font><font color="#000080"><i> -- x[2]
</i></font><font color="#800000">         {</font><font color="#000000">0</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000"> 0</font><font color="#800000">}      </font><font color="#000080"><i> -- x[3]
</i></font><font color="#0000FF">        }</font>
</pre>
        where we have written the numbers in a way that makes the structure
        clearer. An expression of the form x[i][j] can be used to access any element,
        or if you prefer x[i,j] has exactly the same meaning.<br>
        <small>
        (Personally, I use "," when the subscripts have some equivalence, eg points in 
        3D space deserve [x,y,z], whereas I use "][" when they are logically distinct 
        - almost always the case when one is variable and the other a constant - eg
        shape[idx][COLOUR].)</small>
       <br>
       <br>
        The two dimensions are not symmetric however, since an entire "row" can be
        selected with x[i], but there is no simple expression to select an entire
        column. There is, however, a library routine to do just that, see 
        <a href="columnize.htm">columnize</a>() [with columns as a plain integer].
        Other logical structures, such as n-dimensional arrays, arrays of strings, 
        structures, arrays of structures etc. can also be handled easily and flexibly:
       <br>
       <br>
       <h4>3-D array:</h4>
<!--eucode>
    y = {
         {{ 1,1}, {3,3}, {5,5}},
         {{ 0,0}, {0,1}, {9,1}},
         {{-1,7}, {1,1}, {2,2}}
        }
    -- y[2][3][1] is 9
</eucode-->
<pre>
<font color="#000000">    y</font><font color="#0000FF"> = {
</font><font color="#800000">         {</font><font color="#800080">{</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000">1</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">3</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">5</font><font color="#0000FF">,</font><font color="#000000">5</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">,
</font><font color="#800000">         {</font><font color="#800080">{</font><font color="#000000"> 0</font><font color="#0000FF">,</font><font color="#000000">0</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">0</font><font color="#0000FF">,</font><font color="#000000">1</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">9</font><font color="#0000FF">,</font><font color="#000000">1</font><font color="#800080">}</font><font color="#800000">}</font><font color="#0000FF">,
</font><font color="#800000">         {</font><font color="#800080">{</font><font color="#0000FF">-</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">7</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">1</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#800080"> {</font><font color="#000000">2</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800080">}</font><font color="#800000">}
</font><font color="#0000FF">        }
</font><font color="#000080"><i>    -- y[2][3][1] is 9</i></font>
</pre>
       <h4>Array of strings:</h4>
<!--eucode>
    s = {"Hello", "World", "Phix", "", "Last One"}
    -- s[3] is "Phix"
    -- s[3][2] is 'h'
</eucode-->
<pre>
<font color="#000000">    s</font><font color="#0000FF"> = {</font><font color="#008000">"Hello"</font><font color="#0000FF">,</font><font color="#008000"> "World"</font><font color="#0000FF">,</font><font color="#008000"> "Phix"</font><font color="#0000FF">,</font><font color="#008000"> ""</font><font color="#0000FF">,</font><font color="#008000"> "Last One"</font><font color="#0000FF">}
</font><font color="#000080"><i>    -- s[3] is "Phix"
    -- s[3][2] is 'h'</i></font>
</pre>
       <h4>A Structure:</h4>
<!--eucode>
    employee = {
                {"John","Smith"},
                45000,
                27,
                185.5
               }
</eucode-->
<pre>
<font color="#000000">    employee</font><font color="#0000FF"> = {
</font><font color="#800000">                {</font><font color="#008000">"John"</font><font color="#0000FF">,</font><font color="#008000">"Smith"</font><font color="#800000">}</font><font color="#0000FF">,
</font><font color="#000000">                45000</font><font color="#0000FF">,
</font><font color="#000000">                27</font><font color="#0000FF">,
</font><font color="#000000">                185.5
</font><font color="#0000FF">               }</font>
</pre>
        To access "fields" or elements within a structure it is good
        programming style to make up a set of constants that name the various
        fields. This will make your program easier to read. For the example
        above you might have:
<!--eucode>
    constant NAME = 1
    constant FIRST_NAME = 1, LAST_NAME = 2
    constant SALARY = 2
    constant AGE = 3
    constant WEIGHT = 4
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">    constant</font><font color="#000000"> NAME</font><font color="#0000FF"> =</font><font color="#000000"> 1
</font><font color="#008080">    constant</font><font color="#000000"> FIRST_NAME</font><font color="#0000FF"> =</font><font color="#000000"> 1</font><font color="#0000FF">,</font><font color="#000000"> LAST_NAME</font><font color="#0000FF"> =</font><font color="#000000"> 2
</font><font color="#008080">    constant</font><font color="#000000"> SALARY</font><font color="#0000FF"> =</font><font color="#000000"> 2
</font><font color="#008080">    constant</font><font color="#000000"> AGE</font><font color="#0000FF"> =</font><font color="#000000"> 3
</font><font color="#008080">    constant</font><font color="#000000"> WEIGHT</font><font color="#0000FF"> =</font><font color="#000000"> 4</font>
</pre>
        You could then access the person&rsquo;s name with employee[NAME], or if you
        wanted the last name you could say employee[NAME][LAST_NAME].
       <br>
       <br>
       <h4>Array of structures:</h4>
<!--eucode>
    employees = {
                 {{"John","Smith"}, 45000, 27, 185.5},   -- a[1]
                 {{"Bill","Jones"}, 57000, 48, 177.2},   -- a[2]
                 -- .... etc.
                }
    -- employees[2][SALARY] is 57000
</eucode-->
<pre>
<font color="#000000">    employees</font><font color="#0000FF"> = {
</font><font color="#800000">                 {</font><font color="#800080">{</font><font color="#008000">"John"</font><font color="#0000FF">,</font><font color="#008000">"Smith"</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#000000"> 45000</font><font color="#0000FF">,</font><font color="#000000"> 27</font><font color="#0000FF">,</font><font color="#000000"> 185.5</font><font color="#800000">}</font><font color="#0000FF">,  </font><font color="#000080"><i> -- a[1]
</i></font><font color="#800000">                 {</font><font color="#800080">{</font><font color="#008000">"Bill"</font><font color="#0000FF">,</font><font color="#008000">"Jones"</font><font color="#800080">}</font><font color="#0000FF">,</font><font color="#000000"> 57000</font><font color="#0000FF">,</font><font color="#000000"> 48</font><font color="#0000FF">,</font><font color="#000000"> 177.2</font><font color="#800000">}</font><font color="#0000FF">,  </font><font color="#000080"><i> -- a[2]
                 -- .... etc.
</i></font><font color="#0000FF">                }
</font><font color="#000080"><i>    -- employees[2][SALARY] is 57000</i></font>
</pre>
       <h4>Accessing Sequence Elements</h4>
       <!--------------------------------->
        The number of elements in a sequence can be found by calling the 
        length() function. For example:
<!--eucode>
    s = {'a','b','c','d','e'}
    j = length(s)   -- j is now 5
</eucode-->
<pre>
<font color="#000000">    s</font><font color="#0000FF"> = {</font><font color="#008000">'a'</font><font color="#0000FF">,</font><font color="#008000">'b'</font><font color="#0000FF">,</font><font color="#008000">'c'</font><font color="#0000FF">,</font><font color="#008000">'d'</font><font color="#0000FF">,</font><font color="#008000">'e'</font><font color="#0000FF">}
</font><font color="#000000">    j</font><font color="#0000FF"> =</font><font color="#7060A8"> length</font><font color="#0000FF">(</font><font color="#000000">s</font><font color="#0000FF">)  </font><font color="#000080"><i> -- j is now 5</i></font>
</pre>
        Individual elements of s can be referenced using an expression which 
        returns a single positive integer from 1 to length(s), for example:
<!--eucode>
    x = s[1]        -- x is now 'a'
    s[3] = 'Z'      -- s is now {'a','b','Z','d','e'}
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#000000"> s</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]       </font><font color="#000080"><i> -- x is now 'a'
</i></font><font color="#000000">    s</font><font color="#0000FF">[</font><font color="#000000">3</font><font color="#0000FF">] =</font><font color="#008000"> 'Z'     </font><font color="#000080"><i> -- s is now {'a','b','Z','d','e'}</i></font>
</pre>
        Attempts to reference s[0] or s[6] (and above) cause an index out of 
        bounds error.
       <br>
        <a name=negative></a>
       <br>
        Elements of s can also be referenced using -1 to -length(s), counting 
        backwards from the end of the sequence, for example:
<!--eucode>
    x = s[-1]       -- x is now 'e'
    s[-3] = 'c'     -- s is now {'a','b','c','d','e'}
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> =</font><font color="#000000"> s</font><font color="#0000FF">[-</font><font color="#000000">1</font><font color="#0000FF">]      </font><font color="#000080"><i> -- x is now 'e'
</i></font><font color="#000000">    s</font><font color="#0000FF">[-</font><font color="#000000">3</font><font color="#0000FF">] =</font><font color="#008000"> 'c'    </font><font color="#000080"><i> -- s is now {'a','b','c','d','e'}</i></font>
</pre>
        In this way, <b><i>negative indexes</i></b> are simply an exact mirror image (right 
        to left) of the more common (left to right) positive indexes. 
       <br>
       <br> 
        Attempts to reference s[-6] and below cause an index out of bounds error.
       <br>
       <br>
        You can also use the $ shorthand to refer to the last element, for example
<!--eucode>
    x = {{1,2},{3,4}}
    y = x[$]            -- y is now {3,4}
    y = x[end]          -- ditto
    z = x[$][$]         -- z is now 4
</eucode-->
<pre>
<font color="#000000">    x</font><font color="#0000FF"> = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}
</font><font color="#000000">    y</font><font color="#0000FF"> =</font><font color="#000000"> x</font><font color="#0000FF">[</font><font color="#000000">$</font><font color="#0000FF">]           </font><font color="#000080"><i> -- y is now {3,4}
</i></font><font color="#000000">    y</font><font color="#0000FF"> =</font><font color="#000000"> x</font><font color="#0000FF">[</font><font color="#008080">end</font><font color="#0000FF">]         </font><font color="#000080"><i> -- ditto
</i></font><font color="#000000">    z</font><font color="#0000FF"> =</font><font color="#000000"> x</font><font color="#0000FF">[</font><font color="#000000">$</font><font color="#0000FF">][</font><font color="#000000">$</font><font color="#0000FF">]        </font><font color="#000080"><i> -- z is now 4</i></font>
</pre>
        The last line is equivalent to z = x[length(x)][length(x[length(x)])], and is obviously much clearer and shorter. 
        Exactly the same result is produced by x[-1][-1], x[$][$], and x[end][end].
       <br>
       <br>
        Dot subscripts are also allowed, eg s.i.j is equivalent to s[i][j]. (provided that constant ORAC in p.exw is set to 1)
       <br>
       <br>
        Using subscripts to alter a variable defined as a <a href="string.htm">string</a> to contain a non-character will cause a typecheck error. For a 
        variable defined as a <a href="sequence.htm">sequence</a> that is currently assigned a <a href="string.htm">string</a>, the same operation will 
        quietly auto-expand the string (one byte per character) to a <a href="html/glossary.htm#dwordseq">dword-sequence</a> so that the substitution 
        can take place.
       <br>
       <br>
        <font color="#020202">
         <b>Phix data structures are almost infinitely flexible.</b>
        </font>
         Arrays in other languages are constrained to have a fixed number of elements,
         and those elements must all be of the same type. Phix eliminates both
         of those restrictions.
         You can easily add a new structure to the employee sequence above,
         or store an unusually long name in the NAME field and phix will take
         care of it for you. If you wish, you can store a variety of different
         employee "structures", with different sizes, all in one sequence.
       <br>
       <br>
         Not only can a phix program easily represent all conventional data
         structures but you can create very useful, flexible structures that would be
         extremely hard to declare in a conventional language.
         See
        <a href="phixvscl.htm">Phix vs Conventional Languages</a>.
       <br>
       <br>
         In general any expression may be subscripted, for example it would be perfectly legal to write "AEIOU"[vowel_number], 
         however this is not compatibile with RDS Euphoria or OpenEu, plus it could be quite wasteful to write something like
         {5+2,6-1,7*8,8+1}[3]. There are some exceptions, for example you may not immediately follow a slice (see next) with 
         a subscript. <small>(You could use parenthesis as a work-round, eg (s[2..4])[2] is equivalent to s[3], however the 
         latter would be significantly faster, as well as being much easier to read and write in the first place.)</small>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
