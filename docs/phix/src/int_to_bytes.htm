<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">int_to_bytes</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          <b>Definition:</b>
         </td>
         <td>
         <a href="sequence.htm">sequence</a> s = int_to_bytes(<a href="atom.htm">atom</a> a, <a href="integer.htm">integer</a> size = 4)
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Description:</b>
         </td>
         <td>
            Convert an integer into a <a href="sequence.htm">sequence</a> of bytes. These bytes are in
            the order expected on the 386+, i.e. least-significant byte first.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Comments:</b>
         </td>
         <td>
            You might use this routine prior to poking the bytes into
            memory for use by a machine language program.
          <br>
          <br>
            The integer can be negative. It can also be a full 32/64 bit integer that does not fit into a 
            31/63 bit phix <a href="integer.htm">integer</a> type, and hence is declared as type <a href="atom.htm">atom</a>. 
            The individual byte-values returned are unsigned (0..255), but after poking them into memory you will have
            the correct (twos complement) representation, and will yield the same
            (signed) value if passed to <a href="bytes_to_int.htm">bytes_to_int</a>().
          <br>
          <br>
           The size may be 1, 2, 4, or 8, ie the number of bytes.
          <br>
          <br>
            For values which exceed the specified size, the lower size*8 bits are 
            stored and any higher bits discarded. Values which exceed the phix definition
            of integer (ie 31 or 63 bits) but still fit in the specified size (32 or 64 
            bits) will work fine, but obviously any variable used to store the result from 
            <a href="bytes_to_int.htm">bytes_to_int</a>() will need to be declared as atom.
          <br>
          <br>
            Note however that 32-bit phix cannot hold a 64-bit integer with full accuracy,
            even in a variable declared as atom, since atoms on 32-bit have a maximum
            precision of 53 bits, however there is no attempt to issue any kind of compiler
            or runtime error or warning that low-bits might get dropped.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Example 1:</b>
         </td>
         <td>
<!--eucode>
s = int_to_bytes(999)
-- s is {231, 3, 0, 0}
</eucode-->
<pre>
<font color="#000000">s</font><font color="#0000FF"> =</font><font color="#5E005E"> int_to_bytes</font><font color="#0000FF">(</font><font color="#000000">999</font><font color="#0000FF">)
</font><font color="#000080"><i>-- s is {231, 3, 0, 0}</i></font>
</pre>
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Example 2:</b>
         </td>
         <td>
<!--eucode>
s = int_to_bytes(-999)
-- s is {25,252,255,255}
</eucode-->
<pre>
<font color="#000000">s</font><font color="#0000FF"> =</font><font color="#5E005E"> int_to_bytes</font><font color="#0000FF">(-</font><font color="#000000">999</font><font color="#0000FF">)
</font><font color="#000080"><i>-- s is {25,252,255,255}</i></font>
</pre>
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>See Also:</b>
         </td>
         <td>
          <a href="bytes_to_int.htm">bytes_to_int</a>,
          <a href="int_to_bits.htm">int_to_bits</a>,
          <a href="bits_to_int.htm">bits_to_int</a>,
          <a href="peek.htm">peek</a>,
          <a href="poke.htm">poke</a>
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
