<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Multiple Assignment</h1>
      <div id="mainSection">
        Sometimes it can be convenient to make several assignments in one statement, for example
<!--eucode>
    {a,b,c} = somefunc()
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} =</font><font color="#000000"> somefunc</font><font color="#0000FF">()</font>
</pre>
        is (functionally) the same as
<!--eucode>
    tmp = somefunc()
    c = tmp[3]
    b = tmp[2]
    a = tmp[1]
</eucode-->
<pre>
<font color="#000000">    tmp</font><font color="#0000FF"> =</font><font color="#000000"> somefunc</font><font color="#0000FF">()
</font><font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">3</font><font color="#0000FF">]
</font><font color="#000000">    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]
</font><font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
</pre>
        Alternatively you may want to initialise several items to the same thing, eg
<!--eucode>
    {names,dates,sizes} @= {}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">names</font><font color="#0000FF">,</font><font color="#000000">dates</font><font color="#0000FF">,</font><font color="#000000">sizes</font><font color="#0000FF">} @= {}</font>
</pre>
        which is functionally the same as
<!--eucode>
    sizes = {}
    dates = {}
    names = {}
</eucode-->
<pre>
<font color="#000000">    sizes</font><font color="#0000FF"> = {}
</font><font color="#000000">    dates</font><font color="#0000FF"> = {}
</font><font color="#000000">    names</font><font color="#0000FF"> = {}</font>
</pre>
        Like everywhere else, instead of the plainer "=" you can use ":=", which is 
        normally pronounced "becomes equal to", whereas "@=" is normally pronounced 
        "all become equal to". (The comparison form of "=", "==", which is normally
        pronounced "is equal to", is not used anywhere else on this page.)
       <br>
       <br>
        You can also nest (to any level) and combine the two types of multiple assignment:
<!--eucode>
    {{a,b},{c,d}} = {{1,2},{3,4}}       -- (becomes equal to)
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#800000">{</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#800000">}</font><font color="#0000FF">} = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}      </font><font color="#000080"><i> -- (becomes equal to)</i></font>
</pre>
        is functionally equivalent to
<!--eucode>
    {c,d} = {3,4}
    {a,b} = {1,2}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#0000FF">} = {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}</font>
</pre>
        which in turn is functionally equivalent to
<!--eucode>
    d = 4
    c = 3
    b = 2
    a = 1
</eucode-->
<pre>
<font color="#000000">    d</font><font color="#0000FF"> =</font><font color="#000000"> 4
    c</font><font color="#0000FF"> =</font><font color="#000000"> 3
    b</font><font color="#0000FF"> =</font><font color="#000000"> 2
    a</font><font color="#0000FF"> =</font><font color="#000000"> 1</font>
</pre>
        whereas
<!--eucode>
    {{a,b},{c,d}} @= {{1,2},{3,4}}      -- (all become equal to)
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#800000">{</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#800000">}</font><font color="#0000FF">} @= {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}     </font><font color="#000080"><i> -- (all become equal to)</i></font>
</pre>
        is functionally equivalent to (any nested multiple assignments are always the plainer "="/":=")
<!--eucode>
    {c,d} = {{1,2},{3,4}}
    {a,b} = {{1,2},{3,4}}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">c</font><font color="#0000FF">,</font><font color="#000000">d</font><font color="#0000FF">} = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}
    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} = {</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#800000">}</font><font color="#0000FF">}</font>
</pre>
        which is the same as
<!--eucode>
    d = {3,4}
    c = {1,2}
    b = {3,4}
    a = {1,2}
</eucode-->
<pre>
<font color="#000000">    d</font><font color="#0000FF"> = {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
</font><font color="#000000">    c</font><font color="#0000FF"> = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}
</font><font color="#000000">    b</font><font color="#0000FF"> = {</font><font color="#000000">3</font><font color="#0000FF">,</font><font color="#000000">4</font><font color="#0000FF">}
</font><font color="#000000">    a</font><font color="#0000FF"> = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">}</font>
</pre>
        Subscripts and slices are also permitted; if s is {1,2,3,4} then
<!--eucode>
    {s[1],s[2..$]} = {s[$],s[1..$-1]}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">1</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">2</font><font color="#0000FF">..</font><font color="#000000">$</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">$</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">1</font><font color="#0000FF">..</font><font color="#000000">$</font><font color="#0000FF">-</font><font color="#000000">1</font><font color="#800000">]</font><font color="#0000FF">}</font>
</pre>
        leaves s as {4,1,2,3}. It would require named temporary variables to achieve the same
        thing using multiple statements, whereas the above form uses unnamed temps, which, 
        obviously enough, need not (and indeed cannot) be declared. However see performance 
        notes below (multiple assignment is designed for comfort and convenience not speed).
       <br>
       <br>
        As well as the syntax previously shown in <a href="variables.htm">Variables</a> and <a href="constants.htm">Constants</a>,
        you can also declare variables as part of (/mid-) multiple assignment, eg
<!--eucode>
    {string name, integer id} = lookup()
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#004080">string</font><font color="#000000"> name</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> id</font><font color="#0000FF">} =</font><font color="#000000"> lookup</font><font color="#0000FF">()</font>
</pre>
        however sub-types do /NOT/ propagate/carry-over-commas as you might expect, eg:
<!--eucode>
    {a, string b, c} = lookup()
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#004080"> string</font><font color="#000000"> b</font><font color="#0000FF">,</font><font color="#000000"> c</font><font color="#0000FF">} =</font><font color="#000000"> lookup</font><font color="#0000FF">()</font>
</pre>
        will terminate in error if b already exists, or if a <i>/<b>or c</b>/</i> does not already exist. 
        Use "string b, string c" instead, along with whatever you might need to do for a.
        While string {a, b, c} propagates the type, and declares three new variables of type string, 
        that does <i>/not/</i> happen for types inside the {}, except when the type immediately 
        precedes an opening/nested '{'. Admittedly this is a simple practical choice/implementation 
        detail (see pmain.e/GetMultiAssignSet()) that it may be possible to improve upon, but there 
        are four competing use cases for that routine, hence the simplest solution won (being reset 
        after every comma). Also, constructs such as string {a, integer b, c} are treated as nonsense 
        and trigger an error, but obviously you can simply move the "string" inside the {}, in that 
        particular case twice.
       <br>
       <br>
        Use '{}' (or '?') to omit elements
<!--eucode>
    {a,{},c} = {1,2,3}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#800000">{}</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} = {</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000">2</font><font color="#0000FF">,</font><font color="#000000">3</font><font color="#0000FF">}</font>
</pre>
        is functionally the same as
<!--eucode>
    c = 3
    a = 1
</eucode-->
<pre>
<font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> 3
    a</font><font color="#0000FF"> =</font><font color="#000000"> 1</font>
</pre>
        and ditto for "{a,?,c} = {1,2,3}".
       <br>
       <br>
        You can also omit everything:
<!--eucode>
    {} = f()
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {} =</font><font color="#000000"> f</font><font color="#0000FF">()</font>
</pre>
        which explicitly discards the result of the function call. Alternatively if you prefer
       <code>{?} = f()</code>
        has exactly the same effect (however
       <code>? = f()</code> is not legal syntax). Note that OpenEuphoria (imnsho 
        wrongly) allows /implicit/ discarding of function results, which Phix does not, whereas, cmiiw, OpenEuphoria 
        does not support any of the subscripting, nesting, "@=", "{}=", ":=", or "==" forms of (multiple) assignment 
        that Phix does.
       <br>
       <br>
        Like all powerful programming constructs, multiple assigment can be used to make things easier, but it can 
        also be abused to make things much more difficult than they need to be.
       <br>
       <br>
        <h2>How NOT to use multiple assigment</h2>
        You may be wondering why I appear to have written the equivalents "backwards".
        Any subscripts on the lhs are pushed onto opstack (in pmain.e) from left to right, hence the assignments are 
        always performed from right to left to pick up any subscripts from the top of the stack, in the right order. 
        (Actually, there is an exception to that rule, as explained in the technicalia section below.)
        Of course relying on such subtleties would constitute very bad practice, and in reality that is a fairly
        trivial implementation detail that could fairly easily be changed, if it ever proves necessary that is.
       <br>
       <br>
        One case where this may trip you is:
<!--eucode>
    {main,mainHwnd} = {create(Window,...),getHwnd(main)} -- error!
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">main</font><font color="#0000FF">,</font><font color="#000000">mainHwnd</font><font color="#0000FF">} = {</font><font color="#008080">create</font><font color="#800000">(</font><font color="#000000">Window</font><font color="#0000FF">,...</font><font color="#800000">)</font><font color="#0000FF">,</font><font color="#000000">getHwnd</font><font color="#800000">(</font><font color="#000000">main</font><font color="#800000">)</font><font color="#0000FF">}</font><font color="#000080"><i> -- error!</i></font>
</pre>
        Obviously you could rewrite that statement the other way round, but as the saying goes, debugging is several 
        times harder than writing code in the first place, therefore if you write tricky code you are, by definition, 
        not smart enough to debug it.
        <br>
        <br>
        <b>Update</b>: actually, you <i>cannot</i> write that "the other way round". Further illustrating the 
        "not smart enough" point, I failed to spot that the rhs is constructed in its entireity before any assignments 
        on the lhs, hence main would be unassigned whichever way round things were done [ie, as mentioned elsewhere, 
        you should <b><i>never</i></b> try to both modify and reference the same variable in a single statement, in 
        <i>any</i> programming language].
       <br>
       <br>
<!--
        At this point it is worth noting that using all of these features together in
        one statement could easily create completely unreadable code; ideally they
        should be used wisely to make code clearer rather than harder to understand.
        I should also warn you that I am just about to push the boundaries of what is 
        and is not possible with multiple assignment, and I trust it is understood
        that any "bad/ugly/confusing" stuff should be avoided at all costs.
       <br>
       <br>
        The first example of such things that springs to mind is the slightly dodgy:
-->
        Another example is the slightly dodgy:
<!--eucode>
    {s[idx],idx} = <something>
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">idx</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">idx</font><font color="#0000FF">} = &lt;</font><font color="#000000">something</font><font color="#0000FF">&gt;</font>
</pre>
        which is perhaps understandable, but may be "an accident waiting to happen".
        Clearly someone could read that and assume it is setting the old idx of s,
        before getting a new value of idx for something else later, but of course
        that would be the effect of {idx,s[idx]} = &lt;something&gt;. Not nice, really,
        either way round.
       <br>
       <br>
        Certainly the lhs should never rely on something having "already happened" on 
        the rhs, or otherwise attempt to modify something twice in a single statement,
        except for "static" subscripts. As an example to clarify that last point, if
        you try to make various substitutions in say "The [noun] [verb] the [object]",
        all in a single statement and possibly in any order, and further the lengths 
        and positions all change several times mid-statement, expect problems! Do them
        one at a time, and figure out where things are, after, rather than before they
        have moved(!!), and it should all be plain sailing.
       <blockquote>
    &lt;aside&gt;
        <br>
        <br>
        OK, to further clarify that, consider this longhand version:
<!--eucode>
            s = "The [noun] [verb] on the [object]"
            --   123456789012345678901234567890123
            --           -1-       -2-       -3-
            s[26..33] = "mat"
            s[12..17] = "sat"
            s[5..10] = "cat"
</eucode-->
<pre>
<font color="#000000">            s</font><font color="#0000FF"> =</font><font color="#008000"> "The [noun] [verb] on the [object]"
</font><font color="#000080"><i>            --   123456789012345678901234567890123
            --           -1-       -2-       -3-
</i></font><font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#0000FF">] =</font><font color="#008000"> "mat"
</font><font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#0000FF">] =</font><font color="#008000"> "sat"
</font><font color="#000000">            s</font><font color="#0000FF">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#0000FF">] =</font><font color="#008000"> "cat"</font>
</pre>
        which is fine, but you should really avoid this nastiness:
<!--eucode>
            {s[26..33],s[12..17],s[5..10]} = {"mat","sat","cat"}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}</font>
</pre>
        or this nasty mess:
<!--eucode>
            {s[5..10],s[12..17],s[26..33]} = {"cat","sat","mat"}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">}</font>
</pre>
        I bet that intuitively, if told one of them does not work most people would 
        assume the first works but the second does not, when in fact it is the other 
        way round. Few people would (immediately) understand what I have done with 
        the indexes to get (/force) these alternatives to work:
<!--eucode>
            {s[20..27],s[9..14],s[5..10]} = {"mat","sat","cat"}
            {s[20..27],s[5..10],s[12..17]} = {"mat","cat","sat"}
            {s[9..14],s[23..30],s[5..10]} = {"sat","mat","cat"}
            {s[9..14],s[5..10],s[26..33]} = {"sat","cat","mat"}
            {s[5..10],s[23..30],s[12..17]} = {"cat","mat","sat"}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">20</font><font color="#0000FF">..</font><font color="#000000">27</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">20</font><font color="#0000FF">..</font><font color="#000000">27</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">23</font><font color="#0000FF">..</font><font color="#000000">30</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">9</font><font color="#0000FF">..</font><font color="#000000">14</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">26</font><font color="#0000FF">..</font><font color="#000000">33</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"sat"</font><font color="#0000FF">,</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">}
            {</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">5</font><font color="#0000FF">..</font><font color="#000000">10</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">23</font><font color="#0000FF">..</font><font color="#000000">30</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">s</font><font color="#800000">[</font><font color="#000000">12</font><font color="#0000FF">..</font><font color="#000000">17</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#008000">"cat"</font><font color="#0000FF">,</font><font color="#008000">"mat"</font><font color="#0000FF">,</font><font color="#008000">"sat"</font><font color="#0000FF">}</font>
</pre>
        (Notice how "mat" goes to s[20..27], s[23..30] or s[26..33])
        Of course in a real world program, we would not use fixed literal
        integers but the results from find or match, and dynamically apply
        adjustments to those results. Technically it can be made to work,
        but regardless, this sort of stuff is truly horrid, don&rsquo;t do it!
        (except perhaps when participating in a code obfuscation contest)
        <br>
        <br>
    &lt;/aside&gt;
       </blockquote>

        Another example occured when writing the
       <a id="ext338" style="color:#9B5565" 
        href="javascript:ExternalLink('ext338','http://rosettacode.org/wiki/Reduced_row_echelon_form#Phix');">rosettacode/Reduced_row_echelon_form
       </a> entry. I tried to replace
<!--eucode>
sequence temp
        temp = M[i]
        M[i] = M[r]
        M[r] = sq_div(temp,temp[lead])
</eucode-->
<pre>
<font color="#000000"></font><font color="#004080">sequence</font><font color="#000000"> temp
        temp</font><font color="#0000FF"> =</font><font color="#000000"> M</font><font color="#0000FF">[</font><font color="#000000">i</font><font color="#0000FF">]
</font><font color="#000000">        M</font><font color="#0000FF">[</font><font color="#000000">i</font><font color="#0000FF">] =</font><font color="#000000"> M</font><font color="#0000FF">[</font><font color="#000000">r</font><font color="#0000FF">]
</font><font color="#000000">        M</font><font color="#0000FF">[</font><font color="#000000">r</font><font color="#0000FF">] =</font><font color="#5E005E"> sq_div</font><font color="#0000FF">(</font><font color="#000000">temp</font><font color="#0000FF">,</font><font color="#000000">temp</font><font color="#800000">[</font><font color="#000000">lead</font><font color="#800000">]</font><font color="#0000FF">)</font>
</pre>
        with
<!--eucode>
        {M[i],M[r]} = {M[r],sq_div(M[i],M[i][lead])
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">        {</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">i</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">r</font><font color="#800000">]</font><font color="#0000FF">} = {</font><font color="#000000">M</font><font color="#800000">[</font><font color="#000000">r</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#5E005E">sq_div</font><font color="#800000">(</font><font color="#000000">M</font><font color="#800080">[</font><font color="#000000">i</font><font color="#800080">]</font><font color="#0000FF">,</font><font color="#000000">M</font><font color="#800080">[</font><font color="#000000">i</font><font color="#800080">][</font><font color="#000000">lead</font><font color="#800080">]</font><font color="#800000">)</font>
</pre>
        It failed miserably when i=r, for the same "right to left" reasons (there is
        nothing wrong with the rhs per se, but the lhs overwrites in the wrong order).
        If it was my code to maintain, I would probably leave the top version in, but
        after some consideration I decided that a fixed version of the one-liner, with 
        an appropriate comment, was probably the more useful thing in that particular
        instance.
       <br>
       <br>
        The "{s[1],s[2..$]} = {s[$],s[1..$-1]}" example already given is perhaps the
        most complex thing that can be considered "static" subscripts. No s[i] is
        updated twice and there is no confusion or dependency on any destination, 
        though admittedly it relies on all "gathering" occuring before any update, 
        which is a general rule for all forms of assignment anyway. (And I should
        quickly remind you, again, to check out the performance notes below before 
        considering using such a statement.)
       <br>
       <br>
       <h2>Performance notes</h2>
        Multiple assignment is ideally suited to function results and table entries.
        If you are using {} or & on the rhs (at the top level) of a multiple assigmnent
        statement, then a longhand version will almost certainly be slightly faster, 
        due to the creation and subscripting of the temporary sequence being absent, 
        though obviously any such overhead is insignificant except in the most 
        crititical of inner loops, and as always there is no point pre-emptively 
        optimising anything unless profiling shows it really is expending some real 
        effort and time there.
       <br>
       <br>
        The "{s[1],s[2..$]} = {s[$],s[1..$-1]}" example given above obviously creates 
        an entirely new copy of s in a new temporary sequence, then copies it all back, 
        whereas "z = s[$], s = s[1..$-1], s = prepend(s,z)" can do things "in situ",
        and therefore exhibit exponetially better performance on very long sequences.
        Also worth noting is that "{s} = {append(s,stuff)}" will thwart optimisations
        that can get applied to the simpler "s = append(s,stuff)". Other cases exist.
       <br>
       <br>
        This is the reason I have used "functionally" quite excessively in this section,
        because the actual code emitted may be quite different, though it will achieve
        the same results. The compiler makes some attempts to avoid any such overheads, 
        but (as just shown) there are limits to what it can reasonably do. You may like
        to compare the list.asm from "p -d -nodiag t57" with and without the test flag
        "testemitONis0" being set.
       <br>
       <br>
        Another common idiom worth mentioning is the simple swap:
<!--eucode>
    {a,b} = {b,a}
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">} = {</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">a</font><font color="#0000FF">}</font>
</pre>
        which, as you probably already know and ignoring any (integer-only) xor tricks,
        has no longhand equivalent that does not use a (named) temporary variable. But
<!--eucode>
    tmp := b
    b := a
    a := tmp
</eucode-->
<pre>
<font color="#000000">    tmp</font><font color="#0000FF"> :=</font><font color="#000000"> b
    b</font><font color="#0000FF"> :=</font><font color="#000000"> a
    a</font><font color="#0000FF"> :=</font><font color="#000000"> tmp</font>
</pre>
        is noticeably faster (in a pointless benchmark) than the code the one-liner generates:
<!--eucode>
    tmp = {b,a}
    b = tmp[2]
    a = tmp[1]
</eucode-->
<pre>
<font color="#000000">    tmp</font><font color="#0000FF"> = {</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">a</font><font color="#0000FF">}
</font><font color="#000000">    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]
</font><font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
</pre>
        It would also be quite wrong to believe that additional variables always 
        introduce unnecessary overhead. In fact the compiler often has to introduce 
        an unnamed temporary which has /exactly/ the same costs as a named variable. 
        Apart from the disadvantage of having to declare s, the advantage to say
<!--eucode>
    s = f(...)
    {...} = s
</eucode-->
<pre>
<font color="#000000">    s</font><font color="#0000FF"> =</font><font color="#000000"> f</font><font color="#0000FF">(...)
    {...} =</font><font color="#000000"> s</font>
</pre>
        is that an ex.err may contain some extra valuable and time saving information.
        It would not normally be any slower (or faster) than the one-line version.
        In some cases, however, you may need to explicitly deassign ("s:={}") to avoid some
        hidden refcounting issue that the one-liner does not exhibit, conversely sometimes
        such an explicit deassign may circumvent a compiler refcount issue (/bug).
       <br>
       <br>
       <table>
        <col style="width: 8%"/>
        <tr>
         <td valign=top>
          <b>See Also:</b>
         </td>
         <td>
          <a href="variables.htm">variables</a>,
          <a href="constants.htm">constants</a>
         </td>
        </tr>
        <tr id="Technicalia" style="display:none;">
         <td valign=top>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
            There is a minor implementation caveat with "all equal": at least one of the protagonists must be a plain named variable (or the rhs a constant):
<!--eucode>
    {a[i],b[j]} @= f()
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#800000">[</font><font color="#000000">i</font><font color="#800000">]</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#800000">[</font><font color="#000000">j</font><font color="#800000">]</font><font color="#0000FF">} @=</font><font color="#000000"> f</font><font color="#0000FF">()</font>
</pre>
          <br>
            triggers the error "sorry, construct requires at least one plain var".
            The trouble is that the result of f() ends up in an un-named temporary, and moving 
            anything out of an un-named temporary (as a generally applied optimisation) avoids 
            an unnecessary incref by h4-ing the temp, leading to failure on the second attempt 
            to use the un-named temporary.
          <br>
          <br>
            In a statement such as
          <code>{a[i],b,c[k]} @= f()</code>, the compiler performs 
            the
          <code>b=f()</code> first, and uses b instead of the unnamed temp for the 
            remaining assignments. However when nothing with a name is available, then you 
            get the above error. Using additional un-named temps would not help; adding 
            "don't apply that optimisation" flags would get real messy real quick. There are
            (thankfully) no other language constructs that lead to this kind of error.
          <br>
          <br>
            Should this get really irksome, we /could/ (possibly) enhance the compiler to
            automatically perform
          <code>a[i] = b[j]</code> to complete the operation, but 
            unless we /really/ have to, I&rsquo;d prefer to avoid such complications. Bearing in 
            mind that we might have to repeat that trick for several terms, the difficulty 
            of adequate testing, the probability of adding further bugs, that it does not
            add any performance overhead, and that it potentially makes debugging easier, 
            it just seems better all round to force the programmer to use a named variable 
            to store the result of f() (or any other rhs expression).
          <br>
          <br>
            There is also an implementation detail (by comparison utterly trivial) for normal multiple assignment that I feel 
            I should at least document. Should the rhs be a plain variable, and further should it be assigned on the left, the 
            compiler automatically uses a temporary variable to avoid out-of-order operations (on the rhs, with that right-to-left 
            thing) yielding unexpected results, eg/ie:
<!--eucode>
    {a,b,c} = b
</eucode-->
<pre>
<font color="#000000"></font><font color="#0000FF">    {</font><font color="#000000">a</font><font color="#0000FF">,</font><font color="#000000">b</font><font color="#0000FF">,</font><font color="#000000">c</font><font color="#0000FF">} =</font><font color="#000000"> b</font>
</pre>
          <br>
            is equivalent to/implemented as
<!--eucode>
    c = b[3]
    tmp = b
    b = tmp[2]
    a = tmp[1]
</eucode-->
<pre>
<font color="#000000">    c</font><font color="#0000FF"> =</font><font color="#000000"> b</font><font color="#0000FF">[</font><font color="#000000">3</font><font color="#0000FF">]
</font><font color="#000000">    tmp</font><font color="#0000FF"> =</font><font color="#000000"> b
    b</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">2</font><font color="#0000FF">]
</font><font color="#000000">    a</font><font color="#0000FF"> =</font><font color="#000000"> tmp</font><font color="#0000FF">[</font><font color="#000000">1</font><font color="#0000FF">]</font>
</pre>
          <br>
            (because tmp is always subscripted, it is not subject to the same optimisation 
            trouble that we just saw in the "all equal" case above.) Obviously the compiler
            tries (hard) to avoid using a un-named temp unless it has no choice.
          <br>
          <br>
         </td>
        </tr>
       </table>
       <img src="images/sprites/tech.open.png" title="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
