--
-- filedump.exw
-- ============
--
--  Originally written to display the contents of Windows PE format executable files
--  and help me get my head around the import section, and therefore implement ilASM
--  statements such as: 'call "kernel32.dll","ReadFile"'. While similar programs are
--  available to download (not written in Phix), none of them would have been nearly
--  as helpful for writing the new routines in pemit.e (peek_import_table(), for use 
--  during interpretation, and read_import_table() for use in compilation). In fact,
--  F3/dump_import_table() is a hangover from that, and now serves very little or no
--  purpose, but equally there is no obvious gain from removing it.
--
--  It has since evolved to read 32 and 64 bit programs and dlls, and ELF files, and
--  other file formats may be added in future. The demo\hd.exw program could also be 
--  used to obtain a raw hex dump of any file. Of course, both those are really only
--  suitable for small test programs. A full dump of, say, p.exe is neither fast nor
--  particularly useful, to be honest with you. Note: this uses the same disassembly 
--  engine as "p -d"; it often displays "(??? 0 0)" instead of actual variable names
--  (since there is no pukka symtab here), and if (it finds any reason to think) the 
--  file is not Phix-generated, or is not pure code, it will hex dump it rather than 
--  disassemble it. Fairly obviously, the list.asm generated via "p -d" will contain
--  more and better details (labels etc) than a standalone binary dump such as this.
--
--  The PE executable file structure has evolved over many decades, and is quite scary.
--  Most of the constants and structures used are officially defined in winnt.h and for 
--  the most part I have kept the names from there completely unchanged. Whether or not 
--  this is actually useful to anyone else is not my problem ;-), but it is without any 
--  doubt whatsoever far easier than staring at raw hex dumps. Fairly obviously, should
--  this program flag an "error" with something, it is more likely to be a shortfall in
--  here rather than a problem in the exe/dll file.
--
--  In contrast the ELF format is a much newer development with far less concerns about
--  backward compatibility. It also cleanly separates details of execution (segments)
--  and linking (sections), and further since Phix (currently) just creates segments 
--  (program header table) not sections (linker info), only the most basic handling of 
--  the latter is attempted, which greatly simplifies matters. Obviously, getting this
--  program up and running, on Windows, and getting Phix to create ELF files (again on
--  Windows) is a good first step and avoids the "chicken and egg" problem of starting
--  from scratch on a standalone Linux box. For now, I can save any elf files I create
--  in a shared folder and test from inside Windows 7 using VirtualBox running Ubuntu.
--  Not that a Linux port is going to be easy or quick or anything, you understand.
--  Also (especially given the extreme flexibility of the elf specification) note this
--  may not fare particularly well on any non-Phix-generated elf files.
--  Lastly, I have made a start on ARM dissassembly, using the few examples I could 
--  find, with a view to eventually writing ELF/ARM for Linux/Android, but I have yet
--  to locate/install anything suitable for testing on.
--
--  The FLV file handling arose from stumbling upon an online article (I forget where)
--  and wondering if I could somehow repair things (see also flvmerge.exw), and (quite
--  sensibly) only skims the surface structure with a view to tweaking settings and/or
--  deleting corrupted blocks, and does not attempt to decipher any video/audio stream
--  or need to understand any of the plethora of possible codecs.. It remains somewhat
--  incomplete and never proved to be of any practical value (sorry!).
--
--  I have also dabbled a bit with .ico, .bmp, .edb, and .udd files. What happens is,
--  I wander in here, have a quick play, and leave yet something else unfinis....
--
-- This is one of the "cool" demos.
--
-- TODO:
--  keep separate scroll settings per tab. [DONE]
--  use the new file dialog (to get a preview when saving the "print")
--  **set global sequence knownAddr, knownNames [DONE]
--  sug: add edb files (started, got lost pretty quickly...)
--  sug: add a messages tab, rather than console output, and "Not Phix because..."              
--      [tab added, more testing rqd, some console messages are still being shown]
--      (eg p2asm/isPlausibleJumpTable, "cruft" in import secion, >6 sections, RVA!=start(section),
--          i>IMAGE_DIRECTORY_ENTRY_RESOURCE and i!=IMAGE_DIRECTORY_ENTRY_BASERELOC, ...)
--  BUG: opening (eg) cd.dll (64 bit) does not land on "Not Phix" properly, and fills
--       the display with "row error"
--
--  04/04/15 Added return/dblclick -> follow a "see #hhhhhhhh" automatically.
--
with trace
--DEV/TEMP
--constant WINDERS=WINDOWS
--constant WINDERS=LINUX

--#withtype Ihandle
--#withtype Ihandln
--#withtype nullable_string

--include arwen.ew
include pGUI.e

Ihandle maindlg, tabs, matrix, clipboard

--DEV windows only:
include builtins\timestamp.ew -- DateTimeStampToString and SYSTEMTIMEtoDateTimeStamp and FILETIMEtoDateTimeStamp
--/*
--constant FILETIMEdwLow = 0,
--       FILETIMEdwHigh = 4
--
--global function FILETIMEtoDateTimeStamp(atom pFileTime)
----
---- A FILETIME is a 64-bit value representing the number of 100-nanosecond intervals since Jan 1, 1601.
---- A DateTimeStamp is the number of seconds since Jan 1, 1970. There were 11644473600 seconds between
---- Jan 1,1601 and Jan 1,1970, so just subtract that (in 100-nanosecond intervals) and convert back to 
---- seconds. The result is an atom (good for another 70-odd million years) but be advised it overflows 
---- 32 bits (which is how most things store it) sometime on Jan 19, 2038.
----
--atom hns -- 100-nanosecond intervals
--  hns = (peek4u(pFileTime+FILETIMEdwLow)+peek4s(pFileTime+FILETIMEdwHigh)*#100000000)
--  return floor((hns-(11644473600*10000000))/10000000)
--end function
--*/

include builtins\timedate.e

set_timedate_formats({"Mmm dth yyyy hh:mm:ss"})
--set_timedate_formats({"D/M/YYYY"},"Mmm dth yyyy hh:mm:ss")
--constant Jan1st1970 = parse_date_string("1/1/1970")   -- (12:00:00am, ie {1970,1,1,0,0,0,0,0})
constant Jan1st1970 = {1970,1,1,0,0,0,0,0}

object RedFlag

integer tabidx

sequence tabnames = {}
sequence tabids = {}
sequence res -- sets [one per tab] of {address, description, size, value, notes} (for display)
constant R_TITLE = 1    -- idx to lvcolumns[j] [ie "Address".."Notes"]
constant R_ADDR = 1     -- idx to res
constant R_DESC = 2     -- idx to res
constant R_SIZE = 3     -- idx to res
constant R_VALUE = 4    -- idx to res
constant R_NOTES = 5    -- idx to res

integer address  -- note that address 0 corresponds to binary[1]

--constant UseNativeDialog = 01 -- (windows only)
--
--include builtins\fileopenN.ew --      ""

global sequence code_section
global constant vmap = {}, VMep = {}, codeTable = {}, codeIdx = {}
--global constant craddr = {}, cridx = {}, vmap = {}, symtab = {}, VMep = {}, opNames = {}, codeTable = {}, codeIdx = {}
global atom ImageBase = 0, CSvaddr = 0, CSvsize = 0, DSvaddr = 0, DSvsize = 0
--global constant S_NTyp = 0, S_vtype = 0, S_State = 0, S_value = 0, S_Name = 0, S_Type = 0, S_Func = 0, S_Const = 0, T_integer = 1, K_lit = 0, K_Fres = 0, S_Parm1 = 0, S_Slink = 0
include ..\..\pglobals.e
craddr = {}
global integer inFrame = 0, outFrame = 0
global constant opFrame = 17
global constant opCallOnce = 18
include ..\..\p2asm.e as p2asm

--DEV fix rein! (done in pIDE)
--constant string initialcurrentdir = get_proper_dir(command_line()[2])
constant cl = command_line()
constant string initialcurrentdir = get_proper_dir(cl[2])

function get_image(string image)
nullable_string res

    if length(image)=0 then
        res = NULL
    elsif image[1]='I' then -- (should be enough)
        res = image         -- stock image (see IupImageLibOpen)
    elsif platform()=WINDOWS
      and IupGetHandle(image)!=NULL then    -- (already loaded)
        res = image
    else
        string path = join_path({initialcurrentdir,"icons",image})
        if platform()=WINDOWS then

            -- use IM library to load image
            Ihandln handle = IupLoadImage(path)
            if handle=NULL then
                res = NULL
            else
                -- store the image handle
                IupSetHandle(image, handle)
                return image
            end if
        else -- LINUX
            -- natively supports PNG images
            res = path
        end if
    end if
    return res
end function

string lastpath
       lastpath = ""

string currentfilename
       currentfilename = ""

function copyname_cb(Ihandle /*file_copy*/)
--> setClipboardText(currentfilename,CF_TEXT)
    IupSetAttribute(clipboard,"TEXT",currentfilename)
    return IUP_DEFAULT;
end function
constant cb_copyname = Icallback("copyname_cb")

function exit_cb(Ihandle /*file_exit*/)
    return IUP_CLOSE
end function
constant cb_exit = Icallback("exit_cb")

constant titles = {"Address", "Description", "Size", "Value", "Notes"}
--       cwidth = {       80,            80,     80,     120,     240}

sequence awidths = {},
         origins = {},
         current = {}

function lvFormat(integer lRow, integer lColumn)
sequence ri
object rii, size
    if lColumn=0 then return 0 end if -- no icons [erm, that was arwen, in IUP that be title column?]
    ri = res[tabidx]
    if lRow>length(ri) then return "row error" end if
    ri = ri[lRow]
    if lColumn>length(ri) then return "column error" end if
    rii = ri[lColumn]
--  if rii=0 and ri={0,"-",0,0,""} then return "" end if -- from addsep()
--  if rii=0 and ri[2]="-" and lRow!=1 then return "" end if -- from addsep()/NotPhix()
    if rii=0 and length(ri[2]) and ri[2][1]='-' then return "" end if -- from addsep()/NotPhix()
--  if lColumn=1 then -- Address
    if lColumn=R_ADDR then -- Address (column 1)
        return sprintf("%08x",rii)
    elsif lColumn=R_DESC then -- Description (column 2)
        return rii
    elsif lColumn=R_SIZE then -- Size (column 3)
        if rii=0 then
            return ""
        elsif integer(rii) then
            return sprintf("%d",rii)
        else
            return rii
        end if
    elsif lColumn=R_VALUE then -- Value (column 4)
        size = ri[R_SIZE] -- (so we know how to display rii)
        if size=0 then
            return ""
        elsif integer(size) then
            return sprintf("%d",rii)
        elsif size="h1" then
            return sprintf("%02xh",rii)
        elsif size="h2" then
            return sprintf("%04xh",rii)
        elsif size="h3" then
            return sprintf("%06xh",rii)
        elsif size="h4" then
            return sprintf("%08xh",rii)
--      elsif size="h6" and rii!=0 then
--          return sprintf("%012xh",rii)
--      elsif size="h7" and rii!=0 then
--          return sprintf("%014xh",rii)
--      elsif size="h9" and rii!=0 then
--          return sprintf("%018xh",rii)
--      elsif size="h6"
--         or size="h7"
--         or size="h8"
--         or size="h9"
--         or size="h20" then
        elsif size="h8" then
--          if integer(rii) then
            if atom(rii) then
--              return sprintf("%g",rii)
                return sprintf("%16xh",rii)
            end if
--?rii
            return sprintf("%08x%08xh",rii)
--          return sprintf("%08x%08xZh",reverse(rii))
        elsif find(size,{"x","x2","x3","x4","x8","-"}) then
            return rii
        elsif length(size)>1 and size[1]='u' and find(size[2],"123456789") then
            return rii
        elsif size="f8" then
--          return sprint(rii)
            -- (if this is file-byte-order not little-endian or whatever, who cares?)
            return sprintf("%02x%02x%02x%02x%02x%02x%02x%02x",atom_to_float64(rii))
--          return sprintf("%02x%02x%02x%02x%02x%02x%02x%02xh",reverse(atom_to_float64(rii)))
        elsif size="f10" then
            return sprint(rii)
        else
            return sprintf("unknown size/format [%s] (%s)",{sprint(size),sprint(rii)})
        end if
    elsif lColumn=R_NOTES then
        return rii
    end if
    -- (should now never trigger)
--  return rii
    return 9/0
end function

string semiperm -- (return value of value_cb must outlive it)

function value_cb(Ihandle /*self*/, integer l, integer c)
    if c>=1 and c<=length(titles) then
        if l==R_TITLE-1 then
            semiperm = titles[c]    -- column title
        elsif tabidx<1
           or tabidx>length(res) then
            semiperm = "tabidx error"
        else
            semiperm = lvFormat(l,c)
        end if
        return IupRawStringPtr(semiperm)
    end if
    return NULL
end function
constant cb_value = Icallback("value_cb")

function enteritem_cb(Ihandle ih, integer lin, integer col)
    IupSetAttribute(ih,"MARKED", NULL)  /* clear all marks */
    IupMatSetAttribute(ih,"MARK", lin, 0, "Yes")
    IupSetStrAttribute(ih,"REDRAW", "L%d", {lin})
    IupSetStrAttribute(ih,"FOCUSCELL", "%d:%d", {lin,col})
    return IUP_DEFAULT
end function
constant cb_enteritem = Icallback("enteritem_cb")

function colresize_cb(Ihandle /*ih*/, integer col)
-- thwart attempts to resize column 0 (vertical titles)
    if col=0 then
        IupSetInt(matrix, "WIDTH0", NULL)
    end if
    return IUP_DEFAULT
end function
constant cb_colresize = Icallback("colresize_cb")

function resize_cb(Ihandle /*ih*/, integer width, integer /*height*/)
sequence widths = repeat(0,IupGetInt(matrix,"NUMCOL"))
integer total_width = 0, new_width
    for i=1 to length(widths) do
        widths[i] = IupGetIntId(matrix,"RASTERWIDTH",i)
    end for
    width -= 60
    if width<120 then width = 120 end if
    total_width = sum(widths)
    IupSetInt(matrix,"RASTERWIDTH0",0)
    for i=1 to length(widths) do
        new_width = max(floor((widths[i]/total_width)*width),10)
        IupSetIntId(matrix,"RASTERWIDTH",i,new_width)
    end for
--DEV I used this (in listview.exw) to set MINSIZE: 
--IupSetAttribute(dlg, "TITLE", IupGetAttribute(dlg,"SIZE"))
    return IUP_DEFAULT
end function
constant cb_resize = Icallback("resize_cb")


-->constant Main = create(Window,"",0,0,410,0,941,724,0)
-->constant mainDC = getPrivateDC(Main)
-->constant FileMenu = create(Menu,"File",0,Main,173,5,0,0,0)
-->constant OpenMenuItem = create(MenuItem,"Open\t(Ctrl O)",0,FileMenu,0,0,0,0,0)
-->constant PrintMenuItem = create(MenuItem,"Print\t(Ctrl P)",0,FileMenu,0,0,0,0,0)
-->constant CopyFileName = create(MenuItem,"Copy filename",0,FileMenu,0,0,0,0,0)
-->constant GraphicView = create(MenuItem,"Graphic View\t(F9)",0,FileMenu,0,0,0,0,0)
-->constant CloseMenuItem = create(MenuItem,"Exit\t(Escape/Alt F4)",0,FileMenu,0,0,0,0,0)
-->constant HelpMenu = create(Menu,"Help",0,Main,99,333,0,0,0)
-->constant HelpAboutMenuItem = create(MenuItem,"About\t(F1)",0,HelpMenu,0,0,0,0,0)
-->constant TabCtrl = create(TabControl,"TabControl",0,Main,5,9,712,25,0)
--constant lvcolumns = {{"Address",80},
--                    {"Description",80},
--                    {"Size",80},
--                    {"Value",120},
--                    {"Notes",240}}
-->constant lvflags = {{LVS_SHOWSELALWAYS,LVS_OWNERDATA},LVS_EX_FULLROWSELECT}
-->constant MainLV = create(ListView,lvcolumns,0,Main,5,34,712,585,lvflags)
--setFont(MainLV, "Courier New", 10, Normal)
-->constant CloseButton = create(Button,"Close",0,Main,642,628,75,29,0)
-->constant hTabCtrl = getHwnd(TabCtrl),
-->      hMainLV = getHwnd(MainLV),
-->      hClose = getHwnd(CloseButton)

--> [ use get_image("RedFlag.png") instead of setting the text colour ]

procedure SetTabIdx(string name)
--integer id
Ihandle tab
    ?{"SetTabIdx",name}
    tabidx = find(name,tabnames)
    if tabidx=0 then
        tabnames = append(tabnames,name)
        tabidx = length(tabnames)
-->     id = create(TabItem,name,0,TabCtrl,0,0,0,0,0)
        tab = IupHbox({IupFill()})
--      tabids = append(tabids,id)
        tabids = append(tabids,tab)
        res = append(res,{})
        awidths = append(awidths,-1)
        origins = append(origins,"1:1")
        current = append(current,"1:1")
        IupSetAttribute(tab, "TABTITLE", name)
        IupAppend(tabs,tab)
    end if
end procedure

function resetTabs()
    address = 0
    tabnames = {}
--> void = destroy(tabids)
    IupDestroy(tabids)
    tabids = {}
    res = {}
    awidths = {}
    origins = {}
    current = {}
    return -1
end function

--#without reformat
constant
          IMAGE_FILE_RELOCS_STRIPPED         = 0x0001,      -- Relocation info stripped from file.
          IMAGE_FILE_EXECUTABLE_IMAGE        = 0x0002,      -- File is executable (i.e. no unresolved externel references).
          IMAGE_FILE_LINE_NUMS_STRIPPED      = 0x0004,      -- Line numbers stripped from file. (deprecated)
          IMAGE_FILE_LOCAL_SYMS_STRIPPED     = 0x0008,      -- Local symbols stripped from file. (deprecated)
          IMAGE_FILE_AGGRESIVE_WS_TRIM       = 0x0010,      -- Agressively trim working set. (obsolete)
          IMAGE_FILE_LARGE_ADDRESS_AWARE     = 0x0020,      -- App can handle >2gb addresses
--                                             0x0040,      -- Reserved for future use
          IMAGE_FILE_BYTES_REVERSED_LO       = 0x0080,      -- Bytes of machine word are reversed. (deprecated)
          IMAGE_FILE_32BIT_MACHINE           = 0x0100,      -- 32 bit word machine.
          IMAGE_FILE_DEBUG_STRIPPED          = 0x0200,      -- Debugging info stripped from file in .DBG file
          IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400,      -- If Image is on removable media, copy and run from the swap file.
          IMAGE_FILE_NET_RUN_FROM_SWAP       = 0x0800,      -- If Image is on Net, copy and run from the swap file.
          IMAGE_FILE_SYSTEM                  = 0x1000,      -- System File.
          IMAGE_FILE_DLL                     = 0x2000,      -- File is a DLL.
          IMAGE_FILE_UP_SYSTEM_ONLY          = 0x4000,      -- File should only be run on a UniProcessor machine
          IMAGE_FILE_BYTES_REVERSED_HI       = 0x8000,      -- Bytes of machine word are reversed. (deprecated)

    FileHeaderCharacteristicSet = {

        -- Descriptions kept short as not much space for them,
        --  and ordered in the way we would like them shown:
        { IMAGE_FILE_32BIT_MACHINE,             "32BIT" },
        { IMAGE_FILE_EXECUTABLE_IMAGE,          "EXEC" },
        { IMAGE_FILE_DLL,                       "DLL" },
        { IMAGE_FILE_RELOCS_STRIPPED,           "-RELOCS" },
        { IMAGE_FILE_LINE_NUMS_STRIPPED,        "-LINES?" },
        { IMAGE_FILE_LOCAL_SYMS_STRIPPED,       "-LOCALS?" },
        { IMAGE_FILE_DEBUG_STRIPPED,            "-DEBUG" },
        { IMAGE_FILE_LARGE_ADDRESS_AWARE,       "LARGE_ADDR" },
        { IMAGE_FILE_AGGRESIVE_WS_TRIM,         "WS_TRIM?" },
        { IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP,   "REMRUN" },
        { IMAGE_FILE_NET_RUN_FROM_SWAP,         "NETRUN" },
        { IMAGE_FILE_SYSTEM,                    "SYSTEM" },
        { IMAGE_FILE_UP_SYSTEM_ONLY,            "UPSYS_ONLY" },
        { IMAGE_FILE_BYTES_REVERSED_LO,         "REVLO?" },
        { IMAGE_FILE_BYTES_REVERSED_HI,         "REVHI?" }}

constant
--        IMAGE_SCN_TYPE_REG                = 0x00000000,   -- Reserved.
--        IMAGE_SCN_TYPE_DSECT              = 0x00000001,   -- Reserved.
--        IMAGE_SCN_SCALE_INDEX             = 0x00000001,   -- Tls index is scaled
--        IMAGE_SCN_TYPE_NOLOAD             = 0x00000002,   -- Reserved.
--        IMAGE_SCN_TYPE_GROUP              = 0x00000004,   -- Reserved.
--        IMAGE_SCN_TYPE_NO_PAD             = 0x00000008,   -- Reserved. obsolete/replaced by IMAGE_SCN_ALIGN_1BYTES. valid only for object files.
--        IMAGE_SCN_TYPE_COPY               = 0x00000010,   -- Reserved.
          IMAGE_SCN_CNT_CODE                = 0x00000020,   -- Section contains executable code.
          IMAGE_SCN_CNT_INITIALIZED_DATA    = 0x00000040,   -- Section contains initialized data.
          IMAGE_SCN_CNT_UNINITIALIZED_DATA  = 0x00000080,   -- Section contains uninitialized data.
--        IMAGE_SCN_LNK_OTHER               = 0x00000100,   -- Reserved.
--        IMAGE_SCN_LNK_INFO                = 0x00000200,   -- Section contains comments or some other type of information. Object files only.
--        IMAGE_SCN_TYPE_OVER               = 0x00000400,   -- Reserved.
--        IMAGE_SCN_LNK_REMOVE              = 0x00000800,   -- Section contents will not become part of image. Object files only.
--        IMAGE_SCN_LNK_COMDAT              = 0x00001000,   -- Section contains comdat. Object files only.
--                                          = 0x00002000,   -- Reserved.
--        IMAGE_SCN_MEM_PROTECTED           = 0x00004000,   -- Obsolete
--        IMAGE_SCN_NO_DEFER_SPEC_EXC       = 0x00004000,   -- Reset speculative exceptions handling bits in the TLB entries for this section.
--        IMAGE_SCN_GPREL                   = 0x00008000,   -- Section content can be accessed relative to GP
--        IMAGE_SCN_MEM_FARDATA             = 0x00008000,
--        IMAGE_SCN_MEM_SYSHEAP             = 0x00010000,   -- Obsolete
--        IMAGE_SCN_MEM_PURGEABLE           = 0x00020000,   -- Reserved for future use.
--        IMAGE_SCN_MEM_16BIT               = 0x00020000,   -- For ARM machine types, the section contains Thumb code.  Reserved for future use with other machine types.
--        IMAGE_SCN_MEM_LOCKED              = 0x00040000,   -- Reserved for future use.
--        IMAGE_SCN_MEM_PRELOAD             = 0x00080000,   -- Reserved for future use.
--        IMAGE_SCN_ALIGN_1BYTES            = 0x00100000,   -- Valid only for object files
--        IMAGE_SCN_ALIGN_2BYTES            = 0x00200000,   -- ""
          IMAGE_SCN_ALIGN_4BYTES            = 0x00300000,   -- ""
--        IMAGE_SCN_ALIGN_8BYTES            = 0x00400000,   -- ""
          IMAGE_SCN_ALIGN_16BYTES           = 0x00500000,   -- "" Default alignment if no others are specified.
--        IMAGE_SCN_ALIGN_32BYTES           = 0x00600000,   -- ""
--        IMAGE_SCN_ALIGN_64BYTES           = 0x00700000,   -- ""
--        IMAGE_SCN_ALIGN_128BYTES          = 0x00800000,   -- ""
--        IMAGE_SCN_ALIGN_256BYTES          = 0x00900000,   -- ""
--        IMAGE_SCN_ALIGN_512BYTES          = 0x00A00000,   -- ""
--        IMAGE_SCN_ALIGN_1024BYTES         = 0x00B00000,   -- ""
--        IMAGE_SCN_ALIGN_2048BYTES         = 0x00C00000,   -- ""
--        IMAGE_SCN_ALIGN_4096BYTES         = 0x00D00000,   -- ""
--        IMAGE_SCN_ALIGN_8192BYTES         = 0x00E00000,   -- ""
--        IMAGE_SCN_ALIGN_MASK              = 0x00F00000,   -- ""
--        IMAGE_SCN_LNK_NRELOC_OVFL         = 0x01000000,   -- Section contains extended relocations.
          IMAGE_SCN_MEM_DISCARDABLE         = 0x02000000,   -- Section can be discarded.
--        IMAGE_SCN_MEM_NOT_CACHED          = 0x04000000,   -- Section is not cachable.
          IMAGE_SCN_MEM_NOT_PAGED           = 0x08000000,   -- Section is not pageable.
          IMAGE_SCN_MEM_SHARED              = 0x10000000,   -- Section is shareable.
          IMAGE_SCN_MEM_EXECUTE             = 0x20000000,   -- Section is executable.
          IMAGE_SCN_MEM_READ                = 0x40000000,   -- Section is readable.
          IMAGE_SCN_MEM_WRITE               = 0x80000000,   -- Section is writeable.

    SectionCharacteristicSet = {

        { IMAGE_SCN_CNT_CODE,               "code"},
        { IMAGE_SCN_MEM_EXECUTE,            "executable"},
        { IMAGE_SCN_MEM_READ,               "read"},
        { IMAGE_SCN_MEM_WRITE,              "write"},
        { IMAGE_SCN_MEM_SHARED,             "shared"},
        { IMAGE_SCN_CNT_INITIALIZED_DATA,   "init"},
        { IMAGE_SCN_CNT_UNINITIALIZED_DATA, "uninit"},
        { IMAGE_SCN_MEM_DISCARDABLE,        "discardable"},
        { IMAGE_SCN_ALIGN_4BYTES,           "align4"},
        { IMAGE_SCN_ALIGN_16BYTES,          "align16"},
        { IMAGE_SCN_MEM_NOT_PAGED,          "not paged"}}

constant
--        IMAGE_LIBRARY_PROCESS_INIT                        = 0x0001,   -- Reserved, must be zero. \
--        IMAGE_LIBRARY_PROCESS_TERM                        = 0x0002,   -- Reserved, must be zero.  \ (?)
--        IMAGE_LIBRARY_THREAD_INIT                         = 0x0004,   -- Reserved, must be zero.  /
--        IMAGE_LIBRARY_THREAD_TERM                         = 0x0008,   -- Reserved, must be zero. /
          IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE             = 0x0040,   -- DLL can be relocated at load time.
          IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY          = 0x0080,   -- Code Integrity checks are enforced.
          IMAGE_DLLCHARACTERISTICS_NX_COMPAT                = 0x0100,   -- Image is NX compatible
          IMAGE_DLLCHARACTERISTICS_NO_ISOLATION             = 0x0200,   -- Image understands isolation and doesn't want it
          IMAGE_DLLCHARACTERISTICS_NO_SEH                   = 0x0400,   -- Image does not use SEH.  No SE handler may reside in this image
          IMAGE_DLLCHARACTERISTICS_NO_BIND                  = 0x0800,   -- Do not bind this image. [DEV Phix should probably always specify this?]
--                                                          = 0x1000,   -- Reserved, must be zero.
          IMAGE_DLLCHARACTERISTICS_WDM_DRIVER               = 0x2000,   -- Driver uses WDM model
--                                                          = 0x4000,   -- Reserved.
          IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE    = 0x8000,   -- Terminal Server aware.

    DllCharacteristicSet = {

        { IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE,            "DynamicBase"},
        { IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY,         "ForceIntegrity"},
        { IMAGE_DLLCHARACTERISTICS_NX_COMPAT,               "NXcompat"},
        { IMAGE_DLLCHARACTERISTICS_NO_ISOLATION,            "NoIsolation"},
        { IMAGE_DLLCHARACTERISTICS_NO_SEH,                  "NoSEH"},
        { IMAGE_DLLCHARACTERISTICS_NO_BIND,                 "NoBind"},
        { IMAGE_DLLCHARACTERISTICS_WDM_DRIVER,              "WDMdriver"},
        { IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE,   "TSaware"}},


    -- Segment (Execution View) flag bits (ELF).

          PF_X  = 1,  -- Execute
          PF_W  = 2,  -- Write
          PF_R  = 4,  -- Read

    ELFpflagSet = {
        { PF_R, "Read"},
        { PF_X, "Execute"},
        { PF_W, "Write"}},

    -- Section (Linking View) flag bits (ELF).

          SHF_WRITE             = 0x001,        /* Writable */
          SHF_ALLOC             = 0x002,        /* Occupies memory during execution */
          SHF_EXECINSTR         = 0x004,        /* Executable */
            --??                = 0x008,
          SHF_MERGE             = 0x010,        /* Might be merged */
          SHF_STRINGS           = 0x020,        /* Contains nul-terminated strings */
          SHF_INFO_LINK         = 0x040,        /* `sh_info' contains SHT index */
          SHF_LINK_ORDER        = 0x080,        /* Preserve order after combining */
          SHF_OS_NONCONFORMING  = 0x100,        /* Non-standard OS specific handling required */
          SHF_GROUP             = 0x200,        /* Section is member of a group.  */
          SHF_TLS               = 0x300,        /* Section hold thread-local data.  */
--        SHF_MASKOS            = 0x0ff00000    /* OS-specific.  */
--        SHF_MASKPROC          = 0xf0000000    /* Processor-specific */
--        SHF_ORDERED           = (1 << 30)     /* Special ordering requirement (Solaris). */
--        SHF_EXCLUDE           = (1 << 31)     /* Section is excluded unless referenced or allocated (Solaris).*/

    ELFsflagSet = {
        { SHF_WRITE,            "writeable"},
        { SHF_ALLOC,            "alloc"},
        { SHF_EXECINSTR,        "executable"},
        { SHF_MERGE,            "merge"},
        { SHF_STRINGS,          "strings"},
        { SHF_INFO_LINK,        "info link"},
        { SHF_LINK_ORDER,       "link order"},
        { SHF_OS_NONCONFORMING, "OS n/c"},
        { SHF_GROUP,            "grp"},
        { SHF_TLS,              "tls"}},

    FLVhFlagSet = {
        { 0x04, "audio"},
        { 0x01, "video"}}

--/*

//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000
//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

/* Image resource directory */
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY;

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } DUMMYSTRUCTNAME;
        DWORD   Name;
        WORD    Id;
    } DUMMYUNIONNAME;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

/* Image resource directory string */
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;

/* Image resource directory string (Unicode version) */
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

/* Image resource data entry */
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;


// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.

#define IMPORT_OBJECT_HDR_SIG2  0xffff

typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD    Sig2;                       // Must be IMPORT_OBJECT_HDR_SIG2.
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              // Time/date stamp
    DWORD   SizeOfData;                 // particularly useful for incremental links

    union {
        WORD    Ordinal;                // if grf & IMPORT_OBJECT_ORDINAL
        WORD    Hint;
    } DUMMYUNIONNAME;

    WORD    Type : 2;                   // IMPORT_TYPE
    WORD    NameType : 3;               // IMPORT_NAME_TYPE
    WORD    Reserved : 11;              // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal
    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @
} IMPORT_OBJECT_NAME_TYPE;

--*/

--#with reformat

integer file_size
sequence binary

integer e_lfanew

constant escapes = "\0\t\r\n"
constant escaped = "0trn"

function toString(integer size)
integer ch
integer escidx
string res = ""
integer instring = 0
integer nostrip = 0
integer i

    i = 1
    while 1 do -- until (size=-1 and ch = '\0') or (size!=-1 and i>size)
        ch = binary[address+i]
        if size=-1 then
            if ch='\0' then exit end if
        end if
        escidx = find(ch,escapes)
        if escidx!=0
        or (ch>=' ' and ch<='~') then
            if not instring then
                if length(res) then
                    res &= "&"
                    nostrip = 1
                end if
                res &= "\""
                instring = 1
            end if
            if escidx!=0 then
                res &= "\\"&escaped[escidx]
            else
                res &= ch
            end if
        else
            if instring then
                res &= "\""
                instring = 0
            end if
            if length(res) then
                res &= "&"
                nostrip = 1
            end if
            res &= sprintf("0x%02x",ch)
        end if
        i += 1
        if size!=-1 then
            if i>size then exit end if
        end if
    end while
    if instring then
        if nostrip then
            res &= "\""
        else
            res = res[2..$] -- (remove opening \")
        end if
    end if
    return res
end function


constant atom h8a = allocate(8),
         integer h8i = floor(h8a/4)     -- (easier for ilASM)

function reconstitute_int64(sequence s8)
-- While 64-bit apps use 80-bit floats, which have 64 bits of precision,
--  32-bit apps use 64-bit floats, which only have 53 bits of precision.
-- This retrieves "normal" numbers as "normal" values (eg 0,1,-1,237),
--  but eg #8000000000000001 (or more accurately {1,0,0,0,0,0,0,#80}),
--  as {#80000000,1}, ie {hi_dword,lo_dword}, rather than minus the 1.
-- (If invoked on 64-bit, does a pointless peek and returns an atom.)   [DEV, try below (once this has been ported to pGUI)]
object res
    poke(h8a,s8)
    #ilASM{
-- untested on 64 bit:
        [32]
            mov eax,[h8i]
            lea edi,[res]
            fild qword[ebx+eax*4]
            call :%pStoreFlt        -- ([edi]:=ST0)
--          [PE32,ELF32]
            mov eax,[res]
            mov edi,[h8i]
            cmp eax,h4
--          jl %opRetf
            jl :%opRetf
            fld qword[ebx+eax*4]
            fistp qword[ebx+edi*4]
        [64]
            mov rax,[h8i]
            lea rdi,[res]
            fild qword[rbx+rax*4]   -- (assume signed)
            call :%pStoreFlt        -- ([edi]:=ST0)
--          mov rax,[res]
--          mov rdi,[h8i]
--          cmp rax,h4
--          jl %opRetf
--          fld tbyte[rbx+rax*4]
--          fistp tbyte[rbx+rdi*4]
        []
          }
    if peek({h8a,8})=s8 then
        return res
    end if
    poke(h8a,s8)
    return reverse(peek4u({h8a,2}))
end function

--/*
SUG: (untried)
function reconstitute_int64(sequence s8)
-- While 64-bit apps use 80-bit floats, which have 64 bits of precision,
--  32-bit apps use 64-bit floats, which only have 53 bits of precision.
-- This retrieves "normal" numbers as "normal" values (eg 0,1,-1,237),
--  but eg #8000000000000001 (or more accurately {1,0,0,0,0,0,0,#80}),
--  rather than minus the 1, as {#80000000,1}, ie {hi_dword,lo_dword}.
object res
    poke(h8a,s8)
    if machine_bits()=64 then
        #ilASM{ 
                mov rax,[h8i]
                lea rdi,[res]
                fild qword[rbx+rax*4]       -- (assume signed)
                call %:pStoreFlt            -- ([rdi]:=ST0)
              }
        return res
    else -- 32 bit
        #ilASM{ 
                mov eax,[h8i]
                lea edi,[res]
                fild qword[ebx+eax*4]
                call %:pStoreFlt            -- ([edi]:=ST0)
                mov eax,[res]
                mov edi,[h8i]
                cmp eax,h4
                jl %opRetf
                fld qword[ebx+eax*4]
                fistp qword[ebx+edi*4]
              }
        if peek({h8a,8})=s8 then
            return res
        end if
        poke(h8a,s8)
        return reverse(peek4u({h8a,2}))
    end if
end function

--*/

integer asHex = 0 -- Normally (with asHex=0) we want the real number, so #01,#00 -> #0001, not #0100 (=256).
                  -- For disassembly: code, and numbers embedded in it, should be shown as-is, little-endian.
                  -- eg mov dx,1 is "BA 01 00", whereas "00 01 BA" would just be completely misleading drivel.
                  -- That is, asHex can be set to 1 before calling decode(), and reset once we're finished.
                  -- Incidentally, xN/toString behave "as asHex=1" but of course we do not want our mov dx,1
                  -- shown as "0xBA&0x01&0x00" or worse mix in some character literals in the middle.

constant mul = {#1,#100,#10000,#1000000,#100000000,#10000000000,#1000000000000,#100000000000000}

integer signed
integer xlen

--include builtins\pfloat.e -- float80_to_atom

function decode(string description, object size, string notes="")
object val
sequence line
integer byte
atom mi
    line = {address,description,size,0,notes}
    if string(size)
    and size[1]='h' then
        if size="h" then
            size = xlen
        elsif size="h1" then
            size = 1
        elsif size="h2" then
            size = 2
        elsif size="h3" then
            size = 3
        elsif size="h4" then
            size = 4
        elsif size!="h8" then
            ?9/0
        end if
    end if
    if integer(size) then
        signed = 0
        val = binary[address+1]
        for i=2 to size do
            byte = binary[address+i]
            if asHex then
                val = val*#100+byte
            else
                if byte!=0 then
                    if i<=length(mul) then
                        mi = mul[i]
                    else
                        mi = power(2,(i-1)*8)
                    end if
                    if i=size and size>4 and and_bits(byte,#80) then
                        byte -= #80
                        signed = 1
                        if byte!=0 then
                            val += byte*mi
                        end if
                    else
                        val += byte*mi
                    end if
                end if
            end if
        end for
    elsif size="x" then
        val = toString(xlen)
        size = xlen
    elsif size="x2" then
        val = toString(2)
        size = 2
    elsif size="x3" then
        val = toString(3)
        size = 3
    elsif size="x4" then
        val = toString(4)
        size = 4
    elsif size="x8" then
        val = toString(8)
        size = 8
    elsif size="f8" then
        val = float64_to_atom(binary[address+1..address+8])
        size = 8
    elsif size="f10" then
        val = float80_to_atom(binary[address+1..address+10])
        size = 10
    elsif size="h8" then
        val = reconstitute_int64(binary[address+1..address+8])
        size = 8
    else
        val = "unknown size"
    end if
    line[4] = val
    res[tabidx] = append(res[tabidx],line)
    address += size
    return val
end function

function WideCharToAnsi(sequence s)
integer l = length(s)
atom pInBuff = allocate(l)
--integer nLen
--atom pOutBuff
string res
    poke(pInBuff,s)
    l = floor(l/2)
--> nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,NULL,0,NULL,NULL})
    res = utf16_to_utf8(peek2u({pInBuff,l}))
--  pOutBuff = allocate(nLen)
--  nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,pOutBuff,nLen,NULL,NULL})
--  res = peek({pOutBuff,nLen})
--  free(pOutBuff)
    free(pInBuff)
    return res
end function

string unicode_string
function decode_unicode_string(string description, integer size=-1, string notes="")
sequence line
integer word
    if size=-1 then
        size = 0
        while 1 do
            word = binary[address+size+1]+binary[address+size+2]*#100
            size += 2
            if word=0 then exit end if
        end while
    end if
    unicode_string = WideCharToAnsi(binary[address+1..address+size-2])
--(DEV) this complains, I think, because it suspects that address or
--      unicode_string could be modified by the sprintf() call...
--      [should probably add this as an example to the docs... [DEV/DOCS]]
--  line = {address,description,sprintf("u%d",size/2-1),unicode_string,notes}
    string s = sprintf("u%d",size/2-1)
    line = {address,description,s,unicode_string,notes}
    res[tabidx] = append(res[tabidx],line)
    address += size
    return size
end function

function fatal(string msg)
sequence line
    line = {address,msg,0,0,""}
    res[tabidx] = append(res[tabidx],line)
--> setTextColour(tabids[tabidx], #0000FF) -- red
    IupSetAttributeId(tabs,"TABIMAGE", tabidx-1, RedFlag)
--  IupSetAttributeId(tabs,"TABIMAGE", 1, NULL) -- yes (clears)???
    return 0
end function

procedure addsep(string desc="")
sequence line
--  line = {0,"-",0,0,""}
    line = {0,"-",0,0,desc}
--  line = {0,desc,0,0,"-"}
    res[tabidx] = append(res[tabidx],line)
end procedure

procedure addsymtabsep(string desc="")
sequence line
    line = {0,desc,0,0,""}
    res[tabidx] = append(res[tabidx],line)
end procedure

function get_string(integer address)
integer ch
string res = ""
    while 1 do -- (until ch = '\0')
        address += 1
        ch = binary[address]
        if ch='\0' then exit end if
        res &= ch
    end while
    return res
end function

function get_integer(integer address)
object val = 0
    for i=1 to 4 do
        val += binary[address+i]*mul[i]
    end for
    return val
end function

--DEV use this elsewhere
procedure binary_dump(integer size, string desc)
--
-- Show remainder with first chunk up to a 16-byte boundary,
-- and rest in (whole) 16-byte blocks (for nicer addresses)
-- Displays binary[address..address+size-1], ie address is a
-- real file address. Also, if desc contains "%08x", displays 
-- (and increments) addr, which can therefore be a virtual 
-- address.
--
string hex, text
sequence line
integer addrMax
integer byte
    if size<0 then ?9/0 end if
    while size do
        hex = ""
        text = ""
--29/8/14:
--      if size<16 then
        if size<=16 then
            addrMax = address+size-1
        else
            addrMax = address+16
            addrMax -= and_bits(addrMax,#0F)+1
        end if
        for a=address to addrMax do
--DEV 5/9/15:
--if a>=length(binary) then ?804 size=0 exit end if
            byte = binary[a+1]
            hex &= sprintf("%02x",byte)
            if remainder(a+5,4)=0 then
                hex &= ' '
            end if
            if byte<' ' or byte>#7E then byte = '.' end if
            text &= byte
        end for
        if match("%08x",desc) then
            line = {address,sprintf(desc,{addr}),"-",hex,text,""}
            addr += (addrMax-address+1)
        else
            line = {address,desc,"-",hex,text,""}
        end if
        res[tabidx] = append(res[tabidx],line)
        size -= (addrMax-address+1)
        address = addrMax+1
    end while
end procedure

sequence NotPhixMessages

integer wasZZ = 0
procedure NotPhix(string msg)
    if not wasZZ and not find(msg,NotPhixMessages) then
        NotPhixMessages = append(NotPhixMessages,msg)
        setnotphix()
    end if
end procedure

procedure ShowNotPhix()
sequence line
    if length(NotPhixMessages) then
        SetTabIdx("Not Phix")
        line = {0,"-",0,0,""}
        for i=1 to length(NotPhixMessages) do
            line[5] = NotPhixMessages[i]
            res[tabidx] = append(res[tabidx],line)
        end for
-->     setTextColour(tabids[tabidx], #0000FF) -- red
        IupSetAttributeId(tabs,"TABIMAGE", tabidx-1, RedFlag)
    end if
end procedure

integer machine

--global 
constant --T_integer = 1,
                T_N         = 2,    -- float but not atom (internal use only)
                T_atom      = 3,
                T_Dsq       = 4,    -- dword sequence but not string (internal use only)
                T_string    = 8,
                T_sequence  = 12,
                T_object    = 15,
--              typeINSPO   = {T_integer,T_atom,T_string,T_sequence,T_object},
                T_pathset   = 16,
                T_fileset   = 17,
                T_nslink    = 18,
                T_cmdlnflg  = 19,
--              T_callstk   = 20,
--29/3/15:
                T_optable   = 20,
                T_maintls   = 21,
                T_EBP       = 22,   -- spare
                T_ds4       = 23,
                T_constm1   = 24,
                T_const0    = 25,
                T_const1    = 26        -- (also used as limit in pcfunc.e and pdiag.e)

sequence stdescs = repeat("",T_const1)
         stdescs[T_integer] = "T_integer"
         stdescs[T_N] = "T_N"
         stdescs[T_atom] = "T_atom"
         stdescs[T_Dsq] = "T_Dsq"
         stdescs[T_string] = "T_string"
         stdescs[T_sequence] = "T_sequence"
         stdescs[T_object] = "T_object"
         stdescs[T_pathset] = "T_pathset"
         stdescs[T_fileset] = "T_fileset"
         stdescs[T_nslink] = "T_nslink"
         stdescs[T_cmdlnflg] = "T_cmdlnflg"
--       stdescs[T_callstk] = "T_callstk"
         stdescs[T_optable] = "T_optable"
         stdescs[T_maintls] = "T_maintls"
         stdescs[T_EBP] = "T_EBP"
         stdescs[T_ds4] = "T_ds4"
         stdescs[T_constm1] = "T_constm1"
         stdescs[T_const0] = "T_const0"
         stdescs[T_const1] = "T_const1"

constant SYMTABN = #01,
         LINETAB = #02,
         SYMDESC = #04,
         GVARDDR = #08

constant tdesc = {"S_Const","S_GVar","S_TVar","S_Nspc","S_Rsvd","S_Type","S_Func","S_Proc"}
integer siNTyp

constant StateSet = {
                     {S_used,"S_used"},
                     {S_set,"S_set"},
                     {S_fwd,"S_fwd"},
                     {S_for,"S_for"},
                     {K_used,"K_used"},
                     {K_sqr,"K_sqr"},
                     {K_aod,"K_aod"},
                     {K_wdb,"K_wdb"},
                     {K_noclr,"K_noclr"},
                     {K_rtn,"K_rtn"},
                     {K_ran,"K_ran"},
                     {K_gbl,"K_gbl"},
                     {K_Fres,"K_Fres"},
                     {K_lit,"K_lit"},
                     {K_type,"K_type"},
                     {K_othr,"K_othr"},
                     {K_ridt,"K_ridt"},
                     {K_dlft,"K_dlft"}}

procedure SymtabN(object v, integer i)
string desc = ""
string notes = "", prev
integer ps, pe
--integer siState

    if i=S_Name then
        desc = "S_Name"
    elsif i=S_NTyp then
        desc = "S_NTyp"
        siNTyp = v
        if siNTyp<1 or siNTyp>length(tdesc) then
            notes = "????"
        else
            notes = tdesc[siNTyp]
        end if
    elsif i=S_FPno then
        desc = "S_FPno"
        notes = sprintf("%d",v)
    elsif i=S_State then
        desc = "S_State"
        notes = decode_flags(StateSet,v)
    elsif i=S_Nlink then
        desc = "S_Nlink"
        notes = sprintf("%d",v)
    elsif i=S_Slink then
        desc = "S_Slink"
        notes = sprintf("%d",v)
    elsif siNTyp<=S_TVar then   -- S_Const/S_GVar2/S_TVar
        if i=S_vtype then
            desc = "S_vtype"
--DEV to go
        elsif i=S_value then
            desc = "S_value"
        elsif siNTyp=S_TVar then
            if i=S_Tidx then
                desc = "S_Tidx"
                notes = sprintf("%d",v)
            end if
        else
--DEV to go
            if i=S_Clink then
                desc = "S_Clink"
                notes = sprintf("%d",v)
            end if
        end if
    elsif siNTyp<=S_Rsvd then   -- S_Nspc/S_Rsvd
        if siNTyp=S_Nspc
        and i=S_nFno then
            desc = "S_nFno"
        end if
    else                        -- S_Type/S_Func/S_Proc
        if i=S_sig then
            desc = "S_sig"
        elsif i=S_Parm1 then
            desc = "S_Parm1"
            notes = sprintf("%d",v)
        elsif i=S_ParmN then
            desc = "S_ParmN"
            notes = sprintf("%d",v)
        elsif i=S_Ltot then
            desc = "S_Ltot"
            notes = sprintf("%d",v)
        elsif i=S_il then
            desc = "S_il"
        elsif i=S_ltab then
            desc = "S_ltab"
        elsif i=S_1stl then
            desc = "S_1stl"
            notes = sprintf("%d",v)
--      elsif i=S_Name then
        end if
    end if
    if length(desc) then
        prev = res[tabidx][$][R_DESC]
        ps = match("dseq[",prev)
        pe = find(']',prev,ps)
        prev[ps..pe] = desc
        res[tabidx][$][R_DESC] = prev
    end if
    if length(notes) then
        prev = res[tabidx][$][R_NOTES]
        if length(prev) then
            notes = notes & ", " & prev
        end if
        res[tabidx][$][R_NOTES] = notes
    end if
end procedure
--/*
                -- constants and variables [S_NTyp<=S_TVar]
--              S_vtype = 7,    -- variable type [see notes below]
--              S_value = 8,    -- value [see note below]
                S_Clink = 9,    -- constant chain (S_NTyp=S_Const only, see below)
--              S_Tidx  = 9,    -- thread idx (S_NTyp=S_Tvar only)
                S_ErrV  = 10,   -- {'v', file, line, col}; see pmain.e[-35]
--DEV not newEmit?:
                S_ConstChain = 10,  -- see notes below (constant ref/count optimisations)
                S_Init  = 11,   -- Initialised chain (known init if non-0/see S_Const note below)
                S_ltype = 12,   -- local type (see pltype.e)
                S_maxlv = 13,   -- last entry for var (see pltype.e)
                S_gInfo = 14,   -- (see note below)
                S_gNew  = 15,
                -- routines [S_NTyp>=S_Type]
--              S_sig   = 7,    -- routine signature, eg {'F',T_integer} (nb S_sig must be = S_vtype)
--              S_Parm1 = 8,    -- first parameter. (idx to symtab, follow S_Slink)
--              S_ParmN = 9,    -- minimum no of parameters (max is length(S_sig)-1)
--              S_Ltot  = 10,   -- total no of parameters, locals, and temporary vars
                                -- (needed to allocate the stack frame space)
--              S_il    = 11,   -- intermediate code (also backpatch list)
--              S_ltab  = 12,   -- line table
--              S_1stl  = 13,   -- first line
                S_Efct  = 14,   -- side effects
                S_ErrR  = 15    -- {'R', file, line, col}; see pmain.e[-60]

            else
                wasRtnLit = and_bits(siState,K_rtn+K_lit)
                wasNoClr = and_bits(siState,K_noclr)
--              si[S_State] = sState
                if siNTyp<=S_TVar then
                    sState = symtab[si[S_vtype]][S_Name]    -- eg 3 -> "atom" (udts too)
                    si[S_vtype] = sState
                    k = si[S_Slink]
                    if siNTyp<=S_GVar2 then -- S_Const and S_Gvar2
if newEmit then
                        sState = sprintf("%d/#%08x[???]",{k,ImageBase+DSvaddr+(0+k)*4+32})
else
                        sState = sprintf("%d/#%08x",{k,ImageBase+DSvaddr+(k-1)*4})
end if
                    else
                        sState = sprintf("%d",k)
                    end if
                    si[S_Slink] = sState
                    sState = ppf(si[S_value])
                    if siNTyp=S_TVar then
                        k = si[S_Tidx]
                        sState = '['&sState&"],"&sprintf("%d/#%08x",{k,ImageBase+DSvaddr+(-1-k)*4})
                        -- ('[',']' since TVar value is unlikely to be meaningful, btw)
                    end if
                    si[S_value] = sState
                    printf(fn,"{%s,%s,%d,%s,%d,%s,%s,%s}\n",si[1..S_value])
--              elsif siNTyp=S_Nspc then
                elsif siNTyp<=S_Rsvd then
                    printf(fn,"{%s,%s,%d,%s,%d,%d,%d}\n",si)
                else    -- type/function/procedure(inc top_level_subs)
--21/8/10 (possibly temp?)
if sequence(si[S_sig]) then
                    si[S_sig][1] = {si[S_sig][1]}
                    for j=2 to length(si[S_sig]) do
                        si[S_sig][j] = symtab[si[S_sig][j]][1]
                    end for
end if
                    ptxt = ppExf(si[S_sig],{pp_StrFmt,-1})
                    si[S_sig] = ptxt
--DEV make the linetab optional (and/or put it on a newline, properly folded):
                    ptxt = sprint(si[S_ltab])
                    si[S_ltab] = ptxt
--                  printf(fn,"{%s,%s,%d,%s,%d,%d,%s,%d,%d,%d,#%08x,%s,%d}\n",si[1..S_1stl])
-- to show [S_Efct]:
                    if equal(si[S_Name],"-1") then          -- S_Efct is meaningless on tls
                        sState = "0"
                    else
                        siState = si[S_Efct]
                        if siState=E_none then
                            sState = "E_none"
                        elsif siState=E_other then
                            sState = "E_other"
                        elsif siState=E_all then
                            sState = "E_all"
                        else
                            sState = sprintf("#%08x",siState)
                        end if
                    end if
                    si[S_Efct] = sState
                    printf(fn,"{%s,%s,%d,%s,%d,%d,%s,%d,%d,%d,#%08x,%s,%d,%s}\n",si[1..S_Efct])
--*/

--include builtins\VM\optable.e -- for vm_names
global constant bind = 0
global sequence tt
global integer ttidx
global constant EQ = 0
--without warning -- (suppress no side effects*3)
integer swm -- (suppress warning messages)
global procedure Finc(string file)                      swm = length(file)  end procedure
global procedure tt_string(string s,integer i)          swm = length(s)+i   end procedure
global procedure agchecktt(integer ttidx, integer i)    swm = ttidx+i       end procedure
--with warning
include builtins\VM\optable.e   -- get_vm_names()
glblname = {}
--void = create_optable()

--
--NB: The following will probably fail when dumping files generated with previous versions of Phix:
--    Where possible we'll try to make it robust/do a NotPhix()/revert to binary_dump(), but if
--    say two (or more) entry points are simply swapped, or something is moved from one file to
--    another but the total stays the same, you should expect to get mislead.. As yet we are not
--    doing anything clever (or simple) with version numbers, but we clearly should.
--
sequence vm_names = get_vm_names()

function phix_datadump(integer size, string bdesc)
--
-- Attempt to decode a (new style) phix data section.
-- If anything is amiss, revert to binary_dump().
-- Same for PE and ELF format files (but this routine 
--  could easily have an extra parameter, if needed).
--
string sig
integer layout
string fmt, f810
integer msize
atom symptr
--object symptrX
atom rawptr
integer flags
sequence todo
sequence todx
sequence tdfg
integer rtidx
integer rdiff
integer rbyte
--string txt
--atom maxop
integer relocs
integer relocraw
--atom opcode
integer maxgvar
--atom gvar
object gvarX
atom slack
integer maxlen
integer symlen
integer seqlen
--integer refcount
atom refcount
object refcountX
--atom typebyte
object typebyteX
--atom si
object siX
string sdesc
string snotes
atom float
string rtdesc
string brtdesc
integer k
sequence gvaraddrs
integer siName
object tmp
string notes

    if size>4 and binary[address+1..address+4]="Phix" then
        integer offset = addr
        sig = decode(sprintf("%08x: sigPhx",addr),"x4","signature (should be \"Phix\")")
        if sig!="Phix" then return fatal("bad signature") end if
        size -= 4
        addr += 4
        todo = {}
        todx = {}
        tdfg = {}
        layout = decode(sprintf("%08x: layout",{addr}),"h4","") -- (for pemit2<-->filedump use)
        size -= 4
        addr += 4
        fmt = "h4"
        f810 = "f8"
        msize = 4
        if machine=64 then
            fmt = "h8"
            f810 = "f10"
            msize = 8
        end if
        symptr = decode(sprintf("%08x: symptr",{addr}),fmt,"")
--      rawptr = and_bits(symptr,#3FFFFFFF)*4
        rtidx = length(res[tabidx][$])
--      res[tabidx][$][R_NOTES] = sprintf("see #%08x",rawptr)
        res[tabidx][$][R_NOTES] = sprintf("see #%08x",symptr)
        size -= msize
        addr += msize
        relocs = decode(sprintf("%08x: relocs",{addr}),fmt,"")
--      if not integer(relocs) then return fatal("relocs not integer!") end if
        res[tabidx][$][R_NOTES] = sprintf("see #%08x",relocs)
        relocraw = relocs-4
        size -= msize
        addr += msize
--DEV length 0 now...
--      for i=1 to maxop do
--          opcode = decode(sprintf("%08x: opcode[%d]",{addr,i}),fmt,"")
--          size -= msize
--          addr += msize
--      end for
        maxgvar = decode(sprintf("%08x: maxgvar",{addr}),fmt,"")
        res[tabidx][$][R_NOTES] = sprintf("%d",maxgvar)
        size -= msize
        addr += msize
        gvaraddrs = repeat(0,maxgvar)
        for i=1 to maxgvar do
            if address+msize>file_size then return fatal("unexpected end of file") end if
            gvaraddrs[i] = addr
--trace(1)
            gvarX = decode(sprintf("%08x: gvar[%d]",{addr,i}),fmt,"")
--if machine=64 then ?"9/0(1)" end if
--          if gvarX>#3FFFFFFF and gvarX<#C0000000 then
--          if (machine=64 and gvarX={#40000000,0})
--          if (machine=64 and gvarX={0,#40000000})
            if (machine=64 and gvarX=#4000000000000000)
            or (machine=32 and gvarX=#40000000) then
                res[tabidx][$][R_NOTES] = "<unassigned>"
            elsif (machine=64 and sequence(gvarX) and gvarX[1]=#40000000)
--          elsif (machine=64 and sequence(gvarX) and gvarX[2]=#40000000)
--          or (machine=32 and gvarX>#3FFFFFFF and gvarX<#C0000000) then
               or (machine=32 and gvarX>#40000000 and gvarX<#C0000000) then
                if machine=64 then
                    gvarX = gvarX[2]
--                  gvarX=gvarX[1]
                end if
                rawptr = and_bits(gvarX,#3FFFFFFF)*4
                res[tabidx][$][R_NOTES] = sprintf("see #%08x",rawptr)
                todo = append(todo,rawptr)
                todx = append(todx,length(res[tabidx]))
--      todx = {rtidx}
                tdfg = append(tdfg,0)
            else
                res[tabidx][$][R_NOTES] = sprint(gvarX)
            end if
            size -= msize
            addr += msize
        end for
        tmp = decode(sprintf("%08x: slack",{addr}),fmt,"(should be 0)")
        if not integer(tmp) then return fatal("slack not integer!") end if
        slack = tmp
        size -= msize
        addr += msize
        tmp = decode(sprintf("%08x: maxlen",{addr}),fmt,"(total allocated size in bytes)")
        if not integer(tmp) then return fatal("maxlen not integer!") end if
        maxlen = tmp
        size -= msize
        addr += msize
        tmp = decode(sprintf("%08x: symlen",{addr}),fmt,"")
        if not integer(tmp) then
            res[tabidx][$][R_NOTES] = sprintf("**?? %s ??**",sprint(tmp))
            return fatal("symlen not integer!")
        end if
        symlen = tmp
        res[tabidx][$][R_NOTES] = sprintf("%d",symlen)
        size -= msize
        addr += msize
        refcountX = decode(sprintf("%08x: refcount",{addr}),fmt,"")
        size -= msize
        addr += msize
        typebyteX = decode(sprintf("%08x: typebyte",{addr}),fmt,"")
        size -= msize
        addr += msize
        for i=1 to symlen do
            sdesc = ""
            if i<=length(stdescs) then
                sdesc = stdescs[i]
                if length(sdesc)!=0 then
                    sdesc = sprintf("%08x: symtab[%d=%s]",{addr,i,sdesc})
                end if
            end if
            if length(sdesc)=0 then
                sdesc = sprintf("%08x: symtab[%d]",{addr,i})
            end if
            siX = decode(sdesc,fmt,"")
--OK, it seems:
--if sequence(siX) then
--if machine=64 then ?"9/0(2)" ?siX printf(1,"%08x%08x\n",siX) end if
--end if
--{#80000000,#4022A8}
            if (machine=64 and sequence(siX) and siX[1]=#40000000)
--          if (machine=64 and sequence(siX) and siX[2]=#40000000)
            or (machine=32 and siX>#3FFFFFFF and siX<#C0000000) then
                if machine=64 then
                    siX = siX[2]
--                  siX=siX[1]
                end if
                rawptr = and_bits(siX,#3FFFFFFF)*4
                snotes = sprintf("see #%08x",rawptr)
                res[tabidx][$][R_NOTES] = snotes
                todo = append(todo,rawptr)
                todx = append(todx,length(res[tabidx]))
--              if i=T_pathset or i=T_fileset then
                if i=T_pathset or i=T_fileset or i=T_optable then
                    tdfg = append(tdfg,0)
                else
                    tdfg = append(tdfg,SYMTABN)
                end if
            elsif find(i,{T_constm1,T_const0,T_const1}) then
                res[tabidx][$][R_NOTES] = sprintf("(ie gvar[%d])",siX)
            end if
            size -= msize
            addr += msize
        end for
        -- [DEV] we should have just collected a bunch of pointers to process...
--?length(todo)
        while length(todo) do
            rtidx = smallest(todo,1)
            if todx[rtidx]=0 then
            -- (tip: to fix this, use File/Print and search the output file...) (I think it is OK now)
                printf(1,"warning: todx[rtidx]=0\n",{})
                rtdesc = "(??todx[rtidx]=0??)"
            else
                rtdesc = "("&res[tabidx][todx[rtidx]][R_DESC]&")"
            end if
            rawptr = todo[rtidx]
            flags = tdfg[rtidx]
            rdiff = rawptr-addr
            if address+rdiff<1
            or address+rdiff>=length(binary) then
                return fatal(sprintf("decode error: rawptr>length(binary) [#%08x>%d]",{rawptr,length(binary)}))
            end if
            rbyte = binary[address+rdiff]
-- machine=M32:
            if rbyte=#12 then
--              rdiff -= 8
                rdiff -= 2*msize
            elsif rbyte=#82 then
--              rdiff -= 16
                rdiff -= 4*msize
            elsif rbyte=#80 then
--              rdiff -= 20
                rdiff -= 5*msize
            else
--NotPhix(sprintf("%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x",binary[address+rdiff-4..address+rdiff+3]))
                return fatal(sprintf("unknown type byte at #%08x-1:%02x (rdiff=%d)",{rawptr,rbyte,rdiff}))
            end if
            if rdiff!=0 then
                if rdiff<0 then
                    NotPhix("-ve rdiff")
                    exit
                end if
                binary_dump(rdiff,"%08x: oops?")
                size -= rdiff
            end if
            if rbyte=#12 then
                refcount = decode(sprintf("%08x: refcount",{addr}),fmt,"")
                size -= msize
                addr += msize
--if machine=64 then ?"9/0(3)" end if
                typebyteX = decode(sprintf("%08x: typebyte",{addr}),fmt,rtdesc)
                size -= msize
                addr += msize
--if 01 then
--              float = decode(sprintf("%08x: float",{addr}),"h8","")
--else
--if machine=64 then ?"9/0(4)" end if -- should be "f10"... (and tough if it don't fit)
--              float = decode(sprintf("%08x: float",{addr}),"f8","")
                float = decode(sprintf("%08x: float",{addr}),f810,"")
--              res[tabidx][$][R_NOTES] = sprintf("%g",float)
                rtdesc = sprint(float)
                res[tabidx][$][R_NOTES] = rtdesc
                --end if
                if machine=64 then
                    addr += 10
                    size -= 10
                    {} = decode("padding","h2","")
                    addr += 2
                    size -= 2
                else
                    addr += 8
--              address += 8
--              binary_dump(8,"%08x: float")
                    size -= 8
                --              addr += 8
                end if
            elsif rbyte=#82 then
                maxlen = decode(sprintf("%08x: maxlen",{addr}),fmt,"(in bytes)")
                size -= msize
                addr += msize
                symlen = decode(sprintf("%08x: length",{addr}),fmt,"")
                size -= msize
                addr += msize
                refcount = decode(sprintf("%08x: refcount",{addr}),fmt,"")
                size -= msize
                addr += msize
--if machine=64 then ?"9/0(5)" end if
                typebyteX = decode(sprintf("%08x: typebyte",{addr}),fmt,rtdesc)
                size -= msize
                addr += msize
                if machine=64 then
                    maxlen -= 32
                else
                    maxlen -= 16
                end if
                rtdesc = get_string(address)
                rtdesc = sprint(rtdesc)
                if maxlen<0 then return fatal("maxlen<0") end if
                binary_dump(maxlen,"%08x: string")
                size -= maxlen
--              addr += maxlen
            elsif rbyte=#80 then
                tmp = decode(sprintf("%08x: slack",{addr}),fmt,"(should be 0)")
                if tmp!=0 then return fatal("not 0") end if
                slack = tmp
                size -= msize
                addr += msize
                maxlen = decode(sprintf("%08x: maxlen",{addr}),fmt,"(in bytes)")
                size -= msize
                addr += msize
                seqlen = decode(sprintf("%08x: length",{addr}),fmt,"")
                size -= msize
                addr += msize
                refcount = decode(sprintf("%08x: refcount",{addr}),fmt,"")
                size -= msize
                addr += msize
--if machine=64 then ?"9/0(6)" end if
                typebyteX = decode(sprintf("%08x: typebyte",{addr}),fmt,rtdesc)
                size -= msize
                addr += msize
                if machine=64 then
                    maxlen -= 40
                else
                    maxlen -= 20
                end if
                siName = -1
                for i=1 to seqlen do
                    notes = ""
                    if match(": symtab[16=T_pathset]",rtdesc) then
                        sdesc = sprintf("%08x: pathset[%d]",{addr,i})
                    elsif match(": symtab[17=T_fileset]",rtdesc) then
                        sdesc = sprintf("%08x: fileset[%d]",{addr,i})
                    elsif match(": symtab[20=T_optable]",rtdesc) then
                        sdesc = sprintf("%08x: optable[%d]",{addr,i})
                        if i>length(vm_names) then
                            notes = sprintf("?vm_names[%d>%d]",{i,length(vm_names)})
                            --DEV NotPhix()
                            ?notes
                        else
                            notes = vm_names[i]
                        end if
                    else
--trace(1)
                        sdesc = sprintf("%08x: dseq[%d]",{addr,i})
                    end if
                    siX = decode(sdesc,fmt,notes)
                    if length(notes) and notes[1]!='?' then
    --DEV
    --append names,ptrs
                    end if
                    --if machine=64 then ?"9/0(7)" end if
                    --(something else entirely will also likely be needed for (the very different case of) machine_bits()=64...)
                    --                  if siX>#3FFFFFFF and siX<#C0000000 then
                    if (machine=64 and sequence(siX) and siX[1]=#40000000)
--                  if (machine=64 and sequence(siX) and siX[2]=#40000000)
                    or (machine=32 and siX>#3FFFFFFF and siX<#C0000000) then
                        if machine=64 then
                            siX = siX[2]
--                          siX=siX[1]
                        end if
                        siX = and_bits(siX,#3FFFFFFF)*4
                        res[tabidx][$][R_NOTES] = sprintf("see #%08x",siX)
                        if siX>addr then
                            todo = append(todo,siX)
                            todx = append(todx,length(res[tabidx]))
                            if and_bits(flags,SYMTABN)
                            and i=S_ltab then
                                tdfg = append(tdfg,LINETAB)
                            else
                                tdfg = append(tdfg,0)
                            end if
                        end if
                        if and_bits(flags,SYMTABN) then
                            if i=S_Name then
                                siName = siX
                                todo = append(todo,siX)
                                todx = append(todx,todx[rtidx])
                                tdfg = append(tdfg,SYMDESC)
                            end if
                        end if
                    end if
                    if and_bits(flags,SYMTABN) then
                        SymtabN(siX,i)
                        if i=S_Slink
                        and siNTyp<=S_GVar2 -- S_Const and S_Gvar2
                        and siName!=-1 then
                            todo = append(todo,siName)
                            todx = append(todx,siX)
                            tdfg = append(tdfg,GVARDDR) -- (add to knowAddr/Names)
                        end if
                    elsif and_bits(flags,LINETAB) then
--if machine=64 then ?"9/0(8)" end if
                        if siX>#3FFFFFFF then
                            siX -= #100000000
                        end if
                        res[tabidx][$][R_NOTES] = sprintf("%d",siX)
                    end if
                    size -= msize
                    maxlen -= msize
                    addr += msize
                end for
                if maxlen!=0 then
                    if maxlen<0 then return fatal("maxlen(slack)<0") end if
                    binary_dump(maxlen,"%08x: (slack)")
                    size -= maxlen
--                  addr += maxlen
                end if
                rtdesc = "got"
            else
                ?9/0
            end if

            brtdesc = " ("&rtdesc&")"
            while 1 do
                if and_bits(flags,GVARDDR) then
                    --printf(1,"%s: %08x\n",{rtdesc,gvaraddrs[todx[rtidx]]})
                    --DEV:
                    if todx[rtidx]=0 then
                    -- tip: fix this via File/Print and search... (I think it is OK now)
                        printf(1,"warning: GVARDDR set but todx[rtidx]=0 for %s\n",{rtdesc})
                    else
                        knownAddr = append(knownAddr,gvaraddrs[todx[rtidx]])
                        knownNames = append(knownNames,rtdesc)
                    end if
                else
                    k = R_NOTES
                    if and_bits(flags,SYMDESC) then
                        k = R_DESC
                    end if
                    res[tabidx][todx[rtidx]][k] &= brtdesc
                end if
                todo[rtidx] = todo[$]
                todo = todo[1..-2]
                todx[rtidx] = todx[$]
                todx = todx[1..-2]
                tdfg[rtidx] = tdfg[$]
                tdfg = tdfg[1..-2]
                rtidx = find(rawptr,todo)
                if rtidx=0 then exit end if
                flags = tdfg[rtidx]
            end while
        end while
        todo = {}
        todx = {}
        tdfg = {}
        if addr=relocraw then
            -- A dll/so:
            -- relocraw is the same value as [ds+12|16], but not in the Relocs table,
            -- so LoadLibrary will not have relocated it. Obviously the difference
            -- between the two (at runtime) shows how far LoadLibrary moved things,
            -- and we use that in pStack/initStack to manually relocate data refs.
            -- In the filedump, relocraw==relocs, 'cos LoadLibrary is not involved.
            maxlen = decode(sprintf("%08x: relocraw",{addr}),fmt,"(not relocated)")
            size -= 4
            addr += 4
            -- Convert the packed offset deltas to actual offsets:
--          integer offset = 0 --DEV lea[ds+0]
            while 1 do
--              sequence line = {address,"delta","h1",0,"notes"}
--                  tgtaddr = getAddr(notes[6..13])-(getAddr(line[R_DESC][1..8])-line[R_ADDR])
                integer delta = decode(sprintf("%08x: delta",{addr}),"h1","")
--              integer delta = binary[address+1]
                size -= 1
                if delta>=4 then    -- (technically >=8 for x64)
                    offset += delta
--                  res[tabidx][$][4] = sprintf("#%02x",delta)
--                  res[tabidx][$][4] = delta
                    res[tabidx][$][R_NOTES] = sprintf("see #%08x",offset)
--                  address += 1
                    addr += 1
                elsif delta=3 then
                    ?9/0 --DEV
                elsif delta=2 then
--                  delta = binary[address+2]*#100+binary[address+3]
--                  delta = binary[address+1]*#100+binary[address+2]
--good:
--                  delta = binary[address+1]+binary[address+2]*#100
                    delta = 0
                    for i=2 to 1 by -1 do
                        delta = delta*#100+binary[address+i]
                    end for
                    offset += delta
--                  res[tabidx][$][4] = sprintf("#02%04x",delta)
                    res[tabidx][$][3] = "h3"
                    res[tabidx][$][4] = #020000+delta
                    res[tabidx][$][R_NOTES] = sprintf("see #%08x",offset)
--                  address += 3
                    address += 2
                    addr += 3
                    size -= 2
                elsif delta=1 then
                    delta = 0
                    for i=4 to 1 by -1 do
                        delta = delta*#100+binary[address+i]
                    end for
--                  delta = binary[address+1] +
--                          binary[address+2]*#100 +
--                          binary[address+3]*#10000 +
--                          binary[address+4]*#1000000
                    offset += delta
                    res[tabidx][$][3] = "h5"
--                  res[tabidx][$][4] = sprintf("#01%08x",delta)
                    res[tabidx][$][4] = #0100000000+delta
                    res[tabidx][$][R_NOTES] = sprintf("see #%08x",offset)
                    addr += 5
                    size -= 4
                elsif delta=0 then
                    res[tabidx][$][R_NOTES] = "terminator"
                    addr += 1
                end if
--              res[tabidx] = append(res[tabidx],line)
                if delta=0 then exit end if
            end while
        end if
    else
        NotPhix("data section does not start with \"Phix\"")
    end if
    if size then
--printf(1,"%08x\n",address)
--printf(1,"%08x\n",addr)
--printf(1,"%08x\n",relocraw)
--?bdesc
        binary_dump(size,bdesc)
--printf(1,"%08x\n",address)
    end if
    return 1
end function

object void

function decode_DOS_Header()
string e_magic
    NotPhixMessages = {}
    SetTabIdx("DOS Header")
    -- An IMAGE_DOS_HEADER structure:
--/*
-- Header shared by DOS, Win16, Win32, and Win64 executables
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
--*/
    -- Magic number. This is the "magic number" of an EXE file.
    -- The first byte of the file is 0x4d and the second is 0x5a.
    e_magic = decode("e_magic","x2","signature (should be \"MZ\")")                                 -- MZ
--DEV (temp)
--  if e_magic!="MZ" then return fatal("bad signature") end if
    if find(e_magic,{"MZ","ZZ"})=0 then return fatal("bad signature") end if
    wasZZ = (e_magic="ZZ")
    -- Bytes on last page of file. The number of bytes in the last block of the
    -- program that are actually used. If this value is zero, that means the entire
    -- last block is used (i.e. the effective value is 512).
    void = decode("e_cblp","h2","Bytes in last block of file")                                      -- 0x80 (128)
    -- Pages in file. Number of blocks in the file that are part of the EXE file.
    -- If [02-03] is non-zero, only that much of the last block is used.
    void = decode("e_cp",  2,"Blocks in file")                                                      -- 1
    -- Relocations. Number of relocation entries stored after the header. May be zero.
    void = decode("e_crlc",2,"Relocations")                                                         -- 0
    -- Size of header in paragraphs. Number of paragraphs in the header.
    -- The program's data begins just after the header, and this field can be used
    -- to calculate the appropriate file offset. The header includes the relocation entries.
    -- Note that some OSs and/or programs may fail if the header is not a multiple of 512 bytes.
    void = decode("e_cparhdr",2,"Size of header in paragraphs")                                     -- 4
    -- Minimum extra paragraphs needed. Number of paragraphs of additional memory that the
    -- program will need. This is the equivalent of the BSS size in a Unix program.
    -- The program can't be loaded if there isn't at least this much memory available to it.
    void = decode("e_minalloc","h2","Minimum extra paragraphs needed")                              -- 0x10 (16)
    -- Maximum extra paragraphs needed. Maximum number of paragraphs of additional memory.
    -- Normally, the OS reserves all the remaining conventional memory for your program,
    -- but you can limit it with this field.
    void = decode("e_maxalloc","h2","Maximum extra paragraphs needed")                              -- 0xffff (65535)
    -- Initial (relative) SS value. Relative value of the stack segment. This value is
    -- added to the segment the program was loaded at, and the result is used to
    -- initialize the SS register.
    void = decode("e_ss","h2","Initial (relative) SS value [ignore]")                               -- 0
    -- Initial SP value. Initial value of the SP register.
    void = decode("e_sp","h2","Initial SP value [ignore]")                                          -- 0x140
    -- Checksum. Word checksum. If set properly, the 16-bit sum of all words in the
    -- file should be zero. Usually, this isn't filled in.
    void = decode("e_csum","h2","Checksum")                                                         -- 0
    -- Initial IP value. Initial value of the IP register.
    void = decode("e_ip","h2","Initial IP value [ignore]")                                          -- 0
    -- Initial (relative) CS value. Initial value of the CS register, relative to
    -- the segment the program was loaded at.
    void = decode("e_cs","h2","Initial (relative) CS value [ignore]")                               -- 0
    -- File address of relocation table. Offset of the first relocation item in the file.
    void = decode("e_lfarlc","h2","File address of relocation table")                               -- 0x40
    -- Overlay number. Overlay number. Normally zero, meaning that it's the main program.
    void = decode("e_ovno","h2","Overlay number")                                                   -- 0
    -- reserved
    void = decode("e_res","h4","Reserved words")                                                    -- 0
    void = decode("e_res","h4","Reserved words")                                                    -- 0
    -- OEM identifier (for e_oeminfo)
    void = decode("e_oemid","h2","OEM identifier (for e_oeminfo)")                                  -- 0
    -- OEM information; e_oemid specific
    void = decode("e_oeminfo","h2","OEM information; e_oemid specific")                             -- 0
    -- reserved
    void = decode("e_res2","h4","Reserved words")                                                   -- 0
    void = decode("e_res2","h4","Reserved words")                                                   -- 0
    void = decode("e_res2","h4","Reserved words")                                                   -- 0
    void = decode("e_res2","h4","Reserved words")                                                   -- 0
    void = decode("e_res2","h4","Reserved words")                                                   -- 0
    -- File address of new exe header
    if address!=#3C then return fatal("wrong e_lfanew address") end if
    e_lfanew = decode("e_lfanew","h4","File address of new exe header")                             -- 0x80
    return 1
end function

function decode_DOS_Stub()
atom check
--string hex
--string text
--integer addrMax
integer byte
--sequence line
integer size

    SetTabIdx("DOS Stub")
    -- If there are any other slightly different DOS stubs out there, just
    --  comment out from asHex=1 to =0, the lower loop will cope just fine.
    asHex = 1
    byte = binary[address+1]
    if byte=#0E then
        check = decode("push cs","h1","")
        if check!=0x0E then return fatal("?") end if
        check = decode("pop ds","h1","(ie data segment:=code segment)")
        if check!=0x1F then return fatal("?") end if
        check = decode("mov dx,0x000E","h3","(ie ds:dx is text string below)")
        if check!=0xBA0E00 then return fatal("?") end if
        check = decode("mov ah,0x09","h2","(write to stdout)")
        if check!=0xB409 then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
        check = decode("mov ax,0x4C01","h3","(exit)")
        if check!=0xB8014C then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
    elsif byte=#BA then
        NotPhix("Wrong DOS Stub")
            -- (obviously there is nothing "wrong" with this 
            --  stub, it is just not the one that Phix uses.)
        check = decode("mov dx,0x0010","h3","(ie ds:dx is text string below)")
        if check!=0xBA1000 then return fatal("?") end if
        check = decode("push cs","h1","")
        if check!=0x0E then return fatal("?") end if
        check = decode("pop ds","h1","(ie data segment:=code segment)")
        if check!=0x1F then return fatal("?") end if
        check = decode("mov ah,0x09","h2","(write to stdout)")
        if check!=0xB409 then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
        check = decode("mov ax,0x4C01","h3","(exit)")
        if check!=0xB8014C then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
        check = decode("padding","h2","")
        if check!=0x9090 then return fatal("?") end if
    elsif byte=#B4 then
        -- (powerbasic)
        NotPhix("Wrong DOS Stub")
            -- (obviously there is nothing "wrong" with this 
            --  stub, it is just not the one that Phix uses.)
        check = decode("mov ah,0x09","h2","(write to stdout)")
        if check!=0xB409 then return fatal("?") end if
        check = decode("mov dx,0x0010","h4","(ie ds:dx is text string below)")
        if check!=0x66BA1000 then return fatal("?") end if
        check = decode("push cs","h1","")
        if check!=0x0E then return fatal("?") end if
        check = decode("pop ds","h1","(ie data segment:=code segment)")
        if check!=0x1F then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
        check = decode("mov ax,0x4C01","h4","(exit)")
        if check!=0x66B8014C then return fatal("?") end if
        check = decode("int 0x21","h2","")
        if check!=0xCD21 then return fatal("?") end if
    end if
    asHex = 0

--if 1 then
    size = e_lfanew-address
    if size then
        binary_dump(size, "-")
    end if
--else
--  -- show remainder with first chunk up to a 16-byte boundary,
--  -- and rest in (whole) 16-byte blocks (for nicer addresses)
--
--  while address<e_lfanew do
--      hex = ""
--      text = ""
--      addrMax = address+16
--      if addrMax>=e_lfanew then
--          addrMax = e_lfanew-1
--      else
--          addrMax -= and_bits(addrMax,#0F)+1
--      end if
--      for a=address to addrMax do
--          byte = binary[a+1]
--          hex &= sprintf("%02x",byte)
--          if remainder(a+5,4)=0 then
--              hex &= ' '
--          end if
--          if byte<' ' or byte>#7E then byte = '.' end if
--          text &= byte
--      end for
--      line = {address,"-","-",hex,text}
--      res[tabidx] = append(res[tabidx],line)
--      address = addrMax+1
--  end while
--end if
    return 1
end function


constant IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x010B,
         IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x020B

constant
--       IMAGE_FILE_MACHINE_UNKNOWN     = 0x0000
         IMAGE_FILE_MACHINE_I386        = 0x014c,   -- Intel 386 or later
--                                      = 0x014d,   -- Intel 486 or better (deprecated)
--                                      = 0x014e,   -- Intel Pentium or better (deprecated)
--       IMAGE_FILE_MACHINE_R3000       = 0x0162,   -- MIPS little-endian, 0x160 big-endian
--       IMAGE_FILE_MACHINE_R4000       = 0x0166,   -- MIPS little-endian
--       IMAGE_FILE_MACHINE_R10000      = 0x0168,   -- MIPS little-endian
--       IMAGE_FILE_MACHINE_WCEMIPSV2   = 0x0169,   -- MIPS little-endian WCE v2
--       IMAGE_FILE_MACHINE_ALPHA       = 0x0184,   -- Alpha_AXP
--       IMAGE_FILE_MACHINE_SH3         = 0x01a2,   -- Hitachi SH3 little-endian
--       IMAGE_FILE_MACHINE_SH3DSP      = 0x01a3,   -- Hitachi SH3 DSP
--       IMAGE_FILE_MACHINE_SH3E        = 0x01a4,   -- Hitachi SH3E little-endian
--       IMAGE_FILE_MACHINE_SH4         = 0x01a6,   -- Hitachi SH4 little-endian
--       IMAGE_FILE_MACHINE_SH5         = 0x01a8,   -- Hitachi SH5
--       IMAGE_FILE_MACHINE_ARM         = 0x01c0,   -- ARM Little-Endian
--       IMAGE_FILE_MACHINE_THUMB       = 0x01c2,   -- ARM or Thumb ("interworking")
--       IMAGE_FILE_MACHINE_ARMNT       = 0x01c4,   -- ARMv7 (or higher) Thumb mode only
--       IMAGE_FILE_MACHINE_ARM64       = 0xaa64,   -- ARMv8 in 64-bit mode
--       IMAGE_FILE_MACHINE_AM33        = 0x01d3,   -- Matsushita AM33
--       IMAGE_FILE_MACHINE_POWERPC     = 0x01f0,   -- IBM PowerPC little-endian
--       IMAGE_FILE_MACHINE_POWERPCFP   = 0x01f1,   -- IBM Power PC with floating point support
--       IMAGE_FILE_MACHINE_IA64        = 0x0200,   -- Intel 64 (Itanium)
--       IMAGE_FILE_MACHINE_MIPS16      = 0x0266,   -- MIPS16
--       IMAGE_FILE_MACHINE_ALPHA64     = 0x0284,   -- ALPHA64 (aka IMAGE_FILE_MACHINE_AXP64)
--       IMAGE_FILE_MACHINE_MIPSFPU     = 0x0366,   -- MIPS with FPU
--       IMAGE_FILE_MACHINE_MIPSFPU16   = 0x0466,   -- MIPS16 wth FPU
--       IMAGE_FILE_MACHINE_TRICORE     = 0x0520,   -- Infineon
--       IMAGE_FILE_MACHINE_CEF         = 0x0CEF,
--       IMAGE_FILE_MACHINE_EBC         = 0x0EBC,   -- EFI Byte Code
         IMAGE_FILE_MACHINE_AMD64       = 0x8664,   -- AMD64 (K8) (aka IMAGE_FILE_MACHINE_X64)
--       IMAGE_FILE_MACHINE_M32R        = 0x9041,   -- Mitsubishi M32R little-endian
--       IMAGE_FILE_MACHINE_CEE         = 0xC0EE,
$

constant
         IMAGE_SUBSYSTEM_UNKNOWN                    = 0,    -- Unknown subsystem.
         IMAGE_SUBSYSTEM_NATIVE                     = 1,    -- Image doesn't require a subsystem. 
                                                            -- Device drivers and native Windows processes
         IMAGE_SUBSYSTEM_WINDOWS_GUI                = 2,    -- Image runs in the Windows GUI subsystem.
         IMAGE_SUBSYSTEM_WINDOWS_CUI                = 3,    -- Image runs in the Windows character subsystem.
         IMAGE_SUBSYSTEM_OS2_CUI                    = 5,    -- image runs in the OS/2 character subsystem.
         IMAGE_SUBSYSTEM_POSIX_CUI                  = 7,    -- image runs in the Posix character subsystem.
         IMAGE_SUBSYSTEM_NATIVE_WINDOWS             = 8,    -- image is a native Win9x driver.
         IMAGE_SUBSYSTEM_WINDOWS_CE_GUI             = 9,    -- Image runs in the Windows CE subsystem.
         IMAGE_SUBSYSTEM_EFI_APPLICATION            = 10,   -- An Extensible Firmware Interface (EFI) application
--       IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER    = 11,   -- An EFI driver with boot services
         IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE           = 11,   -- An EFI driver with boot services
         IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER         = 12,   -- An EFI driver with run-time services
         IMAGE_SUBSYSTEM_EFI_ROM                    = 13,   -- An EFI ROM image
         IMAGE_SUBSYSTEM_XBOX                       = 14,   -- XBOX
--       IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION   = 16,
         IMAGE_SUBSYSTEM_WINDOWS_BOOT_APP           = 16,
$

--/*
#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor
--*/
constant RVAdesc = {"export (see \"Export Section\" tab)",
                    "import (see \"Import Section\" tab)",
                    "resource (see \"Resource Section\" tab)",
                    "exception (see \"Exceptions\" tab)",
                    "security",     -- Certificate (first field is file ptr not RVA)
                    "basereloc (see \"Relocations\" tab)",
                    "debug",
                    "architecture", -- copyright -- Reserved, must be 0
                    "globalptr",
                    "TLS table",
                    "loadconfig",
                    "boundimport",
                    "IAT",
                    "delayimport",
                    "comdescriptor",        -- CLR runtime header
                    "IDD 16"}               -- Reserved, must be zero

integer nImportSection
integer nExportSection
integer nResourceSection
integer nRelocSection
integer nExceptions
sequence sCodeSections
sequence sDataSections
sequence SH_VirtualSizes
sequence SH_VirtualAddress
sequence PointerToRawData
sequence SizeOfRawData
sequence SectionNames
sequence RelativeVirtualAddress
sequence RVASize
atom xImageBase

function roundto(integer v, integer blocksize)
    if and_bits(blocksize,blocksize-1) then ?9/0 end if
    return floor((v+blocksize-1)/blocksize)*blocksize
end function

constant ValidAlignments = {#00002,
                            #00004,
                            #00008,
                            #00010,
                            #00020,
                            #00040,
                            #00080,
                            #00100,
                            #00200,     -- Default FileAlignment (512)
                            #00400,     -- 1K
                            #00800,
                            #01000,
                            #02000,
                            #04000,
                            #08000,
                            #10000}     -- 64K

function decode_PE_Header()
string signature
integer nSections
atom DateTimeStamp
atom PointerToSymbolTable
integer NumberOfSymbols
integer SizeOfOptionalHeader
integer FileHeaderCharacteristics
integer Magic
string desc
integer k
integer MajorLinkerVersion
integer MinorLinkerVersion
integer SizeOfCode
integer SizeOfInitializedData
integer SizeOfUninitializedData
integer AddressOfEntryPoint
integer BaseOfCode
integer BaseOfData
integer SectionAlignment
integer FileAlignment
integer MajorOperatingSystemVersion
integer MinorOperatingSystemVersion
integer MajorImageVersion
integer MinorImageVersion
integer MajorSubsystemVersion
integer MinorSubsystemVersion
integer Win32VersionValue
integer SizeOfImage
integer SizeOfHeaders
atom CheckSum
integer Subsystem
integer DllCharacteristics
atom SizeOfStackReserve
atom SizeOfStackCommit
atom SizeOfHeapReserve
atom SizeOfHeapCommit
integer LoaderFlags
integer NumberOfRvaAndSizes
string Name
--integer SH_VirtualAddress
--integer SizeOfRawData
integer PointerToRelocations
integer PointerToLinenumbers
integer NumberOfRelocations
integer NumberOfLinenumbers
atom SectionCharacteristics
integer size
integer supported

    -- IMAGE_NT_HEADERS(32/64):
    SetTabIdx("PE Header")
    signature = decode("signature","x4","(should be \"PE\\0\\0\")")                                 -- PE
    if signature!="PE\\0\\0" then return fatal("bad signature") end if
    --  IMAGE_FILE_HEADER structure:
    machine = decode("machine","h2","")
    if machine=IMAGE_FILE_MACHINE_I386 then                                                         -- 0x014C
        desc = "i386"
        machine = 32
    elsif machine=IMAGE_FILE_MACHINE_AMD64 then                                                     -- 0x8664
        desc = "amd64"
        machine = 64
    else
        return fatal("unknown architecture")
    end if
    res[tabidx][$][R_NOTES] = desc
    nSections = decode("sections",2,"Number of sections")                                           -- 6
    DateTimeStamp = decode("DateTimeStamp","h4","")
    --DEV windows only:
--> res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(DateTimeStamp))
--  timedate td = adjust_timedate(Jan1st1970,timedelta(seconds:=DateTimeStamp))
--  timedate td = adjust_timedate(Jan1st1970,DateTimeStamp)
--  res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
    res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,DateTimeStamp))
    PointerToSymbolTable = decode("PointerToSymbolTable","h4","")
    NumberOfSymbols = decode("NumberOfSymbols","h4","")
    SizeOfOptionalHeader = decode("SizeOfOptionalHeader","h2","")                                   -- 0xE0
    FileHeaderCharacteristics = decode("Characteristics","h2","")                                   -- 0x818F
    res[tabidx][$][R_NOTES] = decode_flags(FileHeaderCharacteristicSet,FileHeaderCharacteristics)
    if and_bits(FileHeaderCharacteristics,IMAGE_FILE_EXECUTABLE_IMAGE)=0 then
        return fatal("linker error")
    end if
    --
    -- The image_optional_header is "optional" in the sense that it is not present in object files
    --  (as traditionally output by compilers [not Phix] and input to a linker) but must always be 
    --  present for image files (such as executables).
    --
    --  IMAGE_OPTIONAL_HEADER(32/64) structure:
    Magic = decode("Magic","h2","")                                                                 -- 0x010B
    if Magic=IMAGE_NT_OPTIONAL_HDR32_MAGIC then
        desc = "32bit"
        if machine!=32 then return fatal("machine/magic mismatch") end if
    elsif Magic=IMAGE_NT_OPTIONAL_HDR64_MAGIC then                                                  -- 0x020B
        desc = "64bit"
        if machine!=64 then return fatal("machine/magic mismatch") end if
    else
        return fatal("unknown magic")
    end if
    res[tabidx][$][R_NOTES] = desc
    MajorLinkerVersion = decode("MajorLinkerVersion","h1","")                                       -- 1.51
    MinorLinkerVersion = decode("MinorLinkerVersion","h1","")
    res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorLinkerVersion,MinorLinkerVersion})
    SizeOfCode = decode("SizeOfCode","h4","")
    SizeOfInitializedData = decode("SizeOfInitializedData","h4","")
    SizeOfUninitializedData = decode("SizeOfUninitializedData","h4","")
    AddressOfEntryPoint = decode("AddressOfEntryPoint","h4","")
--DEV NotPhix("AddressOfEntryPoint!=CodeSection")
    BaseOfCode = decode("BaseOfCode","h4","")                                                       -- 0
    if machine=32 then
        BaseOfData = decode("BaseOfData","h4","")                                                   -- 0
        xImageBase = decode("ImageBase","h4","")                                                    -- 0x400000
    elsif machine=64 then
        xImageBase = decode("ImageBase","h8","")
    else
        ?9/0 -- cannot happen (left in as sanity check)
    end if
    --12/10/13:
    ImageBase = xImageBase
    SectionAlignment = decode("SectionAlignment","h4","")                                           -- 0x1000
    if not find(SectionAlignment,ValidAlignments) then
        return fatal("invalid")
    end if
    FileAlignment = decode("FileAlignment","h4","")                                                 -- 0x200
    if not find(FileAlignment,ValidAlignments)
    or FileAlignment>SectionAlignment then
        return fatal("invalid")
    end if
    MajorOperatingSystemVersion = decode("MajorOperatingSystemVersion","h2","")                     -- 1.0
    MinorOperatingSystemVersion = decode("MinorOperatingSystemVersion","h2","")
    res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorOperatingSystemVersion,MinorOperatingSystemVersion})
    MajorImageVersion = decode("MajorImageVersion","h2","")                                         -- 0.0
    MinorImageVersion = decode("MinorImageVersion","h2","")
    res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorImageVersion,MinorImageVersion})
    MajorSubsystemVersion = decode("MajorSubsystemVersion","h2","")                                 -- 4.0
    MinorSubsystemVersion = decode("MinorSubsystemVersion","h2","")
    res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorSubsystemVersion,MinorSubsystemVersion})
    Win32VersionValue = decode("Win32VersionValue","h4","")                                         -- 0
    if Win32VersionValue!=0 then
        return fatal("invalid")
    end if
    SizeOfImage = decode("SizeOfImage","h4","")                                                     -- 0x10000
    if remainder(SizeOfImage,SectionAlignment) then
        return fatal("invalid")
    end if
    SizeOfHeaders = decode("SizeOfHeaders","h4","")                                                 -- 0x400
    if remainder(SizeOfHeaders,FileAlignment) then
        return fatal("invalid")
    end if
    CheckSum = decode("CheckSum","h4","")                                                           -- 0x11efc
    Subsystem = decode("Subsystem","h2","")
    supported = 0
    if    Subsystem=IMAGE_SUBSYSTEM_UNKNOWN then            desc = "Unknown"                        -- 0
    elsif Subsystem=IMAGE_SUBSYSTEM_NATIVE then             desc = "Native"                         -- 1
    elsif Subsystem=IMAGE_SUBSYSTEM_WINDOWS_GUI then        desc = "GUI app"        supported = 1   -- 2
    elsif Subsystem=IMAGE_SUBSYSTEM_WINDOWS_CUI then        desc = "console app"    supported = 1   -- 3
    elsif Subsystem=IMAGE_SUBSYSTEM_OS2_CUI then            desc = "OS/2 console"                   -- 5
    elsif Subsystem=IMAGE_SUBSYSTEM_POSIX_CUI then          desc = "Posix console"                  -- 7
    elsif Subsystem=IMAGE_SUBSYSTEM_NATIVE_WINDOWS then     desc = "Native Win9x driver"            -- 8
    elsif Subsystem=IMAGE_SUBSYSTEM_WINDOWS_CE_GUI then     desc = "CE gui"                         -- 9
    elsif Subsystem=IMAGE_SUBSYSTEM_EFI_APPLICATION then    desc = "EFI app"                        -- 10
    elsif Subsystem=IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE then   desc = "EFI Boot Service Driver"        -- 11
    elsif Subsystem=IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER then desc = "EFI Runtime Driver"             -- 12
    elsif Subsystem=IMAGE_SUBSYSTEM_EFI_ROM then            desc = "EFI ROM Image"                  -- 13
    elsif Subsystem=IMAGE_SUBSYSTEM_XBOX then               desc = "XBox"                           -- 14
    elsif Subsystem=IMAGE_SUBSYSTEM_WINDOWS_BOOT_APP then   desc = "Windows Boot App"               -- 16
    else                                                    desc = "Invalid"
    end if
    res[tabidx][$][R_NOTES] = desc
    if not supported then
        return fatal("not supported")
    end if
    DllCharacteristics = decode("DllCharacteristics","h2","")                                       -- 0
    desc = decode_flags(DllCharacteristicSet,DllCharacteristics)
    res[tabidx][$][R_NOTES] = desc
--DEV added 26/09/2013: (had been commented out, put back 16/2/14)
--  if match("0x",desc)=1 then return fatal("unknown characteristics") end if

    if machine=32 then
        SizeOfStackReserve = decode("SizeOfStackReserve","h4","")                                   -- 0x1000
        SizeOfStackCommit = decode("SizeOfStackCommit","h4","")                                     -- 0x1000
        SizeOfHeapReserve = decode("SizeOfHeapReserve","h4","")                                     -- 0x10000
        SizeOfHeapCommit = decode("SizeOfHeapCommit","h4","")                                       -- 0
    elsif machine=64 then
        SizeOfStackReserve = decode("SizeOfStackReserve","h8","")
        SizeOfStackCommit = decode("SizeOfStackCommit","h8","")
        SizeOfHeapReserve = decode("SizeOfHeapReserve","h8","")
        SizeOfHeapCommit = decode("SizeOfHeapCommit","h8","")
    else
        ?9/0 -- cannot happen (left in as sanity check)
    end if
    LoaderFlags = decode("LoaderFlags","h4","")                                                     -- 0
    NumberOfRvaAndSizes = decode("NumberOfRvaAndSizes",4,"")                                        -- 0x10 (==16)
    if machine=32 then
        if (#60+NumberOfRvaAndSizes*8)!=SizeOfOptionalHeader then
            return fatal("does not agree with SizeOfOptionalHeader")
        end if
    elsif machine=64 then
        if (#70+NumberOfRvaAndSizes*8)!=SizeOfOptionalHeader then
            return fatal("does not agree with SizeOfOptionalHeader")
        end if
    else
        ?9/0
    end if

    SetTabIdx("RVA table")

    -- An array of IMAGE_DATA_DIRECTORY structures:
    RelativeVirtualAddress = repeat(0,NumberOfRvaAndSizes)
    RVASize = repeat(0,NumberOfRvaAndSizes)
    for i=1 to NumberOfRvaAndSizes do
        desc = RVAdesc[i]
        RelativeVirtualAddress[i] = decode(sprintf("RelativeVirtualAddress[%d]",i),"h4",desc)
        RVASize[i] = decode(sprintf("RVASize[%d]",i),"h4","")
        k = match(" (see ",desc)
        if k then
            desc = desc[1..k-1]
        end if
        if RVASize[i]=0 then
            if k then
                res[tabidx][$-1][R_NOTES] = desc
            end if
--DEV/SUG
--      elsif i>=IMAGE_DIRECTORY_ENTRY_DEBUG then
--      elsif i>IMAGE_DIRECTORY_ENTRY_RESOURCE and i!=IMAGE_DIRECTORY_ENTRY_BASERELOC then
--          suppress_all_code_sections = 1
        elsif k=0 then -- (ie there was no "(see" and size !=0)
            NotPhix(sprintf("RVA[%d] (%s) not empty",{i,desc}))
        end if
    end for

    SetTabIdx("Section table")

    -- An array of IMAGE_SECTION_HEADER structures:
    SH_VirtualSizes = repeat(0,nSections)
    SH_VirtualAddress = repeat(0,nSections)
    PointerToRawData = repeat(0,nSections)
    SizeOfRawData = repeat(0,nSections)
    SectionNames = repeat("",nSections)

    nImportSection = 0
    nExportSection = 0
    nResourceSection = 0
    nRelocSection = 0
    nExceptions = 0
    sCodeSections = {}
    sDataSections = {}

    for i=1 to nSections do
        if address+#28>file_size then return fatal("unexpected end of file") end if
        Name = decode(sprintf("Name[%d]",i),"x8","")
        if not find(Name,{".idata\\0\\0",
                          ".edata\\0\\0",
                          ".reloc\\0\\0",
                          ".pdata\\0\\0",
                          ".text\\0\\0\\0",     -- (executable code)
                          ".code\\0\\0\\0",
                          ".data\\0\\0\\0",
                          ".rsrc\\0\\0\\0"}) then
            NotPhix("Section Named \""&Name&"\"")
        end if
        if find('$',Name)!=0 then return fatal("section name must not contain $") end if
        if find(Name,{"UPX0\\0\\0\\0\\0","UPX1\\0\\0\\0\\0"}) then
            -- (obviously, if you want more, you must manually unpack the thing, using upx)
            return fatal("no further processing of upx-compressed executables")
        end if
        -- (The next field is PhysicalAddress in .OBJ files, but we are not 
        --  dealing with them, in .exe and .dll files it is the VirtualSize.)
        SH_VirtualSizes[i] = decode("VirtualSize","h4","")
        SH_VirtualAddress[i] = decode("VirtualAddress","h4","")
        if RelativeVirtualAddress[1]>=SH_VirtualAddress[i]
        and RelativeVirtualAddress[1]+RVASize[1]<=SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            nExportSection = i
            desc = "Export Section"
        elsif RelativeVirtualAddress[2]>=SH_VirtualAddress[i]
          and RelativeVirtualAddress[2]+RVASize[2]<=SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            nImportSection = i
            desc = "Import Section"
        elsif RelativeVirtualAddress[3]>=SH_VirtualAddress[i]
          and RelativeVirtualAddress[3]+RVASize[3]<=SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            nResourceSection = i
            desc = "Resource Section"
        elsif RelativeVirtualAddress[4]>=SH_VirtualAddress[i]
          and RelativeVirtualAddress[4]+RVASize[4]<=SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            nExceptions = i
            desc = "Exceptions"
        elsif RelativeVirtualAddress[6]>=SH_VirtualAddress[i]
          and RelativeVirtualAddress[6]+RVASize[6]<=SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            nRelocSection = i
            desc = "Relocations"
        else
            desc = ""
        end if

        if length(desc) then
            SectionNames[i] = desc
            desc = sprintf(" (see \"%s\" tab)",{desc})
        end if
        SizeOfRawData[i] = decode("SizeOfRawData","h4","")
--DEV NotPhix??:
--      if remainder(SizeOfRawData[i],FileAlignment) then
--          return fatal("must be a multiple of FileAlignment") -- (erm "from the optional header?")
--      end if
        PointerToRawData[i] = decode("PointerToRawData","h4",desc)
        if remainder(PointerToRawData[i],FileAlignment) then
            return fatal("must be a multiple of FileAlignment") -- (erm "from the optional header?")
        end if
        k = length(res[tabidx])
        PointerToRelocations = decode("PointerToRelocations","h4","  (should be 0)")
        PointerToLinenumbers = decode("PointerToLinenumbers","h4","  (should be 0)")
        NumberOfRelocations = decode("NumberOfRelocations","h2","  (should be 0)")
        NumberOfLinenumbers = decode("NumberOfLinenumbers","h2","  (should be 0)")
--DEV NotPhix:
--      if PointerToRelocations!=0
--      or PointerToLinenumbers!=0
--      or NumberOfRelocations!=0
--      or NumberOfLinenumbers!=0 then
--          return fatal("invalid")
--      end if
        SectionCharacteristics = decode("Characteristics","h4","")
        res[tabidx][$][R_NOTES] = decode_flags(SectionCharacteristicSet,SectionCharacteristics)
--      if SectionCharacteristics=IMAGE_SCN_CNT_CODE+IMAGE_SCN_MEM_EXECUTE+IMAGE_SCN_MEM_READ and desc="" then
        if and_bits(SectionCharacteristics,IMAGE_SCN_ALIGN_16BYTES) then
            SectionCharacteristics -= IMAGE_SCN_ALIGN_16BYTES
        elsif and_bits(SectionCharacteristics,IMAGE_SCN_ALIGN_4BYTES) then
            SectionCharacteristics -= IMAGE_SCN_ALIGN_4BYTES
        end if
        if and_bits(SectionCharacteristics,IMAGE_SCN_CNT_INITIALIZED_DATA) then
            SectionCharacteristics -= IMAGE_SCN_CNT_INITIALIZED_DATA
        end if
        if (SectionCharacteristics=IMAGE_SCN_CNT_CODE+IMAGE_SCN_MEM_EXECUTE+IMAGE_SCN_MEM_READ or
            SectionCharacteristics=IMAGE_SCN_CNT_CODE+IMAGE_SCN_MEM_READ+IMAGE_SCN_MEM_WRITE)
        and (desc="" or Name=".text\\0\0\\0" or Name=".code\\0\0\\0") then
            sCodeSections = append(sCodeSections,i)
            if length(sCodeSections)=1 then
                desc = " (see \"Code Section\" tab)"
            else
                NotPhix("more than one code section")
                desc = sprintf(" (see \"Code Section(%d)\" tab)",length(sCodeSections))
            end if
            res[tabidx][k][R_NOTES] = desc
        elsif Name=".data\\0\\0\\0" and SizeOfRawData[i]!=0 then
            sDataSections = append(sDataSections,i)
            if length(sDataSections)=1 then
                desc = " (see \"Data Section\" tab)"
            else
                NotPhix("more than one data section")
                desc = sprintf(" (see \"Data Section(%d)\" tab)",length(sDataSections))
            end if
            res[tabidx][k][R_NOTES] = desc
        end if
        addsep()
    end for
    size = roundto(address,FileAlignment)-address
    if size!=0 then
        binary_dump(size,"padding")
    end if
    return 1
end function

function decode_import_section(integer justsettab)
integer size
integer StartAddress
integer ImportBase
atom ThunkBase
integer allnull
integer OriginalFirstThunk
atom TimeDateStamp
integer ForwarderChain
integer Name
integer FirstThunk
integer k
sequence Names
sequence NameIdx
sequence HintNames
sequence OriginalHintNames
atom NewAddr

string text
sequence line

atom RVA
sequence ThunkSet
sequence ThunkIdx
atom ThunkAddr
sequence ThunknownIdx
integer Hint

--integer Size
atom Size
integer NoMorePadding = 0

    SetTabIdx("Import Section")
    if justsettab then return 0 end if
    size = RVASize[2] -- (as noted below, this may only cover the initial IMAGE_IMPORT_DESCRIPTOR array)
    address = PointerToRawData[nImportSection]+RelativeVirtualAddress[2]-SH_VirtualAddress[nImportSection]
    StartAddress = address
    ImportBase = StartAddress-RelativeVirtualAddress[2]
    ThunkBase = xImageBase-ImportBase

    --
    -- Collect any pointers we find, and (hopefully) get through them all later.
    --
    Names = {}
    NameIdx = {}
    HintNames = {}
    OriginalHintNames = {}

    -- An array of IMAGE_IMPORT_DESCRIPTOR (ends with an an all null one)
    -- (for some reason this is not documented on MSDN)
--/*
--// Image import descriptor
--typedef struct _IMAGE_IMPORT_DESCRIPTOR {
--  union {
--      DWORD   Characteristics;            // 0 for terminating null import descriptor
--      DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
--  } DUMMYUNIONNAME;
--  DWORD   TimeDateStamp;                  // 0 if not bound,
--                                          // -1 if bound, and real date\time stamp
--                                          //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
--                                          // O.W. date/time stamp of DLL bound to (Old BIND)
--
--  DWORD   ForwarderChain;                 // -1 if no forwarders
--  DWORD   Name;
--  DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
--} IMAGE_IMPORT_DESCRIPTOR;
--typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;
--*/
    while 1 do
        if address+20>file_size then return fatal("unexpected end of file") end if
        OriginalFirstThunk = decode("OriginalFirstThunk","h4","")   -- Import Table Lookup RVA (optional)
        allnull = 1
        if OriginalFirstThunk!=0 then
            allnull = 0
            NewAddr = OriginalFirstThunk+ImportBase
            k = length(res[tabidx])
            res[tabidx][k][R_NOTES] = sprintf("Hint Name Array, see 0x%08x",NewAddr)
            OriginalHintNames = append(OriginalHintNames,NewAddr)
        end if
        TimeDateStamp = decode("TimeDateStamp","h4","")
        if TimeDateStamp!=0 then
            allnull = 0
            --DEV windows only:
-->         res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(TimeDateStamp))
--          timedate td = adjust_timedate(Jan1st1970,TimeDateStamp)
--          res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
            res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,TimeDateStamp))
        else
            res[tabidx][$][R_NOTES] = "(should be 0 if not bound)"
        end if
        ForwarderChain = decode("ForwarderChain","h4","")
        if ForwarderChain!=0 then return fatal("ForwarderChain!=0 (help!)") end if -- (never seen any)
        Name = decode("Name","h4","")
        if Name!=0 then
            allnull = 0
            NewAddr = Name+ImportBase
            k = length(res[tabidx])
            res[tabidx][k][R_NOTES] = sprintf("Dll Name, see 0x%08x",NewAddr)   -- (overidden below)
            Names = append(Names,NewAddr)
            NameIdx = append(NameIdx,k)
        end if
        FirstThunk = decode("FirstThunk","h4","")   -- RVA to array of IMAGE_THUNK_DATA32/64
        if FirstThunk!=0 then
            allnull = 0
            NewAddr = FirstThunk+ImportBase
            k = length(res[tabidx])
            res[tabidx][k][R_NOTES] = sprintf("Hint Name Array, see 0x%08x",NewAddr)
            HintNames = append(HintNames,NewAddr)
        end if
        size -= 20 -- sizeofstruct(IMAGE_IMPORT_DESCRIPTOR) [same for 32/64]
        addsep()
        if allnull then exit end if
    end while
    --
    -- The IMAGE_IMPORT_DESCRIPTOR above contain pointers (RVAs), so 
    -- presumably the rest of this section can be written in any order. 
    -- Try to do things in file address order. (Update: I have seen a
    -- file with the import RVA at the end of the Import Section, and
    -- thus said pointers leading somewhere earlier in the file...
    -- I ended up adding the NoMorePadding flag to cope.)
    --
    ThunkSet = {}
    ThunkIdx = {}
    ThunknownIdx = {}
    knownAddr = {}
    knownNames = {}

    while 1 do
        if address<0 then return fatal("oops, negative address") end if
        k = find(address,Names)
        if k!=0 then
            text = toString(-1)
            line = {address,"Name","-",text,""}
            res[tabidx] = append(res[tabidx],line)
            res[tabidx][NameIdx[k]][R_NOTES] = sprintf("[0x%08x:%s]",{address,text})
            Names[k..k] = {}
            NameIdx[k..k] = {}
            address += length(text)+1
            size -= length(text)+1
--          addsep()
        else
            k = find(address,HintNames)
            if k!=0 then
                HintNames[k..k] = {}
                -- An array of IMAGE_THUNK_DATA32/64 (in this case each is a single dword
                --  or qword which points to an IMAGE_IMPORT_BY_NAME structure, I think.)
                -- One d/qword RVA per line, until we hit a null.
                while 1 do
                    ThunkAddr = address+ThunkBase
                    if machine=32 then
                        RVA = decode(sprintf("Thunk [%08x]",ThunkAddr),"h4","")
                        size -= 4
                    else
                        RVA = decode(sprintf("Thunk [%08x]",ThunkAddr),"h8","")
                        size -= 8
                    end if
                    k = length(res[tabidx])
                    if RVA=0 then
                        res[tabidx][k][R_DESC] = "terminator"
--                      addsep()
                        exit
                    end if
                    if signed then
                        res[tabidx][k][R_NOTES] = "import by ordinal"
                    else
                        NewAddr = RVA+ImportBase
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",NewAddr)
                        ThunkSet = append(ThunkSet,NewAddr)
                        ThunkIdx = append(ThunkIdx,k)
                        knownAddr = append(knownAddr,ThunkAddr)
                        knownNames = append(knownNames,"eh?")
                        ThunknownIdx = append(ThunknownIdx,length(knownNames))
                    end if
                end while
            else
                k = find(address,OriginalHintNames)
                if k!=0 then
                    OriginalHintNames[k..k] = {}
                    -- An array of IMAGE_THUNK_DATA32/64 (as above, except these are
                    --  optional and any targets should have already been found.)
                    while 1 do
                        if machine=32 then
                            RVA = decode("Original Thunk","h4","")
                            size -= 4
                        else
                            RVA = decode("Original Thunk","h8","")
                            size -= 8
                        end if
                        k = length(res[tabidx])
                        if RVA=0 then
                            res[tabidx][k][R_DESC] = "terminator"
                            exit
                        end if
                        if signed then
                            res[tabidx][k][R_NOTES] = "import by ordinal"
                        else
                            NewAddr = RVA+ImportBase
                            res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",NewAddr)
                        end if
                    end while
                else
                    k = find(address,ThunkSet)
                    if k!=0 then
                        -- IMAGE_IMPORT_BY_NAME Structure
                        Hint = decode("Hint","h2","")
                        text = toString(-1)
                        line = {address,"Name","-",text,""}
                        res[tabidx] = append(res[tabidx],line)
                        res[tabidx][ThunkIdx[k]][R_NOTES] = sprintf("[0x%08x:%s]",{address-2,text})
                        knownNames[ThunknownIdx[k]] = text
                        ThunkSet[k..k] = {}
                        ThunkIdx[k..k] = {}
                        ThunknownIdx[k..k] = {}
                        address += length(text)+1
                        size -= length(text)+3
                    elsif length(Names)
                       or length(HintNames)
                       or length(OriginalHintNames)
                       or length(ThunkSet) then
                        Size = smallest(Names&HintNames&OriginalHintNames&ThunkSet)-address
                        if not integer(Size) then return fatal("not integer(Size)") end if
                        if NoMorePadding or Size<0 then
                            address = Size+address
                            NoMorePadding = 1
                        elsif NoMorePadding=0 then
                            if Size=1 and and_bits(address,#01) then
                                binary_dump(Size,"padding")
                            else
                                binary_dump(Size,"padding?")
                            end if
                            size -= Size
                        end if
                    else
                        exit
                    end if
                end if
            end if
        end if
        addsep()
    end while
    if NoMorePadding=0 then
-- bugfix: in lb\\test.dll, RVASize[2] just covers the array of IMAGE_IMPORT_DESCRIPTORs, and we overran that.
--      if size!=0 then -- oops
        if size>0 then -- oops
            if size<16 then
                binary_dump(size,"padding?")
            else
                binary_dump(size,"-")
                return fatal(sprintf("** %d bytes not analysed **",size))
            end if
        elsif size!=0 then
            NoMorePadding = 1
        end if
    end if
    if NoMorePadding=0 then
        -- (I used GraphR.exw to figure this one out!)
        size = SizeOfRawData[nImportSection]-RelativeVirtualAddress[2]+SH_VirtualAddress[nImportSection]-RVASize[2]
        if size!=0 then
            binary_dump(size,"padding")
        end if
    end if
    return 1
end function

function decode_export_section(integer justsettab)
integer size
integer StartAddress
integer EndAddress
integer ExportBase
integer ExportCharacteristics
atom TimeDateStamp
integer MajorVersion,MinorVersion
integer Name
integer OrdinalBase
integer NumberOfFunctions
integer NumberOfNames
integer AddressOfFunctions
integer AddressOfNames
integer AddressOfNameOrdinals

integer k
sequence Names, tmp
sequence NameIdx

string text
sequence line

atom RVA

sequence Functionk
sequence NameOrdinal
sequence Ordinal
sequence Ordinalk
integer OrdinalIdx
string desc

    SetTabIdx("Export Section")
    if justsettab then return 0 end if
    size = RVASize[1]
    address = PointerToRawData[nExportSection]+RelativeVirtualAddress[1]-SH_VirtualAddress[nExportSection]
    StartAddress = address
    EndAddress = StartAddress+size
    ExportBase = StartAddress-RelativeVirtualAddress[1]

--/*
typedef struct IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   OrdinalBase;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    PDWORD* AddressOfFunctions;
    PDWORD* AddressOfNames;
    PWORD*  AddressOfNameOrdinals;
}
--*/

    if address+40>file_size then return fatal("unexpected end of file") end if
    ExportCharacteristics = decode("ExportCharacteristics","h4","(should be 0)")
    TimeDateStamp = decode("TimeDateStamp","h4","")
    if TimeDateStamp!=0 then
        --DEV windows only:
-->     res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(TimeDateStamp))
--      timedate td = adjust_timedate(Jan1st1970,TimeDateStamp)
--      res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
        res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,TimeDateStamp))
    end if
    MajorVersion = decode("MajorVersion","h2","")
    MinorVersion = decode("MinorVersion","h2","")
    res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorVersion,MinorVersion})

    --
    -- Collect any pointers we find, and (hopefully) get through them all later.
    --
    Names = {}
    NameIdx = {}
    NameOrdinal = {}

    Name = decode("Name","h4","")
    if Name!=0 then
        Name += ExportBase
        k = length(res[tabidx])
        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",Name)
        Names = append(Names,Name)
        NameIdx = append(NameIdx,k)
        NameOrdinal = append(NameOrdinal,0)
    end if
    OrdinalBase = decode("OrdinalBase","h4","(usually 1)")  -- ??
    NumberOfFunctions = decode("NumberOfFunctions","h4","")
    NumberOfNames = decode("NumberOfNames","h4","")
    AddressOfFunctions = decode("AddressOfFunctions","h4","")+ExportBase
    res[tabidx][$][R_NOTES] = sprintf("see 0x%08x",AddressOfFunctions)
    AddressOfNames = decode("AddressOfNames","h4","")+ExportBase
    res[tabidx][$][R_NOTES] = sprintf("see 0x%08x",AddressOfNames)
    AddressOfNameOrdinals = decode("AddressOfNameOrdinals","h4","")+ExportBase
    res[tabidx][$][R_NOTES] = sprintf("see 0x%08x",AddressOfNameOrdinals)
    size -= 40
    addsep()

    while 1 do
        if address=AddressOfFunctions then
            Functionk = repeat(0,NumberOfFunctions)
            for i=1 to NumberOfFunctions do
                RVA = decode("RVA","h4","")+ExportBase
                k = length(res[tabidx])
                if RVA<StartAddress or RVA>EndAddress then
                    desc = "Export RVA"
                    Functionk[i] = k
                else
                    desc = "Forwarder RVA"
                    res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",RVA)
                    Names = append(Names,RVA)
                    NameIdx = append(NameIdx,k)
                    NameOrdinal = append(NameOrdinal,0)
                end if
                res[tabidx][$][R_DESC] = sprintf("%s[%d]",{desc,i})
                size -= 4
            end for
            addsep()
            AddressOfFunctions = 0
        elsif address=AddressOfNames then
            for i=1 to NumberOfNames do
                RVA = decode(sprintf("Name RVA[%d]",i),"h4","")
                if RVA!=0 then
                    RVA += ExportBase
                    k = length(res[tabidx])
                    res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",RVA)
                    Names = append(Names,RVA)
                    NameIdx = append(NameIdx,k)
                    NameOrdinal = append(NameOrdinal,i)
                    size -= 4
                end if
            end for
            addsep()
            AddressOfNames = 0
        elsif address=AddressOfNameOrdinals then
            Ordinal = repeat(0,NumberOfNames)
            Ordinalk = repeat(0,NumberOfNames)
            for i=1 to NumberOfNames do
                Ordinal[i] = decode(sprintf("Ordinal [%d]",i),"h2","") -- -Base?
                Ordinalk[i] = length(res[tabidx])
                size -= 2
            end for
            addsep()
            AddressOfNameOrdinals = 0
        else
            k = find(address,Names)
            if k=0 then
                tmp = Names
                if AddressOfFunctions!=0    then tmp = append(tmp,AddressOfFunctions)    end if
                if AddressOfNames!=0        then tmp = append(tmp,AddressOfNames)        end if
                if AddressOfNameOrdinals!=0 then tmp = append(tmp,AddressOfNameOrdinals) end if
                if length(tmp)=0 then exit end if
                k = smallest(tmp)-address
                if k<0 then ?9/0 end if
                binary_dump(k,"padding?")
                size -= k
            else
                text = toString(-1)
                line = {address,"Name","-",text,""}
                res[tabidx] = append(res[tabidx],line)
                res[tabidx][NameIdx[k]][R_NOTES] = sprintf("[0x%08x:%s]",{address,text})
                OrdinalIdx = NameOrdinal[k]
                if OrdinalIdx!=0 then
                    res[tabidx][Ordinalk[OrdinalIdx]][R_NOTES] = text
                    OrdinalIdx = Functionk[Ordinal[OrdinalIdx]+1]
                    if OrdinalIdx!=0 then
                        res[tabidx][OrdinalIdx][R_NOTES] = text
                    end if
                end if
                Names[k..k] = {}
                NameIdx[k..k] = {}
                NameOrdinal[k..k] = {}
                address += length(text)+1
                size -= length(text)+1
            end if
        end if
    end while

    if AddressOfFunctions!=0 then
        return fatal(sprintf("AddressOfFunctions not found [%08x]",{AddressOfFunctions}))
    end if
    if AddressOfNames!=0 then
        return fatal(sprintf("AddressOfNames not found [%08x]",{AddressOfNames}))
    end if
    if AddressOfNameOrdinals!=0 then
        return fatal(sprintf("AddressOfNameOrdinals not found [%08x]",{AddressOfNameOrdinals}))
    end if

    if size!=0 then -- oops
        if size<16 then
            binary_dump(size,"padding?")
        else
            binary_dump(size,"-")
            return fatal(sprintf("** %d bytes not analysed **",size))
        end if
    end if
--DEV see decode_import_section? (put back in for now)
--  size = SizeOfRawData[nExportSection]-RVASize[1]
--  size = SizeOfRawData[nExportSection]-RelativeVirtualAddress[1]+SH_VirtualAddress[nExportSection]-RVASize[1]
    if RelativeVirtualAddress[1]=SH_VirtualAddress[nExportSection] then
        size = SizeOfRawData[nExportSection]-RVASize[1]
        if size!=0 then
            binary_dump(size,"padding")
        end if
    end if
    return 1
end function

constant RelocationTypes = {"Absolute", -- 0
                            "High",     -- 1
                            "Low",      -- 2
                            "HighLow",  -- 3
                            "HighAdj",  -- 4
                            "ARMmov",   -- 5 (or MIPS jmp addr)
                            "Reserved", -- 6
                            "ARMmovt",  -- 7
                            "Unknown",  -- 8
                            "Unknown",  -- 9
                            "Dir64",    -- 10
                            "Unknown",  -- 11
                            "Unknown",  -- 12
                            "Unknown",  -- 13
                            "Unknown",  -- 14
                            "Unknown"}  -- 15
--/*
IMAGE_REL_BASED_ABSOLUTE 0 The base relocation is skipped. This type can be used to pad a block.
IMAGE_REL_BASED_HIGH 1 The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word.
IMAGE_REL_BASED_LOW 2 The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.
IMAGE_REL_BASED_HIGHLOW 3 The base relocation applies all 32 bits of the difference to the 32-bit field at offset.
IMAGE_REL_BASED_HIGHADJ 4 The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word. 
                          The low 16 bits of the 32-bit value are stored in the 16-bit word that follows this base relocation. This means that this base relocation occupies two slots.
IMAGE_REL_BASED_MIPS_JMPADDR
IMAGE_REL_BASED_ARM_MOV32A 5 For MIPS machine types, the base relocation applies to a MIPS jump instruction.
                             For ARM machine types, the base relocation applies the difference to the 32-bit value encoded in the immediate fields of a contiguous MOVW+MOVT pair in ARM mode at offset.
6 Reserved, must be zero.
IMAGE_REL_BASED_ARM_MOV32T 7 The base relocation applies the difference to the 32-bit value encoded in the immediate fields of a contiguous MOVW+MOVT pair in Thumb mode at offset.
IMAGE_REL_BASED_MIPS_JMPADDR16 9 The base relocation applies to a MIPS16 jump instruction.
IMAGE_REL_BASED_DIR64 10 The base relocation applies the difference to the 64-bit field at offset.
--*/

function decode_relocations(integer justsettab)
integer size
atom PageRVA
atom BlockSize
integer TypeOffset
string desc

    SetTabIdx("Relocations")
    if justsettab then return 0 end if
    size = RVASize[6]
    address = PointerToRawData[nRelocSection]+RelativeVirtualAddress[6]-SH_VirtualAddress[nRelocSection]
    while size>0 do
        PageRVA = decode("PageRVA","h4","")
        BlockSize = decode("BlockSize","h4","")
        if not integer(BlockSize) then return fatal("oops[1]") end if
        size -= BlockSize
        BlockSize -= 8
        while BlockSize>0 do
            TypeOffset = decode("TypeOffset","h2","")
            desc = sprintf("%s:#%04x",{RelocationTypes[floor(TypeOffset/#1000)+1],and_bits(TypeOffset,#0FFF)})
            res[tabidx][$][R_NOTES] = desc
            BlockSize -= 2
        end while
    end while
    if size!=0 then -- oops
        if size<0 then return fatal("oops, -ve padding") end if
        if size<16 then
            binary_dump(size,"padding?")
        else
            binary_dump(size,"-")
            return fatal(sprintf("** %d bytes not analysed **",size))
        end if
    end if
--DEV padding?
--  size = SizeOfRawData[nImportSection]-RelativeVirtualAddress[2]+SH_VirtualAddress[nImportSection]-RVASize[2]
    size = SizeOfRawData[nRelocSection]-RVASize[6]
    if size!=0 then
        binary_dump(size,"padding")
    end if
    return 1
end function

constant
--       RT_CURSOR      = 1,
--       RT_BITMAP      = 2,
         RT_ICON        = 3,
--       RT_MENU        = 4,
--       RT_DIALOG      = 5,
--       RT_STRING      = 6,
--       RT_FONTDIR     = 7,
--       RT_FONT        = 8,
--       RT_ACCELERATOR = 9,
--       RT_RCDATA      = 10,
--       RT_MESSAGETABLE= 11,
--       RT_GROUP_CURSOR= 12,
         RT_GROUP_ICON  = 14,
         RT_VERSION     = 16,
--       RT_DLGINCLUDE  = 17,
--       RT_PLUGPLAY    = 19,
--       RT_VXD         = 20,
--       RT_ANICURSOR   = 21,
--       RT_ANIICON     = 22,
--       RT_HTML        = 23,
         RT_MANIFEST    = 24

constant RT_DESCS = {"RT_CURSOR",           -- 1
                     "RT_BITMAP",           -- 2
                     "RT_ICON",             -- 3
                     "RT_MENU",             -- 4
                     "RT_DIALOG",           -- 5
                     "RT_STRING",           -- 6
                     "RT_FONTDIR",          -- 7
                     "RT_FONT",             -- 8
                     "RT_ACCELERATOR",      -- 9
                     "RT_RCDATA",           -- 10
                     "RT_MESSAGETABLE",     -- 11
                     "RT_GROUP_CURSOR",     -- 12
                     "??13??",
                     "RT_GROUP_ICON",       -- 14
                     "??15??",
                     "RT_VERSION",          -- 16
                     "RT_DLGINCLUDE",       -- 17
                     "??18??",
                     "RT_PLUGPLAY",         -- 19
                     "RT_VXD",              -- 20
                     "RT_ANICURSOR",        -- 21
                     "RT_ANIICON",          -- 22
                     "RT_HTML",             -- 23
                     "RT_MANIFEST"}         -- 24

sequence ResourceMasters -- so we can update names etc once when we find them.

function decode_resource_types(sequence ResourceType, integer parenthesize=0)
string res
object Type
integer Lang
object ID
    res = ""
    if length(ResourceType)>=1 then
        if parenthesize or length(ResourceType)>1 then
            res = "("
        end if
        -- Type
        Type = ResourceMasters[ResourceType[1]]
        if integer(Type) then
            if Type=0 then
                res &= "oops,0"
            elsif Type<1 or Type>length(RT_DESCS) then
--              res &= sprintf("oops, Type is %d [not 1..%d]",{Type,length(RT_DESCS)})
                res &= sprintf("%d",Type)
            else
                res &= RT_DESCS[Type]
            end if
        else
            res &= Type
        end if
        if length(ResourceType)>=2 then
            -- Name (ID)
            if not parenthesize and length(ResourceType)=2 then
                res &= ",)"
            else
                res &= ","
            end if
            ID = ResourceMasters[ResourceType[2]]
            if integer(ID) then
                res &= sprintf("%d",ID)
            else
                res &= ID
            end if
            if length(ResourceType)>=3 then
                -- Language
                Lang = ResourceMasters[ResourceType[3]]
                if parenthesize then
                    res &= ","
                else
                    res &= ",)"
                end if
                if Lang=0 then
                    res &= "LANG_NEUTRAL"
                elsif Lang=#409 then
                    res &= "SUBLANG_NEUTRAL+LANG_ENGLISH"
                else
                    res &= sprintf("LANG(%d)",Lang)
                end if
            end if
        end if
        if parenthesize then
            res &= ")"
        end if
    end if
    return res
end function


--#without reformat
constant
    VS_FF_DEBUG         = 0x00000001,   -- The file contains debugging information or is compiled with debugging features enabled.
    VS_FF_INFOINFERRED  = 0x00000010,   -- The file's version structure was created dynamically; therefore, some of the members in this structure may be empty or incorrect. 
                                        -- This flag should never be set in a file's VS_VERSIONINFO data. 
    VS_FF_PATCHED       = 0x00000004,   -- The file has been modified and is not identical to the original shipping file of the same version number.
    VS_FF_PRERELEASE    = 0x00000002,   -- The file is a development version, not a commercially released product.
    VS_FF_PRIVATEBUILD  = 0x00000008,   -- The file was not built using standard release procedures. If this flag is set, the StringFileInfo structure should contain a PrivateBuild entry. 
    VS_FF_SPECIALBUILD  = 0x00000020,   -- The file was built by the original company using standard release procedures but is a variation of the normal file of the same version number. 
                                        -- If this flag is set, the StringFileInfo structure should contain a SpecialBuild entry. 

    FileFlagset = {
        {VS_FF_DEBUG,           "DEBUG"},
        {VS_FF_INFOINFERRED,    "INFOINFERRED"},
        {VS_FF_PATCHED,         "PATCHED"},
        {VS_FF_PRERELEASE,      "PRERELEASE"},
        {VS_FF_PRIVATEBUILD,    "PRIVATEBUILD"},
        {VS_FF_SPECIALBUILD,    "SPECIALBUILD"}},


    VOS_UNKNOWN     = 0x00000000,   -- The operating system for which the file was designed is unknown to the system.
    VOS_DOS         = 0x00010000,   -- The file was designed for MS-DOS.
    VOS_NT          = 0x00040000,   -- The file was designed for Windows NT.
    VOS__WINDOWS16  = 0x00000001,   -- The file was designed for 16-bit Windows.
    VOS__WINDOWS32  = 0x00000004,   -- The file was designed for 32-bit Windows.
    VOS_OS216       = 0x00020000,   -- The file was designed for 16-bit OS/2.
    VOS_OS232       = 0x00030000,   -- The file was designed for 32-bit OS/2.
    VOS__PM16       = 0x00000002,   -- The file was designed for 16-bit Presentation Manager.
    VOS__PM32       = 0x00000003,   -- The file was designed for 32-bit Presentation Manager.

    FileOSset = {
        {VOS_UNKNOWN,       "VOS_UNKNOWN"},
        {VOS_DOS,           "VOS_DOS"},
        {VOS_NT,            "VOS_NT"},
        {VOS__WINDOWS16,    "VOS__WINDOWS16"},
        {VOS__WINDOWS32,    "VOS__WINDOWS32"},
        {VOS_OS216,         "VOS_OS216"},
        {VOS_OS232,         "VOS_OS232"},
        {VOS__PM16,         "VOS__PM16"},
        {VOS__PM32,         "VOS__PM32"}},

    VFT_UNKNOWN     = 0x00000000,   -- The file type is unknown to the system.
    VFT_APP         = 0x00000001,   -- The file contains an application.
    VFT_DLL         = 0x00000002,   -- The file contains a DLL.
    VFT_DRV         = 0x00000003,   -- The file contains a device driver. If dwFileType is VFT_DRV, dwFileSubtype contains a more specific description of the driver. 
    VFT_FONT        = 0x00000004,   -- The file contains a font. If dwFileType is VFT_FONT, dwFileSubtype contains a more specific description of the font file. 
    VFT_VXD         = 0x00000005,   -- The file contains a virtual device.
    VFT_STATIC_LIB  = 0x00000007,   -- The file contains a static-link library.

    FileTypeSet = {
        {VFT_UNKNOWN,       "VFT_UNKNOWN"},
        {VFT_APP,           "VFT_APP"},
        {VFT_DLL,           "VFT_DLL"},
        {VFT_DRV,           "VFT_DRV"},
        {VFT_FONT,          "VFT_FONT"},
        {VFT_VXD,           "VFT_VXD"},
        {VFT_STATIC_LIB,    "VFT_STATIC_LIB"}}

--#with reformat

--with trace
function decode_resource_section(integer justsettab)
--
-- This is a dirty little byte hack (oh really, Pete?); if you (just) want to 
--  extract some values from a resource section, use GetFileVersionInfo() etc.
--  I have only gone into detail here as part of making the compiler write a
--  resource section, without resorting to a resource compiler. I have made no
--  particular attempt to decipher NameRVA contents (it kinda "just" works).
--
-- Debugging tip: In particular, RT_VERSION caused me some grief trying to get
--  the byte counting and padding right. The ONLY way I could make any progress
--  was to plant a huge "if 0 then .. end if" over that section and let it run
--  to a 'binary_dump(Size,"data")' statement, then gradually shrink the area
--  it covers until the error was revealed, and add lots of error testing code
--  such as "if address+size!=EndAddress then ?9/0 end if". The real problem
--  was that being N bytes out here went bang much later on, typically in a
--  binary_dump (especially so before said routine checked for -ve size).
--  The fourth line or so of code serves both as an example, and a quick fix
--  should you encounter a troublesome file (and it's not really the resource
--  section of that file that interests you).
--
integer size
integer StartAddress
integer EndAddress
integer ResourceBase
atom ResourceCharacteristics
atom TimeDateStamp
integer MajorVersion,MinorVersion
integer NumberOfNamedEntries
integer NumberOfIdEntries
atom NameRVA
atom DataEntryRVA
atom ID
integer k
sequence Directories
-- ResourceTypes are determined by the nested IDs which are always followed by an RVA,
--  so I repeat them (in brackets) against the ResourceCharacteristics and Codepage
--  lines, since said RVA may be quite some distance away. To cope with named entries,
--  which usually get discovered after the thing they are supposed to describe, I use
--  ResourceMasters, and everything in ResourceType[s] is an index into that.
--  DataResourceTypes is only used (against CodePage) to repeat something already mentioned.
sequence ResourceTypes
sequence ResourceType -- current set
sequence ResourceDescs  -- for later updating
sequence DataEntries
sequence DataResourceTypes
sequence Data
sequence DataTypes
integer DataType
sequence Sizes
sequence Strings
sequence StringIdx
integer stringaddr

atom DataRVA
atom Size
atom Codepage
atom Reserved

integer Length
string text
sequence rdi

integer firsttime

    SetTabIdx("Resource Section")
    if justsettab then return 0 end if
    size = RVASize[3]
    address = PointerToRawData[nResourceSection]+RelativeVirtualAddress[3]-SH_VirtualAddress[nResourceSection]
    if 0 then
        binary_dump(size,"data")
    else
        StartAddress = address
        EndAddress = StartAddress+size
        if address+size!=EndAddress then ?9/0 end if
        ResourceBase = StartAddress--RelativeVirtualAddress[3]
--/*
typedef struct IMAGE_RESOURCE_DIRECTORY {
        DWORD Characteristics;
        DWORD TimeDateStamp;
        WORD MajorVersion;
        WORD MinorVersion;
        WORD NumberOfNamedEntries;
        WORD NumberOfIdEntries;
}
_ANONYMOUS_STRUCT typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
        _ANONYMOUS_UNION union {
                _ANONYMOUS_STRUCT struct {
                        DWORD NameOffset:31;
                        DWORD NameIsString:1;
                }DUMMYSTRUCTNAME;
                DWORD Name;
                WORD Id;
        } DUMMYUNIONNAME;
        _ANONYMOUS_UNION union {
                DWORD OffsetToData;
                _ANONYMOUS_STRUCT struct {
                        DWORD OffsetToDirectory:31;
                        DWORD DataIsDirectory:1;
                } DUMMYSTRUCTNAME2;
        } DUMMYUNIONNAME2;
}
typedef struct IMAGE_RESOURCE_DIRECTORY_STRING {
        WORD Length;
        CHAR NameString[1];
}
typedef struct IMAGE_RESOURCE_DIR_STRING_U {
        WORD Length;
        WCHAR NameString[1];
}
typedef struct IMAGE_RESOURCE_DATA_ENTRY {
        DWORD OffsetToData;
        DWORD Size;
        DWORD CodePage;
        DWORD Reserved;
}

--*/
        Directories = {address}
        ResourceTypes = {{}}
        ResourceDescs = {}
        ResourceMasters = {}
        DataEntries = {}
        DataResourceTypes = {}
        Data = {}
        DataTypes = {}
        Sizes = {}
        Strings = {}
        StringIdx = {}
        firsttime = 1
        while 1 do
--if address=#aaf0 then trace(1) end if
            if not firsttime then addsep() end if
            k = find(address,Directories)
            if k then
                ResourceType = ResourceTypes[k]
                Directories[k..k] = {}
                ResourceTypes[k..k] = {}
                ResourceCharacteristics = decode("ResourceCharacteristics","h4","(should be 0)")
                if ResourceCharacteristics!=0 then return fatal("Resource Characteristics should be 0") end if
                ResourceDescs = append(ResourceDescs,{length(res[tabidx]),ResourceType,1})
--              res[tabidx][$][R_NOTES] = decode_resource_types(ResourceType,1) -- now done (via "") later
                size -= 4
                if ResourceCharacteristics!=0 then exit end if
                TimeDateStamp = decode("TimeDateStamp","h4","")
                if TimeDateStamp!=0 then
                    --DEV windows only:
-->                 res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(TimeDateStamp))
--                  timedate td = adjust_timedate(Jan1st1970,TimeDateStamp)
--                  res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
                    res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,TimeDateStamp))
                end if
                MajorVersion = decode("MajorVersion","h2","")
                MinorVersion = decode("MinorVersion","h2","")
                res[tabidx][$-1][R_NOTES] = sprintf("%d.%d",{MajorVersion,MinorVersion})
                NumberOfNamedEntries = decode("NumberOfNamedEntries","h2","")
                if NumberOfNamedEntries!=0 then
                    NotPhix("NumberOfNamedEntries!=0 in resource section")
                end if
                NumberOfIdEntries = decode("NumberOfIdEntries","h2","")
                size -= 12
                addsep()
                for i=1 to NumberOfNamedEntries do
--if length(ResourceType)!=0 then ?9/0 end if
                    NameRVA = decode("NameRVA","h4","")
                    k = length(res[tabidx])
                    if and_bits(NameRVA,#80000000) then
                        NameRVA = and_bits(NameRVA,#7FFFFFFF)
                        NameRVA += ResourceBase
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",NameRVA)
                        ResourceMasters = append(ResourceMasters,15)    -- dummy value to be updated
--printf(1,"append(Strings,#%08x) @ #%08x\n",{NameRVA,address})
                        Strings = append(Strings,NameRVA)
                        StringIdx = append(StringIdx,{k,length(ResourceMasters)})
                    else
                        -- (not actually found an example of this yet)
                        ResourceMasters = append(ResourceMasters,NameRVA)
                        res[tabidx][k][R_NOTES] = sprintf("Integer ID %d",NameRVA)
                    end if
                    DataEntryRVA = decode("DataEntryRVA","h4","")
                    k = length(res[tabidx])
                    if and_bits(DataEntryRVA,#80000000) then
                        DataEntryRVA = and_bits(DataEntryRVA,#7FFFFFFF)+ResourceBase
                        Directories = append(Directories,DataEntryRVA)
                        ResourceTypes = append(ResourceTypes,ResourceType&length(ResourceMasters))
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x (subdirectory)",DataEntryRVA)
                    else
                        DataEntryRVA += ResourceBase
                        DataEntries = append(DataEntries,DataEntryRVA)
                        DataResourceTypes = append(DataResourceTypes,ResourceType&length(ResourceMasters))
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",DataEntryRVA)
                    end if
                    size -= 8
                end for
                for i=1 to NumberOfIdEntries do
                    ID = decode("ID","h4","")
                    ResourceMasters = append(ResourceMasters,ID)
                    if firsttime
                    and not find(ID,{RT_ICON,RT_GROUP_ICON,RT_VERSION,RT_MANIFEST}) then
                        if ID<1 or ID>length(RT_DESCS) then
                            NotPhix(sprintf("Type %d in the resource section",ID))
                        else
                            NotPhix(RT_DESCS[ID]&" in the resource section")
                        end if
                    end if
                    ResourceDescs = append(ResourceDescs,{length(res[tabidx]),ResourceType&length(ResourceMasters),0})
--                  res[tabidx][$][R_NOTES] = decode_resource_types(ResourceType&ID) -- now done (via "") later
                    DataEntryRVA = decode("DataEntryRVA","h4","")
                    k = length(res[tabidx])
                    if and_bits(DataEntryRVA,#80000000) then
                        DataEntryRVA = and_bits(DataEntryRVA,#7FFFFFFF)+ResourceBase
                        Directories = append(Directories,DataEntryRVA)
                        ResourceTypes = append(ResourceTypes,ResourceType&length(ResourceMasters))
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x (subdirectory)",DataEntryRVA)
                    else
                        DataEntryRVA += ResourceBase
                        DataEntries = append(DataEntries,DataEntryRVA)
                        DataResourceTypes = append(DataResourceTypes,ResourceType&length(ResourceMasters))
                        res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",DataEntryRVA)
                    end if
                    size -= 8
                end for
                firsttime = 0
            else
                k = find(address,DataEntries)
                if k then
                    ResourceType = DataResourceTypes[k]
                    DataEntries[k..k] = {}
                    DataResourceTypes[k..k] = {}
--                  DataRVA = decode("DataRVA","h4","") + ResourceBase
                    DataRVA = decode("DataRVA","h4","")+(ResourceBase-RelativeVirtualAddress[3])
--if DataRVA=#AAF0 then trace(1) end if
                    Data = append(Data,DataRVA)
                    DataTypes = append(DataTypes,ResourceMasters[ResourceType[1]])
                    k = length(res[tabidx])
                    res[tabidx][k][R_NOTES] = sprintf("see 0x%08x",DataRVA)
                    Size = decode("Size","h4","")
--DEV or padding...
--                  Size = 4 * (floor((Size+3)/4)) -- round up to whole number of dwords
                    Sizes = append(Sizes,Size)
                    Codepage = decode("Codepage","h4","")
                    ResourceDescs = append(ResourceDescs,{length(res[tabidx]),ResourceType,1})
--                  res[tabidx][$][R_NOTES] = decode_resource_types(ResourceType,1) -- now done (via "") later
                    Reserved = decode("Reserved","h4","")
                    size -= 16
                else
                    k = find(address,Data)
                    if k then
                        Size = Sizes[k]
                        DataType = DataTypes[k]
                        if DataType=RT_GROUP_ICON then
                            integer idReserved
                            integer idType
                            integer idCount
                            integer bWidth, bHeight, bColorCount, bReserved, wPlanes, wBitCount, dwBytesInRes
                            string desc

                            idReserved = decode("idReserved",2,"(must be 0) [RT_GROUP_ICON]")
                            if idReserved!=0 then return fatal("error") end if
                            idType = decode("idType",2,"")
                            if idType=1 then
                                desc = "icon"
                            elsif idType=2 then
                                desc = "cursor"
                            else
                                return fatal("unknown type")
                            end if
                            res[tabidx][$][R_NOTES] = desc
                            idCount = decode("idCount",2,"")
                            size -= 6

                            for i=1 to idCount do
                                addsep()
                                bWidth = decode("bWidth",1,"")
                                bHeight = decode("bHeight",1,"")
                                bColorCount = decode("bColorCount",1,"")
                                bReserved = decode("bReserved",1,"(must be 0)")
                                if bReserved!=0 then return fatal("error") end if
                                wPlanes = decode("wPlanes",2,"")
                                wBitCount = decode("wBitCount",2,"")
                                dwBytesInRes = decode("dwBytesInRes",4,"")
                                ID = decode("ID",2,"")
                                size -= 14
                            end for
                        elsif DataType=RT_VERSION then
                            integer wLength, wValueLength, wType, padding, len
                            string desc

                            if address+size!=EndAddress then ?9/0 end if
                            -- VS_VERSIONINFO structure:
                            wLength = decode("VS_VERSIONINFO.wLength",2,"")
                            if wLength!=Size then
                                ?"9/0"
                            end if
                            wValueLength = decode("VS_VERSIONINFO.wValueLength",2,"")
                            wType = decode("VS_VERSIONINFO.wType",2,"")
                            if wType=0 then
                                desc = "binary"
                            elsif wType=1 then
                                desc = "text"
                            else
                                return fatal("unknown type")
                            end if
                            res[tabidx][$][R_NOTES] = desc
                            len = decode_unicode_string("szKey",32,"")+6
                            Size -= len
                            size -= len
                            padding = floor((address+3)/4)*4-address
                            if padding!=0 then
                                binary_dump(padding,"padding")
                                Size -= padding
                                size -= padding
                            end if
                            if address+size!=EndAddress then ?9/0 end if
                            if wValueLength!=0 then
                                -- VS_FIXEDFILEINFO structure:
                                atom dwSignature, dwStrucVersion, dwFileVersionMS, dwFileVersionLS, dwProductVersionMS, dwProductVersionLS,
                                     dwFileFlagsMask, dwFileFlags, dwFileOS, dwFileType, dwFileSubtype, dwFileDateMS, dwFileDateLS

                                dwSignature = decode("VS_FIXEDFILEINFO.dwSignature","h4","(should be #FEEF04BD)")
                                if dwSignature!=#FEEF04BD then return fatal("error") end if
                                dwStrucVersion = decode("VS_FIXEDFILEINFO.dwStrucVersion","h4","")
                                text = sprintf("%d.%d",{floor(dwStrucVersion/#10000),and_bits(dwStrucVersion,#FFFF)})
                                res[tabidx][$][R_NOTES] = text
                                dwFileVersionMS = decode("VS_FIXEDFILEINFO.dwFileVersionMS","h4","")
                                dwFileVersionLS = decode("VS_FIXEDFILEINFO.dwFileVersionLS","h4","")
                                text = sprintf("%d.%d.%d.%d",{floor(dwFileVersionMS/#10000),and_bits(dwFileVersionMS,#FFFF),
                                                              floor(dwFileVersionLS/#10000),and_bits(dwFileVersionLS,#FFFF)})
                                res[tabidx][$-1][R_NOTES] = text
                                dwProductVersionMS = decode("VS_FIXEDFILEINFO.dwProductVersionMS","h4","")
                                dwProductVersionLS = decode("VS_FIXEDFILEINFO.dwProductVersionLS","h4","")
                                text = sprintf("%d.%d.%d.%d",{floor(dwProductVersionMS/#10000),and_bits(dwProductVersionMS,#FFFF),
                                                              floor(dwProductVersionLS/#10000),and_bits(dwProductVersionLS,#FFFF)})
                                res[tabidx][$-1][R_NOTES] = text
                                dwFileFlagsMask = decode("VS_FIXEDFILEINFO.dwFileFlagsMask","h4","")
                                dwFileFlags = decode("VS_FIXEDFILEINFO.dwFileFlags","h4","")
                                res[tabidx][$][R_NOTES] = decode_flags(FileFlagset,and_bits(dwFileFlags,dwFileFlagsMask))
                                dwFileOS = decode("VS_FIXEDFILEINFO.dwFileOS","h4","")
                                res[tabidx][$][R_NOTES] = decode_flags(FileOSset,dwFileOS)
                                dwFileType = decode("VS_FIXEDFILEINFO.dwFileType","h4","")
                                res[tabidx][$][R_NOTES] = decode_flags(FileTypeSet,dwFileType)
                                dwFileSubtype = decode("VS_FIXEDFILEINFO.dwFileSubtype","h4","")
                                dwFileDateMS = decode("VS_FIXEDFILEINFO.dwFileDateMS","h4","")
                                dwFileDateLS = decode("VS_FIXEDFILEINFO.dwFileDateLS","h4","")
                                Size -= 52
                                size -= 52
                                padding = floor((address+3)/4)*4-address
                                if padding!=0 then
                                    binary_dump(padding,"padding")
                                    Size -= padding
                                    size -= padding
                                end if
                            end if
                            if address+size!=EndAddress then ?9/0 end if
                            while Size>6 do
                                addsep()
                                wLength = decode("Children.wLength",2,"")
                                wValueLength = decode("Children.wValueLength",2,"(should be 0)")
                                if wValueLength!=0 then
--                                  return fatal(?)
                                    Size -= 4
                                    size -= 4
                                    wLength -= 4
                                    exit
                                end if
                                wType = decode("Children.wType",2,"")
                                Size -= 6
                                size -= 6
                                wLength -= 6
                                if wType=0 then
                                    desc = "binary"
                                elsif wType=1 then
                                    desc = "text"
                                else
                                    return fatal("unknown type")
                                end if
                                res[tabidx][$][R_NOTES] = desc
                                if binary[address+1]='S' then
                                    -- StringFileInfo structure
                                    if address+size!=EndAddress then ?9/0 end if
                                    len = decode_unicode_string("szKey",30,"")
                                    Size -= len
                                    size -= len
                                    wLength -= len
                                    if unicode_string!="StringFileInfo" then
--                                      return fatal(?)
                                        exit
                                    end if
                                    padding = floor((address+3)/4)*4-address
                                    if padding!=0 then
                                        binary_dump(padding,"padding")
                                        Size -= padding
                                        size -= padding
--                                      wLength -= padding
                                    end if
                                    -- StringTable structure
                                    integer wLengthST = decode("StringTable.wLength",2,"")
                                    if wLengthST!=wLength then
--                                      return fatal("?")
                                        Size -= 2
                                        size -= 2
                                        wLength -= 2
                                        wLengthST -= 2
                                        exit
                                    end if
                                    wValueLength = decode("StringTable.wValueLength",2,"(should be 0)")
                                    if wValueLength!=0 then
--                                      return fatal(?)
                                        Size -= 2
                                        size -= 2
                                        wLength -= 2
                                        wLengthST -= 2
                                        exit
                                    end if
                                    wType = decode("StringTable.wType",2,"")
                                    if wType=0 then
                                        desc = "binary"
                                    elsif wType=1 then
                                        desc = "text"
                                    else
                                        return fatal("unknown type")
                                    end if
                                    res[tabidx][$][R_NOTES] = desc
                                    len = decode_unicode_string("szKey",18,"lang/codepage")+6
                                    Size -= len
                                    size -= len
--                                  wLength -= len
                                    wLengthST -= len
                                    padding = floor((address+3)/4)*4-address
                                    if padding!=0 then
                                        binary_dump(padding,"padding")
                                        Size -= padding
                                        size -= padding
--                                      wLength -= padding
                                        wLengthST -= padding
                                    end if
                                    if address+size!=EndAddress then ?9/0 end if
--                                  while wLength>6 do
                                    while wLengthST>6 do
                                        if address+size!=EndAddress then ?9/0 end if
                                        -- String structure
--                                      integer !wLengthST = decode("String.wLength",2,"(in bytes)")
                                        {} = decode("String.wLength",2,"(in bytes)")
                                        wValueLength = decode("String.wValueLength",2,"(in words)")
                                        wType = decode("String.wType",2,"")
                                        Size -= 6
                                        size -= 6
                                        wLength -= 6
                                        wLengthST -= 6
                                        if wType=0 then
                                            desc = "binary"
                                        elsif wType=1 then
                                            desc = "text"
                                        else
                                            return fatal("unknown type")
--                                          exit
                                        end if
                                        res[tabidx][$][R_NOTES] = desc
                                        len = decode_unicode_string("szKey",-1,"")
                                        Size -= len
                                        size -= len
                                        wLength -= len
                                        wLengthST -= len
                                        padding = floor((address+3)/4)*4-address
                                        if padding!=0 then
                                            binary_dump(padding,"padding")
                                            Size -= padding
                                            size -= padding
--                                          wLength -= padding
                                            wLengthST -= padding
                                        end if
                                        if address+size!=EndAddress then ?9/0 end if
--                                      len = decode_unicode_string("String.Value",-1,"")
                                        if wValueLength!=0 then
                                            if wValueLength<=0 then
                                                return fatal("oops, wValueLength<=0")
                                            end if
                                            len = decode_unicode_string("String.Value",wValueLength*2,"")
                                            Size -= len
                                            size -= len
                                            wLength -= len
                                            wLengthST -= len
                                            padding = floor((address+3)/4)*4-address
                                            if padding!=0 then
                                                binary_dump(padding,"padding")
                                                Size -= padding
                                                size -= padding
--                                              wLength -= padding
                                                wLengthST -= padding
                                            end if
                                        end if
--DEV (temp)
                                        if address+size!=EndAddress then ?9/0 end if
                                    end while
--TEMP                      
                                    if address+size!=EndAddress then ?9/0 end if
--                                  if wLength!=0 then
----                                    if wLength>0 then
----trace(1)
--                                      binary_dump(wLength,"**oops**")
--                                      Size -= wLength
--                                      size -= wLength
--                                  end if
--                                  if wLengthST!=0 then
                                    if wLengthST>0 then -- (should not really have subtracted final padding)
--#without reformat
if wLengthST>Size then ?9/0 end if
--#with reformat
                                        binary_dump(size,"**oops**")
                                        Size -= wLengthST
                                        size -= wLengthST
                                    end if
                                    padding = floor((address+3)/4)*4-address
                                    if padding!=0 then
                                        binary_dump(padding,"padding")
                                        Size -= padding
                                        size -= padding
                                    end if
                                    if address+size!=EndAddress then ?9/0 end if

                                elsif binary[address+1]='V' then
                                    if address+size!=EndAddress then ?9/0 end if
                                    -- VarFileInfo structure
                                    len = decode_unicode_string("szKey",24,"")
                                    Size -= len
                                    size -= len
                                    wLength -= len
                                    if unicode_string!="VarFileInfo" then
--                                      return fatal(?)
                                        exit
                                    end if
                                    padding = floor((address+3)/4)*4-address
                                    if padding!=0 then
                                        binary_dump(padding,"padding")
                                        Size -= padding
                                        size -= padding
                                        wLength -= padding
                                    end if
                                    -- Var structure
                                    if decode("wLength",2,"(in bytes)")!=wLength then
--                                      return fatal(?)
                                        exit
                                    end if
                                    wValueLength = decode("wValueLength",2,"(in bytes)")
                                    wType = decode("wType",2,"")
                                    Size -= 6
                                    size -= 6
                                    wLength -= 6
                                    if wType=0 then
                                        desc = "binary"
                                    elsif wType=1 then
                                        desc = "text"
                                    else
                                        return fatal("unknown type")
                                    end if
                                    res[tabidx][$][R_NOTES] = desc
                                    len = decode_unicode_string("szKey",24,"(should be L\"Translation\")")
                                    Size -= len
                                    size -= len
                                    wLength -= len
                                    padding = floor((address+3)/4)*4-address
                                    if padding!=0 then
                                        binary_dump(padding,"padding")
                                        Size -= padding
                                        size -= padding
                                        wLength -= padding
                                    end if
                                    while wLength>=4 do
                                        {} = decode("dwValue","h4","")
                                        Size -= 4
                                        size -= 4
                                        wLength -= 4
                                    end while
--TEMP                          
                                    if wLength!=0 then
trace(1)
                                        binary_dump(wLength,"[temp]")
                                        Size -= wLength
                                        size -= wLength
                                    end if
                                else
--                                  return fatal(?)
                                    exit
                                end if
                            end while
                            if address+size!=EndAddress then ?9/0 end if
                            if Size!=0 then
                                --trace(1)
                                if Size>0 then
                                    binary_dump(Size,"data")
                                else
                                    ?"negative size, line 3564..\n"
                                end if
                                size -= Size
                            end if
--                          if address+size!=EndAddress then ?9/0 end if
                            if address+size!=EndAddress then
                                ?"wrong end address, line 3570..\n"
                            end if
                        else
                            binary_dump(Size,"data")
                            size -= Size
                        end if
                        Data[k..k] = {}
                        DataTypes[k..k] = {}
                        Sizes[k..k] = {}
                    else
                        k = find(address,Strings)
                        if k then
--                          ?9/0 -- untested?
                            stringaddr = address
                            Length = decode("Length","h2","")*2
                            size -= 2
                            text = WideCharToAnsi(binary[address+1..address+Length])
                            binary_dump(Length,"unicode")
                            size -= Length
-- 1/3/14:
--if 0 then
----DEV bad debug:
----                            res[tabidx][StringIdx[k]][R_NOTES] = sprintf("[0x%08x:%s]",{address,text})
----                            res[tabidx][StringIdx[k][1]][R_NOTES] = sprintf("[0x%08x:%s]",{address,text})
--                          res[tabidx][StringIdx[k][1]][R_NOTES] = sprintf("[0x%08x:%s]",{stringaddr,text})
--                          ResourceMasters[StringIdx[k][2]] = text
--                          Strings[k..k] = {}
--                          StringIdx[k..k] = {}
--else
                            while 1 do
                                res[tabidx][StringIdx[k][1]][R_NOTES] = sprintf("[0x%08x:%s]",{stringaddr,text})
                                ResourceMasters[StringIdx[k][2]] = text
                                Strings[k..k] = {}
                                StringIdx[k..k] = {}
                                k = find(stringaddr,Strings)
                                if k=0 then exit end if
                            end while
--end if
                        elsif length(Directories)
                           or length(DataEntries)
                           or length(Data)
                           or length(Strings) then
                            k = smallest(Directories&DataEntries&Data&Strings)
                            Size = k-address
--#without reformat
if Size<0 then return fatal(sprintf("oops, negative size (%d, see %08x)",{Size,k})) end if
--#with reformat
                            if Size<4 and and_bits(Size+address,#03)=0 then
                                binary_dump(Size,"padding")
                            else
                                binary_dump(Size,"padding?")
                            end if
                            size -= Size
                        else
                            exit
                        end if
                    end if
                end if
            end if
        end while
        for i=1 to length(ResourceDescs) do
            rdi = ResourceDescs[i]
            res[tabidx][rdi[1]][R_NOTES] = decode_resource_types(rdi[2],rdi[3])
        end for
        if size!=0 then -- oops
            if size<16 then
                if size<0 then return fatal("oops, -ve padding") end if
                binary_dump(size,"padding?")
            else
                binary_dump(size,"-")
                return fatal(sprintf("** %d bytes not analysed **",size))
            end if
        end if
    end if
    size = SizeOfRawData[nResourceSection]-RVASize[3]
    if size!=0 then
        binary_dump(size,"padding")
    end if
    return 1
end function

constant
    UNW_FLAG_EHANDLER  = 0x01,
    UNW_FLAG_UHANDLER  = 0x02,
    UNW_FLAG_CHAININFO = 0x04,

    ExceptionFlagsSet = {
--      {UNW_FLAG_EHANDLER, "UNW_FLAG_EHANDLER"},
--      {UNW_FLAG_UHANDLER, "UNW_FLAG_UHANDLER"},
--      {UNW_FLAG_CHAININFO,"UNW_FLAG_CHAININFO"}}
                         {UNW_FLAG_EHANDLER, "EHANDLER"},
                         {UNW_FLAG_UHANDLER, "UHANDLER"},
                         {UNW_FLAG_CHAININFO,"CHAININFO"}}

function decode_exceptions(integer justsettab)
integer size
integer StartAddress
integer ExceptionBase
atom ThunkBase
--integer allnull
--integer OriginalFirstThunk
--atom TimeDateStamp
--integer ForwarderChain
--integer Name
--integer FirstThunk
--integer k
--sequence Names
--sequence NameIdx
--sequence HintNames
--sequence OriginalHintNames
--atom NewAddr
--
--string text
--sequence line
--
--atom RVA
--sequence ThunkSet
--sequence ThunkIdx
--atom ThunkAddr
--sequence ThunknownIdx
--integer Hint
--
----integer Size
--atom Size
--integer NoMorePadding = 0
atom BeginAddress
atom EndAddress
atom UnwindData
integer vf, version,flags
integer SizeOfProlog
integer CountOfCodes
integer FrameRegisterOffset
atom ExceptionHandler
atom ExceptionData

    SetTabIdx("Exceptions")
    if justsettab then return 0 end if
    size = SH_VirtualSizes[nExceptions]
    address = PointerToRawData[nExceptions]+RelativeVirtualAddress[4]-SH_VirtualAddress[nExceptions]
    StartAddress = address
    ExceptionBase = StartAddress-RelativeVirtualAddress[4]
    ThunkBase = xImageBase-ExceptionBase

    for a=1 to RVASize[4] by 12 do
        BeginAddress = decode("BeginAddress","h4","")
        res[tabidx][$][R_NOTES] = sprintf("(code section #%08x)",BeginAddress+ImageBase)
        EndAddress = decode("EndAddress","h4","")
        res[tabidx][$][R_NOTES] = sprintf("(code section #%08x)",EndAddress+ImageBase)
        UnwindData = decode("UnwindData","h4","")
        res[tabidx][$][R_NOTES] = sprintf("see #%08x",UnwindData-SH_VirtualAddress[nExceptions]+PointerToRawData[nExceptions])
        size -= 12
    end for

    while size do
        vf = decode("Version,Flags","h1","")
        version = and_bits(vf,#07)
        flags = floor(vf/8)
        res[tabidx][$][R_NOTES] = sprintf("Version %d%s, Flags 0b%05b (%s)",{version,iff(version=1,"":"? (**should be 1**)"),
                                                                             flags,decode_flags(ExceptionFlagsSet,flags)})
        SizeOfProlog = decode("SizeOfProlog","h1","(should be 0)")
        CountOfCodes = decode("CountOfCodes","h1","(should be 0)")
        FrameRegisterOffset = decode("FrameRegisterOffset","h1","(should be 0:0)")
        ExceptionHandler = decode("ExceptionHandler","h4","")
        res[tabidx][$][R_NOTES] = sprintf("(code section #%08x)",ExceptionHandler+ImageBase)
        ExceptionData = decode("ExceptionData","h4","")
        size -= 12
    end while

--section '.pdata' readable writeable 
--
--data IMAGE_DIRECTORY_ENTRY_EXCEPTION 
--; typedef struct _RUNTIME_FUNCTION { 
--;   DWORD BeginAddress; 
--;   DWORD EndAddress; 
--;   DWORD UnwindData; 
--; } RUNTIME_FUNCTION, *PRUNTIME_FUNCTION; 
--; All three fields are RVAs (otherwise there wouldn't be dwords). 
--; BeginAddress     Points to the start address of the involved part of code.   
--; EndAddress   Points to the end address of the same part of code.     
--; UnwindData   Points to an UNWIND_INFO structure.      
--  dd RVA ex_handl_start 
--  dd RVA ex_handl_end 
--  dd RVA ex_handl_unwind 
--end data 
--
--ex_handl_unwind: 
--; The UNWIND_INFO structure tells how the portion of code should be handled. Here's the declaration I found on MSDN:  
--; typedef union _UNWIND_CODE { 
--;   struct { 
--;       UBYTE CodeOffset; 
--;       UBYTE UnwindOp : 4; 
--;       UBYTE OpInfo   : 4; 
--;   }; 
--;   USHORT FrameOffset; 
--; } UNWIND_CODE, *PUNWIND_CODE; 
--; 
--; typedef struct _UNWIND_INFO { 
--;   UBYTE Version       : 3;      \ PL: so that be one byte!
--;   UBYTE Flags         : 5;      / #19 = 0b10001001, 1 plus flags 2 and #10
--;   UBYTE SizeOfProlog; 
--;   UBYTE CountOfCodes; 
--;   UBYTE FrameRegister : 4; 
--;   UBYTE FrameOffset   : 4; 
--;   UNWIND_CODE UnwindCode[1]; 
--; /*  UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) & ~1) - 1]; 
--; *   union { 
--; *     OPTIONAL ULONG ExceptionHandler; 
--; *     OPTIONAL ULONG FunctionEntry; 
--; *   }; 
--; *   OPTIONAL ULONG ExceptionData[]; */ 
--; } UNWIND_INFO, *PUNWIND_INFO; 
--; Here's the description of the UNWIND_INFO structure members taken directly from the MSDN: 
--; Version Version number of the unwind data, currently 1.   (PL use #07 to extract)
--; Flags   Three flags are currently defined:  
--; UNW_FLAG_EHANDLER The function has an exception handler that should be called when looking for functions that need to examine exceptions.  
--; UNW_FLAG_UHANDLER The function has a termination handler that should be called when unwinding an exception.  
--; UNW_FLAG_CHAININFO This unwind info structure is not the primary one for the procedure. Instead, the chained unwind info entry is the contents of a previous RUNTIME_FUNCTION entry. 
--;                  See the following text for an explanation of chained unwind info structures. If this flag is set, then the UNW_FLAG_EHANDLER and UNW_FLAG_UHANDLER flags must be cleared. 
--;                  Also, the frame register and fixed-stack allocation fields must have the same values as in the primary unwind info.  
--; SizeOfProlog     Length of the function prolog in bytes.   
--; CountOfCodes     This is the number of slots in the unwind codes array. Note that some unwind codes (for example, UWOP_SAVE_NONVOL) require more than one slot in the array.   
--; FrameRegister    If nonzero, then the function uses a frame pointer, and this field is the number of the nonvolatile register used as the frame pointer, 
--;                     using the same encoding for the operation info field of UNWIND_CODE nodes.  
--; FrameOffset  If the frame register field is nonzero, then this is the scaled offset from RSP that is applied to the FP reg when it is established. 
--;                 The actual FP reg is set to RSP + 16 * this number, allowing offsets from 0 to 240. 
--;                 This permits pointing the FP reg into the middle of the local stack allocation for dynamic stack frames, allowing better code density 
--;                 through shorter instructions (more instructions can use the 8-bit signed offset form).  
--; UnwindCode   This is an array of items that explains the effect of the prolog on the nonvolatile registers and RSP. 
--;             See the section on UNWIND_CODE for the meanings of individual items. 
--;             For alignment purposes, this array will always have an even number of entries, with the final entry potentially unused 
--;             (in which case the array will be one longer than indicated by the count of unwind codes field).  
--; ExceptionHandler     This is an image-relative pointer to either the function's language-specific exception/termination handler (if flag UNW_FLAG_CHAININFO is clear and 
--;                     one of the flags UNW_FLAG_EHANDLER or UNW_FLAG_UHANDLER is set).   
--; Language-specific handler data (ExceptionData)   This is the function's language-specific exception handler data. 
--;                                                 The format of this data is unspecified and completely determined by the specific exception handler in use.   
--; Chained Unwind Info (ExceptionData) If flag UNW_FLAG_CHAININFO is set then the UNWIND_INFO structure ends with three UWORDs. 
--;                                     These UWORDs represent the RUNTIME_FUNCTION information for the function of the chained unwind.
--; The possible values of the Flags field are: 
--; #define UNW_FLAG_EHANDLER  0x01 (PL use shl/r 4 or #08 to test)
--; #define UNW_FLAG_UHANDLER  0x02 (PL use shl/r 4 or #10 to test)
--; #define UNW_FLAG_CHAININFO 0x04 (PL use shl/r 4 or #20 to test)
--  db 19h,0,0,0    ; #19 = 0b00011001, ie {1(=Version),1+2(=Flags, ie UNW_FLAG_EHANDLER+UNW_FLAG_UHANDLER)} [in the one byte]
--  dd RVA expt_handler 
--  dd 0 
--

    if size>0 then -- oops
        if size<16 then
            binary_dump(size,"padding?")
        else
            binary_dump(size,"-")
            return fatal(sprintf("** %d bytes not analysed **",size))
        end if
    end if
    addsep()
    size = SizeOfRawData[nExceptions]-RelativeVirtualAddress[4]+SH_VirtualAddress[nExceptions]-RVASize[4]
    if size!=0 then
        binary_dump(size,"padding")
    end if
    return 1
end function

function decode_data_section(integer idx, integer justsettab)
string desc
integer nDataSection
integer size, rawsize

    if idx=1 then
        desc = "Data Section"
    else
        desc = sprintf("Data Section(%d)",idx)
    end if
    SetTabIdx(desc)
    if justsettab then return 0 end if
    nDataSection = sDataSections[idx]
    address = PointerToRawData[nDataSection]
    SectionNames[nDataSection] = desc
    addr = SH_VirtualAddress[nDataSection]+ImageBase
--  size = SizeOfRawData[nDataSection]
    size = SH_VirtualSizes[nDataSection]
    rawsize = SizeOfRawData[nDataSection]
    if rawsize<size then
        NotPhix("data section rawsize<size")
        binary_dump(rawsize,"%08x (raw)")
    else
        {} = phix_datadump(size,"%08x")
        size = rawsize-size
        if size!=0 then
--?{address,size,address+size,file_size}
            if address+size>file_size then
                return fatal(sprintf("unexpected end of file (addr(#%08x)+size(#%08x)>filesize(#%08x)",{address,size,file_size}))
            end if
            binary_dump(size,"%08x:  padding")
        end if
    end if
    return 1
end function

--with trace
function is_PE_data(atom v)
integer dsi
atom vaddr
integer vsize
--trace(1)
    for i=1 to length(sDataSections) do
        dsi = sDataSections[i]
--      vaddr = PointerToRawData[dsi]
        vaddr = SH_VirtualAddress[dsi]+ImageBase
        vsize = SH_VirtualSizes[dsi]
        if v>=vaddr and v<=vaddr+vsize then
            return True
        end if
    end for
    return False
end function

function is_PE_code(atom v)
integer dsi
atom vaddr
integer vsize
--trace(1)
    for i=1 to length(sCodeSections) do
        dsi = sCodeSections[i]
--      vaddr = PointerToRawData[dsi]
        vaddr = SH_VirtualAddress[dsi]+ImageBase
        vsize = SH_VirtualSizes[dsi]
        if v>=vaddr and v<=vaddr+vsize then
            return True
        end if
    end for
    return False
end function

function decode_code_section(integer idx, integer justsettab)
string desc
integer nCodeSection
integer size
string asm,hex,analysis
atom taddr
sequence line
atom ilen

    if idx=1 then
        desc = "Code Section"
    else
        desc = sprintf("Code Section(%d)",idx)
    end if
    SetTabIdx(desc)
    if justsettab then return 0 end if
    nCodeSection = sCodeSections[idx]
--  size = SizeOfRawData[nCodeSection]
    SectionNames[nCodeSection] = desc
    size = SH_VirtualSizes[nCodeSection]
--  if length(NotPhixMessages)=0 then
    if 1 then
        code_section = binary
        CSvaddr = SH_VirtualAddress[nCodeSection]+ImageBase
        CSvsize = size
        address = PointerToRawData[nCodeSection]
-- 29/8/14:
        r_isdata = routine_id("is_PE_data")
-- 4/9/14:
        r_iscode = routine_id("is_PE_code")
        -- 4/9/14:
        X64 = (machine==64)
        newEmit = 1
        glblname = {}
        decodeinit(CSvaddr, address, machine, arch_PE)
        while addr<CSvaddr+size do
            ilen = addr
            {asm,taddr,hex,analysis} = p2asm:decode()
--if taddr = #040A20C then trace(1) end if
--if taddr = #100001024 then trace(1) end if
            ilen = addr-ilen
            line = {address,sprintf("%08x:  %s",{taddr,asm}),"-",hex,analysis}
            address += ilen
            res[tabidx] = append(res[tabidx],line)
            if asm="ret"
            or match("ret ",asm)=1
            or match("(ExitProcess)",asm) then
                addsep()
            end if
        end while
        r_isdata = -1
        r_iscode = -1
    else
        binary_dump(size,"%08x")
    end if
    size = SizeOfRawData[nCodeSection]-SH_VirtualSizes[nCodeSection]
    if size!=0 then
--      address = PointerToRawData[nCodeSection] + SH_VirtualSizes[nCodeSection]
        if address+size>file_size then
            return fatal(sprintf("unexpected end of file (Addr(#%08x)+size(#%08x)>filesize(#%08x)",{address,size,file_size}))
        end if
        if size<0 then
            return fatal(sprintf("oops,size<0 (%d)",{size}))
        end if
        binary_dump(size,"%08x:  padding")
    end if
    return 1
end function

function ConvertRVAtoRaw(atom RVA)
integer found = 0
    for i=1 to length(SH_VirtualAddress) do
        if RVA>=SH_VirtualAddress[i] and RVA<SH_VirtualAddress[i]+SH_VirtualSizes[i] then
            if found then ?9/0 end if
            found = i
        end if
    end for
--  if found=0 then ?9/0 end if -- (will crash on next line anyway)
    return RVA-SH_VirtualAddress[found]+PointerToRawData[found]
end function

--sequence pev --DEV
sequence elfv

--function trim_trailing(sequence s, sequence parts)
--  for i=length(parts) to 1 by -1 do
--      if parts[i]!=s[$] then exit end if
--      s = s[1..$-1]
--  end for
--  return s
--end function

--DEV temp: (for split_path)
include builtins\psplit.e

procedure GraphR(integer elf=0)
-- shows a simple visual representation of the file layout.
sequence v = {}
integer size, k, start, next
string text, desc

    if elf then
--      ?9/0
        v = elfv
        for i=1 to length(v) do
            {desc,start,next} = v[i]
            desc = sprintf("%s (#%x..#%x)",{desc,start,next-1})
            size = next-start
            v[i] = {desc,start,size}
        end for
    else -- pe
        for i=1 to length(RVASize) do
            size = RVASize[i]
            if size!=0 then
                desc = RVAdesc[i]
                k = match(" (",desc)
                if k then
                    desc = desc[1..k-1]
                end if
                start = ConvertRVAtoRaw(RelativeVirtualAddress[i])
                desc = sprintf("%s RVA (#%x..#%x)",{desc,start,start+size-1})
                v = append(v,{desc,start,size})
            end if
        end for
        for i=1 to length(PointerToRawData) do
            size = SizeOfRawData[i]
            if size!=0 then
                desc = SectionNames[i]
                start = PointerToRawData[i]
                desc = sprintf("%s (#%x..#%x)",{desc,start,start+size-1})
                v = append(v,{desc,start,size})
            end if
        end for
    end if
    text = "GraphR:"&sprint(v)
--> setClipboardText(text)
    IupSetAttribute(clipboard,"TEXT",text)

--DEV make this a builtin: (get_interpreter()? - see also demo\edix\src\ext.e)
    sequence cl = command_line()
    string crun = cl[1]
    for i=length(crun) to 0 by -1 do
        if crun[i]='\\' then
            sequence cpaths = split_path(crun[1..i-1])
--          cpaths = trim_trailing(cpaths,{"demo","pGUI"})
            cpaths = cpaths[1..find("demo",cpaths)-1]
            cpaths = append(cpaths,iff(platform()=WINDOWS?"pw.exe":"p"))
            crun = join_path(cpaths)
--?crun
--          crun = crun[1..i]&"pw.exe"
            exit
        end if
    end for
    if find(' ',crun) then
        crun = '\"' & crun & '\"'
    end if
--  sysproc(crun&" GraphR.exw")
    {} = system_exec(crun&" GraphR.exw",8)
end procedure

string filetype = ""

Ihandle file_open
Ihandle file_print
Ihandle file_copy
Ihandle file_graph
Ihandle file_exit

function graph_cb(Ihandle /*file_graph*/)
--?"graph_cb"
--  print_file()
    if filetype="PE executable" then
        GraphR()
    elsif filetype="ELF executable" then
        GraphR(1)
    else
        IupMessage("error","F9 only works on PE/ELF files")
    end if
    return IUP_DEFAULT
end function
constant cb_graph = Icallback("graph_cb")

function file_menu_open_cb(Ihandle /*ih*/)
    IupSetInt(file_graph,"ACTIVE",find(filetype,{"PE executable","ELF executable"})!=0)
    return IUP_DEFAULT
end function

function get_number(integer offset, integer dsize)
-- reassemble dsize bytes at offset
-- Note that offset as passed is 0-based, adjusted here(+1).
-- dsize is 2/4/8
atom res
    res = binary[offset+1]
    for i=2 to dsize do
        res += binary[offset+i]*mul[i]
    end for
    return res
end function

function firstatom(sequence sets)
sequence si
object sij
    for i=1 to length(sets) do
        si = sets[i]
        for j=1 to length(si) do
            sij = si[j]
            if atom(sij) then
                if sij=0 then ?9/0 end if
                return sij
            end if
        end for
    end for
    return 0
end function

procedure dump_import_table()
-- (for pemit.e; this is now only called when F3 is keyed)
integer e_lfanew
integer machine
atom ImageBase
integer nSections
integer address
integer NumberOfRvaAndSizes
integer RelativeVirtualAddress2
integer RVASize2
integer SH_VirtualSize
integer SH_VirtualAddr
integer PointerToRawData
integer ImportBase
atom ThunkBase
sequence Names
sequence HintNames
integer Name
integer FirstThunk
atom thunkaddr
sequence thunkaddrs
sequence thunknames
integer k
string text
atom RVA
integer signed

    e_lfanew = get_number(#3C,4)
    if get_number(e_lfanew,4)!=#00004550 then ?9/0 end if
    machine = get_number(e_lfanew+4,2)
    if machine=0x014C then
        machine = 32
        ImageBase = get_number(e_lfanew+#34,4)
        NumberOfRvaAndSizes = #74 -- (offset)
    elsif machine=0x8664 then
        machine = 64
        ImageBase = get_number(e_lfanew+#30,8)
        NumberOfRvaAndSizes = #84 -- (offset)
    else
        ?9/0 -- return fatal("unknown architecture")
    end if
    nSections = get_number(e_lfanew+6,2)
    address = e_lfanew+NumberOfRvaAndSizes
    NumberOfRvaAndSizes = get_number(address,4)
    if NumberOfRvaAndSizes<2 then ?9/0 end if
    RelativeVirtualAddress2 = get_number(address+12,4)
    RVASize2 = get_number(address+16,4)
    address += NumberOfRvaAndSizes*8+4

    for i=1 to nSections do
        SH_VirtualSize = get_number(address+8,4)
        SH_VirtualAddr = get_number(address+12,4)
        if RelativeVirtualAddress2>=SH_VirtualAddr
        and RelativeVirtualAddress2+RVASize2<=SH_VirtualAddr+SH_VirtualSize then
            PointerToRawData = get_number(address+20,4)
            exit
        end if
        address += 40
    end for

    address = PointerToRawData+RelativeVirtualAddress2-SH_VirtualAddr
    ImportBase = address-RelativeVirtualAddress2
    ThunkBase = ImageBase-ImportBase

    --
    -- Collect any pointers we find, and (hopefully) get through them all later.
    --
    Names = {}
    HintNames = {}

    -- An array of IMAGE_IMPORT_DESCRIPTOR (ends with an an all null one)
    while 1 do
        Name = get_number(address+12,4)
        FirstThunk = get_number(address+16,4)
        address += 20   -- sizeofstruct(IMAGE_IMPORT_DESCRIPTOR)
        if Name=0 and FirstThunk=0 then exit end if
        Names = append(Names,Name+ImportBase)
        HintNames = append(HintNames,FirstThunk+ImportBase)
    end while

    --
    -- The IMAGE_IMPORT_DESCRIPTOR above contain pointers (RVAs), so 
    -- presumably the rest of this section can be written in any order. 
    -- Try to do things in file address order.
    --
    while 1 do
        k = find(address,Names)
        if k!=0 then
            text = get_string(address)
            Names[k] = lower(text)
            address += length(text)+1
        else
            k = find(address,HintNames)
            if k=0 then
                -- I would prefer to do it in file order, but if  
                --  things have been written out higgledy-piggledy...
                address = firstatom({Names,HintNames})
                if address=0 then exit end if
            else
                -- An array of IMAGE_THUNK_DATA32/64 (see decode_import_section())
                -- one d/qword RVA per line, until we hit a null...
                thunkaddrs = {}
                thunknames = {}
                while 1 do
                    signed = 0
                    thunkaddr = address+ThunkBase
                    if machine=32 then
                        RVA = get_number(address,4)
                        if and_bits(RVA,#80000000) then
                            signed = 1
                        end if
                        address += 4
                    else
                        RVA = get_number(address+7,1)
                        if and_bits(RVA,#80) then
                            signed = 1
                        else
                            RVA = get_number(address,8)
                        end if
                        address += 8
                    end if
                    if RVA=0 then exit end if
                    if not signed then
                        thunkaddrs = append(thunkaddrs,thunkaddr)
                        thunknames = append(thunknames,get_string(RVA+ImportBase+2))
                    end if
                end while
                HintNames[k] = {thunkaddrs,thunknames}
            end if
        end if
    end while
    clear_screen() -- (decreases confusion a bit when opening 2nd or subsequent file)
    for i=1 to length(Names) do
        printf(1,"%s:\n",Names[i])
        thunkaddrs = HintNames[i][1]
        thunknames = HintNames[i][2]
        for j=1 to length(thunkaddrs) do
            printf(1,"Thunk[%08x] :%s\n",{thunkaddrs[j],thunknames[j]})
        end for
    end for
-- kept (were interspersed with the code above) just in case:
--  printf(1,"e_lfanew = %08x\n",e_lfanew)
--  printf(1,"NumberOfRvaAndSizes = %d\n",NumberOfRvaAndSizes)
--  printf(1,"RelativeVirtualAddress2 = %08x\n",RelativeVirtualAddress2)
--  printf(1,"RVASize2 = %08x\n",RVASize2)
--  printf(1,"i (to nSections) = %d\n",i)
--  printf(1,"address = %08x\n",address)
--  printf(1,"SH_VirtualSize = %08x\n",SH_VirtualSize)
--  printf(1,"SH_VirtualAddr = %08x\n",SH_VirtualAddr)
--  printf(1,"PointerToRawData = %08x\n",PointerToRawData)
--printf(1,"%08x:%s\n",{address,text})
end procedure


integer string_table

sequence p_types
sequence p_offsets
sequence p_vaddrs
sequence p_seetab
--sequence p_paddrs
sequence p_fileszs
--sequence p_memszs
sequence p_flagss
--sequence p_aligns

constant PT_NULL = 0,       -- Unused segment
         PT_LOAD = 1,       -- Loadable program segment
         PT_DYNAMIC = 2,    -- Dynamic linking information
         PT_INTERP = 3,     -- Program Interpreter pathname
         PT_NOTE = 4,       -- Auxiliary information
         PT_SHLIB = 5,      -- Reserved
         PT_PHDR = 6,       -- The program header table itself
         PT_TLS = 7,        -- The thread-local storage template
         PT_GNU_EH_FRAME    = 0x6474E550,
         PT_GNU_STACK       = 0x6474E551, -- Indicates stack executability.
         PT_GNU_RELRO       = 0x6474E552, -- Read-only after relocation.
         PT_ARM_UNK         = 0x70000001, -- ???/DEV
         {PT_TYPES,PT_TDESC} = columnize({{PT_NULL,"PT_NULL"},
                                          {PT_LOAD,"PT_LOAD"},
                                          {PT_DYNAMIC,"PT_DYNAMIC"},
                                          {PT_INTERP,"PT_INTERP"},
                                          {PT_NOTE,"PT_NOTE"},
                                          {PT_SHLIB,"PT_SHLIB"},
                                          {PT_PHDR,"PT_PHDR"},
                                          {PT_TLS,"PT_TLS"},
                                          {PT_GNU_EH_FRAME,"PT_GNU_EH_FRAME"},
                                          {PT_GNU_STACK,"PT_GNU_STACK"},
                                          {PT_GNU_RELRO,"PT_GNU_RELRO"},
                                          {PT_ARM_UNK,"PT_ARM_UNK"}})

--#define PT_LOOS       0x60000000      /* Start of OS-specific */
--#define PT_HIOS       0x6fffffff      /* End of OS-specific */
--#define PT_LOPROC     0x70000000      /* Start of processor-specific */
--#define PT_HIPROC     0x7fffffff      /* End of processor-specific */
--
--// Segment types.
--enum {
--  PT_LOOS    = 0x60000000, // Lowest operating system-specific pt entry type.
--  PT_HIOS    = 0x6fffffff, // Highest operating system-specific pt entry type.
--  PT_LOPROC  = 0x70000000, // Lowest processor-specific program hdr entry type.
--  PT_HIPROC  = 0x7fffffff, // Highest processor-specific program hdr entry type.
--
--  // x86-64 program header types.
--  // These all contain stack unwind tables.
--  PT_SUNW_UNWIND   = 0x6464E550,
--
--
--  // ARM program header types.
--  PT_ARM_ARCHEXT = 0x70000000, // Platform architecture compatibility info
--  // These all contain stack unwind tables.
--  PT_ARM_EXIDX   = 0x70000001,
--  PT_ARM_UNWIND  = 0x70000001
--};


integer phtab
integer pstab
integer dyntab
sequence sCodeSegments
sequence sDataSegments

sequence shdescs,
         shtypes,
         shflags,
         shaddrs,
         shoffsets,
         shseetabs,
         shsizes,
         shlinks,
         shinfos,
         shaddraligns,
         shentsizes

--function decode_ELF_program_headers(integer e_phnum, integer e_phentsize)
function decode_ELF_program_headers(integer e_phnum) -- e_shoff, e_shnum
atom p_type
string desc
integer p_offset
--integer p_vaddr
atom p_vaddr
--integer p_paddr
atom p_paddr
integer p_filesz
integer p_memsz
integer p_flags
integer p_align
integer vdx
integer size
integer k

    SetTabIdx("Program Headers")
    phtab = tabidx
    elfv = append(elfv,{"Program Headers",address,0})
    p_types = {}
    p_offsets = {}
    p_vaddrs = {}
    p_seetab = {}
--  p_paddrs = {}
    p_fileszs = {}
--  p_memszs = {}
    p_flagss = {}
--  p_aligns = {}
    sCodeSegments = {}
    sDataSegments = {}

    for i=1 to e_phnum do
        p_type = decode("p_type",4,"")
--/*
        if    p_type=PT_NULL then           desc = "null"
        elsif p_type=PT_LOAD then           desc = "loadable"
        elsif p_type=PT_DYNAMIC then        desc = "dynamic linking information"
        elsif p_type=PT_INTERP then         desc = "interpreter"
        elsif p_type=PT_NOTE then           desc = "note"
        elsif p_type=PT_SHLIB then          desc = "shlib"
        elsif p_type=PT_PHDR then           desc = "program header table"
        elsif p_type=PT_TLS then            desc = "tls"
--      elsif p_type=8 then                 desc = "num" -- ??
        elsif p_type=PT_GNU_EH_FRAME then   desc = "gnu eh frame (0x6474E550)"  -- 1685382480
        elsif p_type=PT_GNU_STACK then      desc = "gnu stack (0x6474E551)"     -- 1685382481
        elsif p_type=PT_GNU_RELRO then      desc = "gnu relro (0x6474E552)"     -- 1685382482
--      elsif p_type=0x65041580 then        desc = "pax flags (0x65041580)"     -- 1694766464
1879048193
#70000001
        else return fatal("unsupported type")
--          desc = sprintf("*** unsupported type [0x%08x]***",p_type)
        end if
--*/
        k = find(p_type,PT_TYPES)
        if k=0 then return fatal("unsupported type") end if
        desc = PT_TDESC[k]
        if not find(p_type,{PT_LOAD,PT_DYNAMIC,PT_INTERP,PT_PHDR}) then
            -- (add more types as Phix needs/uses them)
            NotPhix("wrong segment type ("&desc&")")
        end if
        res[tabidx][$][R_NOTES] = desc
        if machine=32 then
            p_offset = decode("p_offset","h4","file offset")
            p_vaddr = decode("p_vaddr","h4","virtual address")
            vdx = length(res[tabidx])
            p_paddr = decode("p_paddr","h4","physical addressing(ignored)")
            p_filesz = decode("p_filesz","h4","bytes in file image")
            p_memsz = decode("p_memsz","h4","bytes in memory image")
            p_flags = decode("p_flags","h4","")
            res[tabidx][$][R_NOTES] = decode_flags(ELFpflagSet,p_flags)
            p_align = decode("p_align","h4","")
        elsif machine=64 then
            p_flags = decode("p_flags","h4","")
            res[tabidx][$][R_NOTES] = decode_flags(ELFpflagSet,p_flags)
            p_offset = decode("p_offset","h8","file offset")
            p_vaddr = decode("p_vaddr","h8","virtual address")
            vdx = length(res[tabidx])
            p_paddr = decode("p_paddr","h8","physical addressing(ignored)")
            p_filesz = decode("p_filesz","h8","bytes in file image")
            p_memsz = decode("p_memsz","h8","bytes in memory image")
            p_align = decode("p_align","h8","")
        else
            ?9/0
        end if
        -- Check p_align: 0 and 1 mean "no alignment", otherwise it should be
        --  a power of 2, and a max of 512K sounds like more than enough.
        --  Also, p_offset and p_vaddr must be congruent modulo p_align.
        if not find(p_align,{0x0,0x01,0x000002,0x000004,0x000008,
                             0x000010,0x000020,0x000040,0x000080,
                             0x000100,0x000200,0x000400,0x000800,
                             0x001000,0x002000,0x004000,0x008000,
                             0x010000,0x020000,0x040000,0x080000,
                             0x100000,0x200000,0x400000,0x800000})
        or (p_align>1 and remainder(p_offset,p_align)!=remainder(p_vaddr,p_align)) then
            return fatal("bad align")
        end if
        p_types = append(p_types,p_type)
        p_offsets = append(p_offsets,p_offset)
        p_vaddrs = append(p_vaddrs,p_vaddr)
        p_seetab = append(p_seetab,vdx)
--      p_paddrs = append(p_paddrs,p_paddr)
        p_fileszs = append(p_fileszs,p_filesz)
--      p_memszs = append(p_memszs,p_memsz)
        p_flagss = append(p_flagss,p_flags)
--      p_aligns = append(p_aligns,p_align)
--1/12/14:
        if p_type=PT_LOAD then
--      if p_type=PT_LOAD and (e_shoff=0 or e_shnum=0) then
            if p_flags=PF_R+PF_X
            or p_flags=PF_R+PF_W+PF_X then  -- for fdbg
                sCodeSegments = append(sCodeSegments,i)
--?sCodeSegments
--          elsif p_flagss[i]=PF_R+PF_W then
            elsif p_flags=PF_R+PF_W then
                sDataSegments = append(sDataSegments,i)
else
    ?{p_flags,"???"}
            end if
        elsif p_type=PT_PHDR then
            res[tabidx][vdx-1][R_NOTES] = "file offset (this tab)"
        end if
        addsep()
    end for
    size = smallest(p_offsets&file_size)-address
--DEV broken on ARM,robotfindskitten,libmain.so,libmain64.so
--  if size!=0 then
-- still broken on dyn64.bin:
--DEV: (needed for skeleton.bin)
--  if size!=0 and length(NotPhixMessages)=0 then
    if size>0 and length(NotPhixMessages)=0 then
        binary_dump(size,"padding")
    end if
    elfv[$][$] = address
    return 1
end function

procedure set_seetab(string desc, integer idx)
integer vdx
    vdx = p_seetab[idx]
    desc = sprintf("virtual address (see \"%s\" tab)",desc)
    res[phtab][vdx][R_NOTES] = desc
end procedure

procedure set_seetab2(string desc, integer idx, integer pstab)
-- (Phix programs don't have section headers, btw)
integer vdx
    vdx = shseetabs[idx]
    desc = sprintf("(see \"%s\" tab)",desc)
    res[pstab][vdx][R_NOTES] = desc
end procedure


constant DT_NULL            = 0,
         DT_NEEDED          = 1,
         DT_PLTRELSZ        = 2,
         DT_PLTGOT          = 3,
         DT_HASH            = 4,
         DT_STRTAB          = 5,
         DT_SYMTAB          = 6,
         DT_RELA            = 7,
         DT_RELASZ          = 8,
         DT_RELAENT         = 9,
         DT_STRSZ           = 10,
         DT_SYMENT          = 11,
         DT_INIT            = 12,
         DT_FINI            = 13,
         DT_SONAME          = 14,
         DT_RPATH           = 15,
         DT_SYMBOLIC        = 16,
         DT_REL             = 17,
         DT_RELSZ           = 18,
         DT_RELENT          = 19,
         DT_PLTREL          = 20,
         DT_DEBUG           = 21,
         DT_TEXTREL         = 22,
         DT_JMPREL          = 23,
         DT_BIND_NOW        = 24,
         DT_INIT_ARRAY      = 25,
         DT_FINI_ARRAY      = 26,
         DT_INIT_ARRAYSZ    = 27,
         DT_FINI_ARRAYSZ    = 28,
         DT_RUNPATH         = 29,
         DT_FLAGS           = 30,
         DT_PREINIT_ARRAY   = 32,
         DT_PREINIT_ARRAYSZ = 33,
         DT_NUM             = 34
--/*
         DT_GNU_PRELINKED   = 0x6ffffdf5,
         DT_GNU_CONFLICTSZ  = 0x6ffffdf6,
         DT_GNU_LIBLISTSZ   = 0x6ffffdf7,
         DT_CHECKSUM        = 0x6ffffdf8,
         DT_PLTPADSZ        = 0x6ffffdf9,
         DT_MOVEENT         = 0x6ffffdfa,
         DT_MOVESZ          = 0x6ffffdfb,
         DT_FEATURE_1       = 0x6ffffdfc, 
         DT_POSFLAG_1       = 0x6ffffdfd,
         DT_SYMINSZ         = 0x6ffffdfe,
         DT_SYMINENT        = 0x6ffffdff,
         DT_GNU_HASH        = 0x6ffffef5,
         DT_TLSDESC_PLT     = 0x6ffffef6,
         DT_TLSDESC_GOT     = 0x6ffffef7,
         DT_GNU_CONFLICT    = 0x6ffffef8,
         DT_GNU_LIBLIST     = 0x6ffffef9,
         DT_CONFIG          = 0x6ffffefa,
         DT_DEPAUDIT        = 0x6ffffefb,
         DT_AUDIT           = 0x6ffffefc,
         DT_PLTPAD          = 0x6ffffefd,
         DT_MOVETAB         = 0x6ffffefe,
         DT_SYMINFO         = 0x6ffffeff,
         DT_VERSYM          = 0x6ffffff0,
         DT_RELACOUNT       = 0x6ffffff9,
         DT_RELCOUNT        = 0x6ffffffa,
         DT_FLAGS_1         = 0x6ffffffb,
         DT_VERDEF          = 0x6ffffffc,
         DT_VERDEFNUM       = 0x6ffffffd,
         DT_VERNEED         = 0x6ffffffe,
         DT_VERNEEDNUM      = 0x6fffffff,
         DT_AUXILIARY       = 0x7ffffffd,
         DT_FILTER          = 0x7fffffff
--*/

constant D_ignored = 0, D_val = 1, D_ptr = 2
sequence p_tags
sequence p_vals
sequence p_didx
--atom p_hash = -1
atom p_symtab = -1

function ds_normalise(atom p_addr)
atom vaddr
    for i=1 to length(p_vaddrs) do
        vaddr = p_vaddrs[i]
        if p_addr>=vaddr and p_addr<vaddr+p_fileszs[i] then
            p_addr -= (vaddr-p_offsets[i])
            return p_addr
        end if
    end for
--  return 9/0
    return 0
end function

constant STB_LOCAL  = 0,
         STB_GLOBAL = 1,
         STB_WEAK   = 2,
         STT_NOTYPE  = 0,
         STT_OBJECT  = 1,
         STT_FUNC    = 2,
         STT_SECTION = 3,
         STT_FILE    = 4

constant R_386_RELATIVE = 8
constant R_386_DESCS = {"R_386_NONE",           -- 0
                        "R_386_32",             -- 1
                        "R_386_PC32",           -- 2
                        "R_386_GOT32",          -- 3
                        "R_386_PLT32",          -- 4
                        "R_386_COPY",           -- 5
                        "R_386_GLOB_DAT",       -- 6
                        "R_386_JUMP_SLOT",      -- 7
                        "R_386_RELATIVE",       -- 8
                        "R_386_GOTOFF",         -- 9
                        "R_386_GOTPC",          -- 10
                        "R_386_32PLT",          -- 11
                        "???",              -- 12
                        "???",              -- 13
                        "R_386_TLS_TPOFF",      -- 14
                        "R_386_TLS_IE",         -- 15
                        "R_386_TLS_GOTIE",      -- 16
                        "R_386_TLS_LE",         -- 17
                        "R_386_TLS_GD",         -- 18
                        "R_386_TLS_LDM",        -- 19
                        "R_386_16",             -- 20
                        "R_386_PC16",           -- 21
                        "R_386_8",              -- 22
                        "R_386_PC8",            -- 23
                        "R_386_TLS_GD_32",      -- 24
                        "R_386_TLS_GD_PUSH",    -- 25
                        "R_386_TLS_GD_CALL",    -- 26
                        "R_386_TLS_GD_POP",     -- 27
                        "R_386_TLS_LDM_32",     -- 28
                        "R_386_TLS_LDM_PUSH",   -- 29
                        "R_386_TLS_LDM_CALL",   -- 30
                        "R_386_TLS_LDM_POP",    -- 31
                        "R_386_TLS_LDO_32",     -- 32
                        "R_386_TLS_IE_32",      -- 33
                        "R_386_TLS_LE_32",      -- 34
                        "R_386_TLS_DTPMOD32",   -- 35
                        "R_386_TLS_DTPOFF32",   -- 36
                        "R_386_TLS_TPOFF32",    -- 37
                        "R_386_TLS_GOTDESC",    -- 39
                        "R_386_TLS_DESC_CALL",  -- 40
                        "R_386_TLS_DESC",       -- 41
                        "R_386_IRELATIVE",      -- 42
                        "R_386_NUM",            -- 43
                       $}

constant R_X86_DESCS = {"R_X86_64_NONE",            -- 0,
                        "R_X86_64_64",              -- 1,
                        "R_X86_64_PC32",            -- 2,
                        "R_X86_64_GOT32",           -- 3,
                        "R_X86_64_PLT32",           -- 4,
                        "R_X86_64_COPY",            -- 5,
                        "R_X86_64_GLOB_DAT",        -- 6,
                        "R_X86_64_JUMP_SLOT",       -- 7,
                        "R_X86_64_RELATIVE",        -- 8,   -- == R_386_RELATIVE
                        "R_X86_64_GOTPCREL",        -- 9,
                        "R_X86_64_32",              -- 10,
                        "R_X86_64_32S",             -- 11,
                        "R_X86_64_16",              -- 12,
                        "R_X86_64_PC16",            -- 13,
                        "R_X86_64_8",               -- 14,
                        "R_X86_64_PC8",             -- 15,
                        "R_X86_64_DTPMOD64",        -- 16,
                        "R_X86_64_DTPOFF64",        -- 17,
                        "R_X86_64_TPOFF64",         -- 18,
                        "R_X86_64_TLSGD",           -- 19,
                        "R_X86_64_TLSLD",           -- 20,
                        "R_X86_64_DTPOFF32",        -- 21,
                        "R_X86_64_GOTTPOFF",        -- 22,
                        "R_X86_64_TPOFF32",         -- 23,
                        "R_X86_64_PC64",            -- 24,
                        "R_X86_64_GOTOFF64",        -- 25,
                        "R_X86_64_GOTPC32",         -- 26,
                        "R_X86_64_GOT64",           -- 27,
                        "R_X86_64_GOTPCREL64",      -- 28,
                        "R_X86_64_GOTPC64",         -- 29,
                        "R_X86_64_GOTPLT64",        -- 30,
                        "R_X86_64_PLTOFF64",        -- 31,
                        "R_X86_64_SIZE32",          -- 32,
                        "R_X86_64_SIZE64",          -- 33,
                        "R_X86_64_GOTPC32_TLSDESC", -- 34,
                        "R_X86_64_TLSDESC_CALL",    -- 35,
                        "R_X86_64_TLSDESC",         -- 36,
                        "R_X86_64_IRELATIVE",       -- 37
                        $}

constant DUPE = "duplicate DT entry"


function decode_ELF_dynamic_segment(integer idx)
integer size = p_fileszs[idx]
string desc
atom d_tag
integer nidx
integer p_hash
integer d_un
atom d_val

atom p_strtab = -1
integer strsize = 0
atom p_rel = -1
atom p_rela = -1
integer n_hash
atom n_strtab
--atom n_symtab
--atom n_rel

--integer syment = -1
integer relsz = -1
integer relasz = -1
integer relent = -1
integer relaent = -1

--DEV temp
--integer nBucket
atom nBucket
integer nChain
--DEV
--integer st_name
atom st_name
sequence st_names
atom st_value
integer st_size
integer st_info
integer st_info_idx
integer binding
integer st_type
integer global_found
integer st_other
integer st_shndx

atom r_offset
object r_info
atom r_symidx
atom r_type
atom r_addend
string name
integer n

sequence todo
integer dsidx
object sy_size = {}
sequence string_addrs
sequence reloc_addrs
atom reloc_base

    desc = "Dynamic Link Info"
    SetTabIdx(desc)
    dyntab = tabidx
    set_seetab(desc,idx)
    n = find(0x6,shtypes)
    if n!=0 then
        -- (Phix programs don't have section headers, btw)
        set_seetab2(desc,n,pstab)
    end if
    p_tags = {}
    p_vals = {}
    p_didx = {}
    p_hash = -1
    p_symtab = -1
    addr = p_vaddrs[idx]
    address = p_offsets[idx]
    elfv = append(elfv,{desc,address,0})
    while size>0 do
        if machine=32 then
            d_tag = decode("d_tag","h4","")
        elsif machine=64 then
            d_tag = decode("d_tag","h8","")
        else
            ?9/0
        end if
        p_tags = append(p_tags,d_tag)
        nidx = length(p_tags)
        if    d_tag=DT_NULL             then    desc = "DT_NULL"            d_un = D_ignored
        elsif d_tag=DT_NEEDED           then    desc = "DT_NEEDED"          d_un = D_val        -- get_string, once we have the DT_STRTAB entry...
        elsif d_tag=DT_PLTRELSZ         then    desc = "DT_PLTRELSZ"        d_un = D_val
        elsif d_tag=DT_PLTGOT           then    desc = "DT_PLTGOT"          d_un = D_ptr
        elsif d_tag=DT_HASH             then    desc = "DT_HASH"            d_un = D_ptr        if p_hash!=-1 then return fatal(DUPE) end if    p_hash   = nidx
        elsif d_tag=DT_STRTAB           then    desc = "DT_STRTAB"          d_un = D_ptr        if p_strtab!=-1 then return fatal(DUPE) end if  p_strtab = nidx
        elsif d_tag=DT_SYMTAB           then    desc = "DT_SYMTAB"          d_un = D_ptr        if p_symtab!=-1 then return fatal(DUPE) end if  p_symtab = nidx
        elsif d_tag=DT_RELA             then    desc = "DT_RELA"            d_un = D_ptr        if p_rela!=-1 then return fatal(DUPE) end if    p_rela   = nidx
        elsif d_tag=DT_RELASZ           then    desc = "DT_RELASZ"          d_un = D_val        if relasz!=-1 then return fatal(DUPE) end if    relasz   = nidx
        elsif d_tag=DT_RELAENT          then    desc = "DT_RELAENT"         d_un = D_val        if relaent!=-1 then return fatal(DUPE) end if   relaent  = nidx
        elsif d_tag=DT_STRSZ            then    desc = "DT_STRSZ"           d_un = D_val        if p_strtab==-1 then return fatal(DUPE) end if  strsize  = nidx
        elsif d_tag=DT_SYMENT           then    desc = "DT_SYMENT"          d_un = D_val
        elsif d_tag=DT_INIT             then    desc = "DT_INIT"            d_un = D_ptr
        elsif d_tag=DT_FINI             then    desc = "DT_FINI"            d_un = D_ptr
        elsif d_tag=DT_SONAME           then    desc = "DT_SONAME"          d_un = D_val
        elsif d_tag=DT_RPATH            then    desc = "DT_RPATH"           d_un = D_val
        elsif d_tag=DT_SYMBOLIC         then    desc = "DT_SYMBOLIC"        d_un = D_ignored
        elsif d_tag=DT_REL              then    desc = "DT_REL"             d_un = D_ptr        if p_rel!=-1 then return fatal(DUPE) end if p_rel    = nidx
        elsif d_tag=DT_RELSZ            then    desc = "DT_RELSZ"           d_un = D_val        if relsz!=-1 then return fatal(DUPE) end if relsz    = nidx
        elsif d_tag=DT_RELENT           then    desc = "DT_RELENT"          d_un = D_val        if relent!=-1 then return fatal(DUPE) end if    relent   = nidx
        elsif d_tag=DT_PLTREL           then    desc = "DT_PLTREL"          d_un = D_val
        elsif d_tag=DT_DEBUG            then    desc = "DT_DEBUG"           d_un = D_ptr
        elsif d_tag=DT_TEXTREL          then    desc = "DT_TEXTREL"         d_un = D_ignored
        elsif d_tag=DT_JMPREL           then    desc = "DT_JMPREL"          d_un = D_ptr
        elsif d_tag=DT_BIND_NOW         then    desc = "DT_BIND_NOW"        d_un = D_ignored
        elsif d_tag=DT_INIT_ARRAY       then    desc = "DT_INIT_ARRAY"      d_un = D_ignored
        elsif d_tag=DT_FINI_ARRAY       then    desc = "DT_FINI_ARRAY"      d_un = D_ignored
        elsif d_tag=DT_INIT_ARRAYSZ     then    desc = "DT_INIT_ARRAYSZ"    d_un = D_ignored
        elsif d_tag=DT_FINI_ARRAYSZ     then    desc = "DT_FINI_ARRAYSZ"    d_un = D_ignored
        elsif d_tag=DT_RUNPATH          then    desc = "DT_RUNPATH"         d_un = D_ignored
        elsif d_tag=DT_FLAGS            then    desc = "DT_FLAGS"           d_un = D_ignored
        elsif d_tag=DT_PREINIT_ARRAY    then    desc = "DT_PREINIT_ARRAY"   d_un = D_ignored
        elsif d_tag=DT_PREINIT_ARRAYSZ  then    desc = "DT_PREINIT_ARRAYSZ" d_un = D_ignored
        elsif d_tag=DT_NUM              then    desc = "DT_NUM"             d_un = D_ignored
        else                                    desc = "?"                  d_un = D_ignored
        end if
        res[tabidx][$][R_NOTES] = desc
        if machine=32 then
            if d_un=D_ignored then
                d_val = decode("-","h4","")
            elsif d_un=D_val then
                d_val = decode("d_val",4,"")
            elsif d_un=D_ptr then
                d_val = decode("d_ptr","h4","")
            end if
            size -= 8
            addr += 8
        elsif machine=64 then
            if d_un=D_ignored then
                d_val = decode("-","h8","")
            elsif d_un=D_val then
                d_val = decode("d_val",8,"")
            elsif d_un=D_ptr then
                d_val = decode("d_ptr","h8","")
            end if
            size -= 16
            addr += 16
        else
            ?9/0
        end if
--DEV check these will actually exist? Or use p_didx?
        if d_tag=DT_HASH then
--          res[tabidx][$][R_NOTES] = "(See \"Hash\" tab)"
            res[tabidx][$][R_NOTES] = "(See \"Symtab\" tab, Hash)"
            n = find(0x5,shtypes)
            if n!=0 then
                -- (Phix programs don't have section headers, btw)
                set_seetab2("Hash",n,pstab)
            end if
        elsif d_tag=DT_SYMTAB then
            res[tabidx][$][R_NOTES] = "(See \"Symtab\" tab)"
            n = find(0xB,shtypes)
            if n!=0 then
                -- (Phix programs don't have section headers, btw)
                set_seetab2("Symtab",n,pstab)
            end if
        elsif d_tag=DT_STRTAB then
            res[tabidx][$][R_NOTES] = "(See \"Symtab\" tab, Strings)"
        elsif d_tag=DT_RELA then
            res[tabidx][$][R_NOTES] = "(See \"Symtab\" tab, Relocationas)"
        elsif d_tag=DT_REL then
            res[tabidx][$][R_NOTES] = "(See \"Symtab\" tab, Relocations)"
        elsif d_tag=DT_STRSZ then
            n_strtab = ds_normalise(p_vals[p_strtab])
            res[tabidx][$][R_NOTES] = sprintf(" (- strings end at #%08x)",n_strtab+d_val-1)
        elsif d_tag=DT_SYMENT then
            res[tabidx][$][R_NOTES] = " (- size of one symtab entry)"
        elsif d_tag=DT_RELSZ then
            res[tabidx][$][R_NOTES] = " (- total DT_REL table size)"
        elsif d_tag=DT_RELENT then
            res[tabidx][$][R_NOTES] = " (- size of one DT_REL entry)"
        elsif d_tag=DT_RELASZ then
            res[tabidx][$][R_NOTES] = " (- total DT_RELA table size)"
        elsif d_tag=DT_RELAENT then
            res[tabidx][$][R_NOTES] = " (- size of one DT_RELA entry)"
        end if
        p_vals = append(p_vals,d_val)
        p_didx = append(p_didx,length(res[tabidx]))
--#without reformat
--      if    d_tag=DT_HASH     then    
--      elsif d_tag=DT_SYMENT   then    if syment  !=-1 then ?9/0 end if    syment   = d_val
--      end if
--#with reformat
    end while

    if p_strtab!=-1 then
--      p_strtab = p_vals[p_strtab]
--      n_strtab = ds_normalise(p_strtab)
        n_strtab = ds_normalise(p_vals[p_strtab])
        string_addrs = {n_strtab}
    end if

    for i=1 to length(p_tags) do
        d_tag = p_tags[i]
        if d_tag=DT_NEEDED
        or d_tag=DT_SONAME
        or d_tag=DT_RPATH   then
            d_val = p_vals[i]
            desc = get_string(n_strtab+d_val)
            res[tabidx][p_didx[i]][R_NOTES] = desc
            string_addrs = append(string_addrs,n_strtab+d_val)
        end if
    end for
    if size then
        binary_dump(size,"%08x")
        -- error!
    end if
    elfv[$][$] = address

    --DEV[1] build a desc for a set_seetab("Symtab, Relocations, Hash, Strings",?idx)
    --DEV[1] build a desc for a set_seetab("Symtab",?idx) <= better [erm...]
    --DEV collect p_hash/p_symtab/p_strings(?)/p_rel/p_rela, sort on start...:
    --DEV if there is a p_types PT_LOAD that starts where we are, dump it all here and PT_NULL it. [DONE]
    if 01 then
    --if atom(sy_size) then
        knownAddr = {}
        knownNames = {}

        todo = {}
        if p_hash!=-1   then todo = append(todo,{p_vals[p_hash],p_hash})        end if
        if p_hash!=-1 then -- hmm...
            if p_symtab!=-1 then todo = append(todo,{p_vals[p_symtab],p_symtab})    end if
        end if
        if p_rel!=-1    then todo = append(todo,{p_vals[p_rel],p_rel})          end if
        if p_rela!=-1   then todo = append(todo,{p_vals[p_rela],p_rela})        end if
        if p_strtab!=-1 then todo = append(todo,{p_vals[p_strtab],p_strtab})    end if
        if length(todo) then
            todo = sort(todo)
            desc = "Symtab"
            SetTabIdx(desc)
            elfv = append(elfv,{desc,address,0})
            reloc_addrs = {}
--      reloc_base = address
            reloc_base = 0
--DEV while
            for i=1 to length(todo) do
                nidx = todo[i][2]
--DEV padding
                address = ds_normalise(todo[i][1])
                if i=1 then
                    for j=1 to length(p_types) do
                        if p_types[j]=PT_LOAD and p_offsets[j]=address then
                            dsidx = find(j,sDataSegments)
                            if dsidx=0 then ?9/0 end if
                            sDataSegments[dsidx..dsidx] = {}
                            sy_size = p_fileszs[j]
                            elfv[$][$] = address+sy_size
                            p_types[j] = PT_NULL
                            set_seetab("Symtab", j)
                            reloc_base = p_vaddrs[j]-p_offsets[j]
                            exit
                        end if
                    end for
                end if
                if nidx=p_hash then
--              n_hash = p_vals[p_hash]
--              address = ds_normalise(n_hash)
--              elfv = append(elfv,{"Hash",address,0})
--              desc = sprintf("hash_table([#%08x])",n_hash)
                    if i>1 then
                        addsep()
                    end if
                    addsymtabsep("--Hash--")
                    desc = sprintf("DT_HASH [#%08x]",p_vals[p_hash])
                    nBucket = decode("nbucket",4,desc)
                    nChain = decode("nchain",4,"(also defines DT_SYMTAB size)")
                    -- (1/12/14) note that all bucket and chain indexes are 0-based.
                    for b=1 to nBucket do
                        {} = decode(sprintf("bucket[%d]",b-1),4,"")
                    end for
                    for c=1 to nChain do
                        {} = decode(sprintf("chain[%d]",c-1),4,"")
                    end for
                    if atom(sy_size) then
                        sy_size -= (nBucket+nChain+2)*4
                    end if
                elsif nidx=p_symtab then
--              p_symtab = p_vals[p_symtab]
--              address = ds_normalise(p_symtab)
--          elfv = append(elfv,{"Symtab",p_symtab,address})
--          elfv = append(elfv,{"Symtab",address,0})
                    if i>1 then
                        addsep()
                    end if
                    addsymtabsep("--Symtab--")
----/*
--typedef struct
--{
--  UINT32  st_name;                /* Symbol name (string tbl index) */
--  UINT32  st_value;               /* Symbol value */
--  UINT32  st_size;                /* Symbol size */
--  unsigned char st_info;          /* Symbol type and binding */
--  unsigned char st_other;         /* No defined meaning, 0 */
--  UINT16 st_shndx;                    /* Section index */
--} Elf32_Sym;
--
--typedef struct
--{
--  UINT32  st_name;                /* Symbol name (string tbl index) */
--  unsigned char st_info;          /* Symbol type and binding */
--  unsigned char st_other;         /* No defined meaning, 0 */
--  UINT16 st_shndx;                    /* Section index */
--  UINT64  st_value;               /* Symbol value */
--  UINT64  st_size;                /* Symbol size */
--} Elf64_Sym;
----*/
                    global_found = 0
                    st_names = {}
                    if p_hash=-1 then ?9/0 end if
                    nChain = get_integer(ds_normalise(p_vals[p_hash])+4)
--              if nChain!=get_integer(ds_normalise(p_vals[p_hash])+4) then ?9/0 end if
                    for c=1 to nChain do
                        if c>1 then
                            addsep()
                        end if
                        st_name = decode(sprintf("st_name[%d]",c-1),"h4","")
                        if atom(sy_size) then
                            sy_size -= 4
                        end if
                        if c=1 then
                            -- (first entry should be all null)
                            if st_name!=0 then return fatal("first entry should be NULL") end if
--                      desc = sprintf("symbol_table([#%08x])",p_symtab)
--                      desc = sprintf("symbol_table([#%08x])",p_vals[p_symtab])
                            desc = sprintf("DT_SYMTAB [#%08x]",p_vals[p_symtab])
                        else
                            string_addrs = append(string_addrs,n_strtab+st_name)
                            desc = get_string(n_strtab+st_name)
                        end if
                        res[tabidx][$][R_NOTES] = desc
                        st_names = append(st_names,desc)
                        if machine=32 then
                            st_value = decode("st_value","h4","")
                            st_size = decode("st_size",4,"")
                            st_info = decode("st_info","h1","")
                            st_info_idx = length(res[tabidx])
                            st_other = decode("st_other","h1","(should be 0)")
                            st_shndx = decode("st_shndx","h2","")
                            if atom(sy_size) then
                                sy_size -= 12
                            end if
                        elsif machine=64 then
                            st_info = decode("st_info","h1","")
                            st_info_idx = length(res[tabidx])
                            st_other = decode("st_other","h1","(should be 0)")
                            st_shndx = decode("st_shndx","h2","")
                            st_value = decode("st_value","h8","")
                            st_size = decode("st_size",8,"")
                            if atom(sy_size) then
                                sy_size -= 20
                            end if
                        else
                            ?9/0
                        end if
                        if c>1 or st_info!=0 then
                            binding = floor(st_info/#10)
                            st_type = and_bits(st_info,#0F)
                            if binding=STB_LOCAL then
                                if global_found then ?9/0 end if
                                desc = "STB_LOCAL"
                            else
                                global_found = 1
                                if binding=STB_GLOBAL then
                                    desc = "STB_GLOBAL"
                                elsif binding=STB_WEAK then
                                    desc = "STB_WEAK"
                                else
                                    desc = "?"
                                end if
                            end if
                            desc &= ", "
                            if st_type=STT_NOTYPE then
                                desc &= "STT_NOTYPE"
                            elsif st_type=STT_OBJECT then
                                desc &= "STT_OBJECT"
                            elsif st_type=STT_FUNC then
                                desc &= "STT_FUNC"
                            elsif st_type=STT_SECTION then
                                desc &= "STT_SECTION"
                            elsif st_type=STT_FILE then
                                desc &= "STT_FILE"
                            else
                                desc &= "?"
                            end if
                            res[tabidx][st_info_idx][R_NOTES] = desc
                        end if
                    end for
                elsif nidx=p_rel then
----/*
--// Relocation entry, without explicit addend.
--struct Elf32_Rel {
--  UINT32 r_offset; // Location (file byte offset, or program virtual addr)
--  UINT32 r_info;   // Symbol table index and type of relocation to apply
--
--  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,
--  // and ELF32_R_INFO macros defined in the ELF specification:
--  UINT32 getSymbol() const { return (r_info >> 8); }
--  unsigned char getType() const { return (unsigned char) (r_info & 0x0ff); }
--  void setSymbol(UINT32 s) { setSymbolAndType(s, getType()); }
--  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }
--  void setSymbolAndType(UINT32 s, unsigned char t) {
--    r_info = (s << 8) + t;
--  }
--};
--
--// Relocation entry, without explicit addend.
--struct Elf64_Rel {
--  UINT64 r_offset; // Location (file byte offset, or program virtual addr).
--  UINT64 r_info;   // Symbol table index and type of relocation to apply.
--
--  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,
--  // and ELF64_R_INFO macros defined in the ELF specification:
--  UINT32 getSymbol() const { return (r_info >> 32); }
--  UINT32 getType() const {
--    return (UINT32) (r_info & 0xffffffffL);
--  }
--  void setSymbol(UINT32 s) { setSymbolAndType(s, getType()); }
--  void setType(UINT32 t) { setSymbolAndType(getSymbol(), t); }
--  void setSymbolAndType(UINT32 s, UINT32 t) {
--    r_info = ((UINT64)s << 32) + (t&0xffffffffL);
--  }
--};
--
----*/
--              p_rel = p_vals[p_rel]
--              address = ds_normalise(p_rel)
                    if relsz=-1 then ?9/0 end if
                    if relent=-1 then ?9/0 end if
                    size = p_vals[relsz]
                    if atom(sy_size) then
                        sy_size -= size
                    end if
--              elfv = append(elfv,{"Relocations",address,address+size})
        --      address = n_rel
                    if i>1 then
                        addsep()
                    end if
                    addsymtabsep("--Relocations--")
                    desc = sprintf("DT_REL [#%08x]",p_vals[p_rel])
                    while size do
                        if machine=32 then
                            r_offset = decode("relocation offset","h4",desc)
                            r_info = decode("r_info","h4","")
                            r_symidx = floor(r_info/#100)
                            r_type = and_bits(r_info,#FF)
                            desc = "??"
                            if r_type>=0 and r_type<length(R_386_DESCS) then
                                desc = R_386_DESCS[r_type+1]
                            end if
                        elsif machine=64 then
                            r_offset = decode("relocation offset","h8",desc)
                            r_info = decode("r_info","h8","")
                            r_symidx = floor(r_info/#100000000)
                            r_type = and_bits(r_info,#FFFFFFFF)
                            desc = "??"
                            if r_type>=0 and r_type<length(R_X86_DESCS) then
                                desc = R_X86_DESCS[r_type+1]
                            end if
                        else
                            ?9/0
                        end if
                        if r_type=R_386_RELATIVE then
                            if r_symidx!=0 then ?9/0 end if
                            res[tabidx][$][R_NOTES] = sprintf("%s",{desc})
                        elsif p_hash=-1 then
                            res[tabidx][$][R_NOTES] = sprintf("%s, symtab[%d]=???",{desc,r_symidx})
                        elsif r_symidx>=length(st_names) then
                            name = sprintf("*** ioob st_names[%d]=??? ***",r_symidx+1)
                            res[tabidx][$][R_NOTES] = name
                            ?name
                        else
                            name = st_names[r_symidx+1]
                            res[tabidx][$][R_NOTES] = sprintf("%s, symtab[%d]=%s",{desc,r_symidx,name})
                            -- (for p2asm:)
                            knownAddr = append(knownAddr,r_offset)
                            knownNames = append(knownNames,name)
                        end if
                        reloc_addrs = append(reloc_addrs,r_offset-reloc_base)
                        size -= p_vals[relent]
                        desc = ""
                    end while
                elsif nidx=p_rela then
----/*
--// Relocation entry with explicit addend.
--struct Elf32_Rela {
--  UINT32  r_offset; // Location (file byte offset, or program virtual addr)
--  UINT32  r_info;   // Symbol table index and type of relocation to apply
--  INT32 r_addend; // Compute value for relocatable field by adding this
--};
--
--struct Elf64_Rela {
--  UINT64  r_offset; // Location (file byte offset, or program virtual addr).
--  UINT64  r_info;   // Symbol table index and type of relocation to apply.
--  INT64 r_addend; // Compute value for relocatable field by adding this.
--};
--
----*/
--              p_rela = p_vals[p_rela]
--              address = ds_normalise(p_rela)
                    if relasz=-1 then ?9/0 end if
                    if relaent=-1 then ?9/0 end if
                    size = p_vals[relasz]
                    if atom(sy_size) then
                        sy_size -= size
                    end if
                    if i>1 then
                        addsep()
                    end if
                    addsymtabsep("--Relocationas--")
                    desc = sprintf("DT_RELA [#%08x]",p_vals[p_rela])
                    while size do
                        if machine=32 then
                            r_offset = decode("relocation offset","h4",desc)
                            r_info = decode("r_info","h4","")
                            r_symidx = floor(r_info/#100)
                            r_type = and_bits(r_info,#FF)
                            desc = "??"
                            if r_type>=0 and r_type<length(R_386_DESCS) then
                                desc = R_386_DESCS[r_type+1]
                            end if
                            r_addend = decode("r_addend","h4","")
                        elsif machine=64 then
--                      r_offset = decode("relocation offset","h8",desc)
                            r_offset = decode("r_offset","h8",desc)
                            r_info = decode("r_info","h8","")
                            if atom(r_info) then
                                r_symidx = floor(r_info/#100000000)
                                r_type = and_bits(r_info,#FFFFFFFF)
                            else
                                {r_symidx,r_type} = r_info
                            end if
                            desc = "??"
                            if r_type>=0 and r_type<length(R_X86_DESCS) then
                                desc = R_X86_DESCS[r_type+1]
                            end if
                            r_addend = decode("r_addend","h8","")
                        else
                            ?9/0
                        end if
                        if r_type=R_386_RELATIVE then
                            if r_symidx!=0 then ?9/0 end if
                            res[tabidx][$-1][R_NOTES] = sprintf("%s",{desc})
                        elsif p_hash=-1 then
                            res[tabidx][$-1][R_NOTES] = sprintf("%s, symtab[%d]=???",{desc,r_symidx})
                        else
                            name = st_names[r_symidx+1]
                            res[tabidx][$-1][R_NOTES] = sprintf("%s, symtab[%d]=%s",{desc,r_symidx,name})
                            knownAddr = append(knownAddr,r_offset)
                            knownNames = append(knownNames,name)
                        end if
                        reloc_addrs = append(reloc_addrs,r_offset-reloc_base)
                        size -= p_vals[relaent]
                        desc = ""
                    end while
                elsif nidx=p_strtab then
                    if i>1 then
                        addsep()
                    end if
                    addsymtabsep("--Strings--")
                    --DEV bug: string addresses are shown as if the string table was the first thing in the symtab tab...
                    -- (untried/perhaps: address = p_vals[p_strtab]??) [DONE]
                    string_addrs = sort(string_addrs)
--printf(1,"%08x, p[]:%08x\n",{addr,p_vals[p_strtab]})
                    addr = p_vals[p_strtab]
--22/4/16:
--              string_addrs = append(string_addrs,p_vals[p_strtab]-reloc_base+p_vals[strsize])
                    string_addrs = append(string_addrs,ds_normalise(p_vals[p_strtab])+p_vals[strsize])
                    for s=1 to length(string_addrs)-1 do
                        size = string_addrs[s+1]-string_addrs[s]
--22/4/16:
--if and_bits(size,#8000) then size -= #8000 end if
--size = and_bits(size,#7FFF)
                        if size!=0 then
--                  if size!=0 and and_bits(size,#8000)=0 then
                            binary_dump(size,"%08x")
                            if atom(sy_size) then
                                sy_size -= size
                            end if
                        end if
                    end for
                else
                    ?9/0 -- unknown nidx
                end if
            end for
            if atom(sy_size) and sy_size!=0 then
                addsep()
                reloc_addrs = sort(reloc_addrs)
                if length(reloc_addrs) and reloc_addrs[1]=address then
                    addsymtabsep("--relocs--")
                    -- note this only works when relocs are at end of symtab segment, 
                    -- (as per Phix\asm\fasm\dynelfexe\test.asm, not part of distro)
                    -- in the example on http://board.flatassembler.net/topic.php?t=10660
                    -- (first post), they need to be moved out of the data segment.
                    size = machine/8
                    for i=1 to length(reloc_addrs) do
                        if reloc_addrs[i]!=address then
                            ?{"reloc_addrs[i]!=address",reloc_addrs,i}
                            exit
                        end if
                        binary_dump(size,sprintf("reloc[%d] (#%08x)",{i,address+reloc_base}))
                        sy_size -= size
                    end for
                else
                    addsymtabsep("--??--")
                end if
                if sy_size!=0 then
                    binary_dump(sy_size,"%08x")
                end if
            end if
            elfv[$][$] = address
        end if
    else
    --DEV this should all be in separate tabs... [done]
    --  res[tabidx] = append(res[tabidx],{0,"(dup)",0,0,"(for raw data of the following see data segment(s):)"})
        if p_hash!=-1 then
--  if nidx=p_hash then
            desc = "Hash"
            SetTabIdx(desc)
--      n_hash = ds_normalise(p_hash)
            n_hash = p_vals[p_hash]
--dev (see Hash tab)
            address = ds_normalise(n_hash)
            elfv = append(elfv,{"Hash",address,0})
            desc = sprintf("hash_table([#%08x])",n_hash)
            nBucket = decode("nbucket",4,desc)
            if not integer(nBucket) then return fatal("not integer") end if
            nChain = decode("nchain",4,"")
            -- (1/12/14) note that all bucket and chain indexes are 0-based.
            for i=1 to nBucket do
                {} = decode(sprintf("bucket[%d]",i-1),4,"")
            end for
            for i=1 to nChain do
                {} = decode(sprintf("chain[%d]",i-1),4,"")
            end for
--      elfv[$][$] = address - elfv[$][$]
            elfv[$][$] = address
            if p_symtab!=-1 then
                desc = "Symtab"
                SetTabIdx(desc)
                p_symtab = p_vals[p_symtab]
--dev (see Symtab tab)
                address = ds_normalise(p_symtab)
--          elfv = append(elfv,{"Symtab",p_symtab,address})
                elfv = append(elfv,{"Symtab",address,0})

----/*
--typedef struct
--{
--  UINT32  st_name;                /* Symbol name (string tbl index) */
--  UINT32  st_value;               /* Symbol value */
--  UINT32  st_size;                /* Symbol size */
--  unsigned char st_info;          /* Symbol type and binding */
--  unsigned char st_other;         /* No defined meaning, 0 */
--  UINT16 st_shndx;                    /* Section index */
--} Elf32_Sym;
--
--typedef struct
--{
--  UINT32  st_name;                /* Symbol name (string tbl index) */
--  unsigned char st_info;          /* Symbol type and binding */
--  unsigned char st_other;         /* No defined meaning, 0 */
--  UINT16 st_shndx;                    /* Section index */
--  UINT64  st_value;               /* Symbol value */
--  UINT64  st_size;                /* Symbol size */
--} Elf64_Sym;
----*/
                global_found = 0
                st_names = {}
                if p_hash=-1 then ?9/0 end if
                --DEV nChain = get_integer(ds_normalise(p_vals[p_hash])+4)
                if nChain!=get_integer(ds_normalise(p_vals[p_hash])+4) then ?9/0 end if
                for i=1 to nChain do
                    st_name = decode(sprintf("st_name[%d]",i-1),"h4","")
                    if i=1 then
                        -- (first entry should be all null)
                        if st_name!=0 then ?9/0 end if
                        desc = sprintf("symbol_table([#%08x])",p_symtab)
                    else
                        desc = get_string(n_strtab+st_name)
                    end if
                    res[tabidx][$][R_NOTES] = desc
                    st_names = append(st_names,desc)
                    if machine=32 then
                        st_value = decode("st_value","h4","")
                        st_size = decode("st_size",4,"")
                        st_info = decode("st_info","h1","")
                        st_info_idx = length(res[tabidx])
                        st_other = decode("st_other","h1","(should be 0)")
                        st_shndx = decode("st_shndx","h2","")
                    elsif machine=64 then
                        st_info = decode("st_info","h1","")
                        st_info_idx = length(res[tabidx])
                        st_other = decode("st_other","h1","(should be 0)")
                        st_shndx = decode("st_shndx","h2","")
                        st_value = decode("st_value","h8","")
                        st_size = decode("st_size",8,"")
                    else
                        ?9/0
                    end if
                    if i>1 or st_info!=0 then
                        binding = floor(st_info/#10)
                        st_type = and_bits(st_info,#0F)
                        if binding=STB_LOCAL then
                            if global_found then ?9/0 end if
                            desc = "STB_LOCAL"
                        else
                            global_found = 1
                            if binding=STB_GLOBAL then
                                desc = "STB_GLOBAL"
                            elsif binding=STB_WEAK then
                                desc = "STB_WEAK"
                            else
                                desc = "?"
                            end if
                        end if
                        desc &= ", "
                        if st_type=STT_NOTYPE then
                            desc &= "STT_NOTYPE"
                        elsif st_type=STT_OBJECT then
                            desc &= "STT_OBJECT"
                        elsif st_type=STT_FUNC then
                            desc &= "STT_FUNC"
                        elsif st_type=STT_SECTION then
                            desc &= "STT_SECTION"
                        elsif st_type=STT_FILE then
                            desc &= "STT_FILE"
                        else
                            desc &= "?"
                        end if
                        res[tabidx][st_info_idx][R_NOTES] = desc
                    end if
                    addsep()
                end for
--          elfv[$][$] = address - elfv[$][$]
                elfv[$][$] = address
            end if
        end if
        knownAddr = {}
        knownNames = {}
        if p_rel!=-1 then
----/*
--// Relocation entry, without explicit addend.
--struct Elf32_Rel {
--  UINT32 r_offset; // Location (file byte offset, or program virtual addr)
--  UINT32 r_info;   // Symbol table index and type of relocation to apply
--
--  // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,
--  // and ELF32_R_INFO macros defined in the ELF specification:
--  UINT32 getSymbol() const { return (r_info >> 8); }
--  unsigned char getType() const { return (unsigned char) (r_info & 0x0ff); }
--  void setSymbol(UINT32 s) { setSymbolAndType(s, getType()); }
--  void setType(unsigned char t) { setSymbolAndType(getSymbol(), t); }
--  void setSymbolAndType(UINT32 s, unsigned char t) {
--    r_info = (s << 8) + t;
--  }
--};
--
--// Relocation entry, without explicit addend.
--struct Elf64_Rel {
--  UINT64 r_offset; // Location (file byte offset, or program virtual addr).
--  UINT64 r_info;   // Symbol table index and type of relocation to apply.
--
--  // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,
--  // and ELF64_R_INFO macros defined in the ELF specification:
--  UINT32 getSymbol() const { return (r_info >> 32); }
--  UINT32 getType() const {
--    return (UINT32) (r_info & 0xffffffffL);
--  }
--  void setSymbol(UINT32 s) { setSymbolAndType(s, getType()); }
--  void setType(UINT32 t) { setSymbolAndType(getSymbol(), t); }
--  void setSymbolAndType(UINT32 s, UINT32 t) {
--    r_info = ((UINT64)s << 32) + (t&0xffffffffL);
--  }
--};
--
----*/
            desc = "Relocations"
            SetTabIdx(desc)
            p_rel = p_vals[p_rel]
            address = ds_normalise(p_rel)
--      elfv = append(elfv,{"Relocations",p_rel,address})
            if relsz=-1 then ?9/0 end if
            if relent=-1 then ?9/0 end if
            size = p_vals[relsz]
            elfv = append(elfv,{"Relocations",address,address+size})
--      address = n_rel
            while size do
                desc = "??"
                if machine=32 then
                    r_offset = decode("relocation offset","h4","")
                    r_info = decode("r_info","h4","")
                    r_symidx = floor(r_info/#100)
                    r_type = and_bits(r_info,#FF)
                    if r_type>=0 and r_type<length(R_386_DESCS) then
                        desc = R_386_DESCS[r_type+1]
                    end if
                elsif machine=64 then
                    r_offset = decode("relocation offset","h8","")
                    r_info = decode("r_info","h8","")
                    r_symidx = floor(r_info/#100000000)
                    r_type = and_bits(r_info,#FFFFFFFF)
                    if r_type>=0 and r_type<length(R_X86_DESCS) then
                        desc = R_X86_DESCS[r_type+1]
                    end if
                else
                    ?9/0
                end if
                if r_type=R_386_RELATIVE then
                    if r_symidx!=0 then ?9/0 end if
                    res[tabidx][$][R_NOTES] = sprintf("%s",{desc})
                elsif p_hash=-1 then
                    res[tabidx][$][R_NOTES] = sprintf("%s, symtab[%d]=???",{desc,r_symidx})
                else
                    name = st_names[r_symidx+1]
                    res[tabidx][$][R_NOTES] = sprintf("%s, symtab[%d]=%s",{desc,r_symidx,name})
                    -- (for p2asm:)
                    knownAddr = append(knownAddr,r_offset)
                    knownNames = append(knownNames,name)
                end if
                size -= p_vals[relent]
            end while
--      elfv[$][$] = address - elfv[$][$]
        end if

        if p_rela!=-1 then
----/*
--// Relocation entry with explicit addend.
--struct Elf32_Rela {
--  UINT32  r_offset; // Location (file byte offset, or program virtual addr)
--  UINT32  r_info;   // Symbol table index and type of relocation to apply
--  INT32 r_addend; // Compute value for relocatable field by adding this
--};
--
--struct Elf64_Rela {
--  UINT64  r_offset; // Location (file byte offset, or program virtual addr).
--  UINT64  r_info;   // Symbol table index and type of relocation to apply.
--  INT64 r_addend; // Compute value for relocatable field by adding this.
--};
--
----*/
            desc = "Relocations2"
            SetTabIdx(desc)
            p_rela = p_vals[p_rela]
            address = ds_normalise(p_rela)
--      elfv = append(elfv,{"Relocations2",p_rela,address})
            if relasz=-1 then ?9/0 end if
            if relaent=-1 then ?9/0 end if
            size = p_vals[relasz]
            elfv = append(elfv,{"Relocations2",address,address+size})
            while size do
                desc = "??"
                if machine=32 then
                    r_offset = decode("relocation offset","h4","")
                    r_info = decode("r_info","h4","")
                    r_symidx = floor(r_info/#100)
                    r_type = and_bits(r_info,#FF)
                    if r_type>=0 and r_type<length(R_386_DESCS) then
                        desc = R_386_DESCS[r_type+1]
                    end if
                    r_addend = decode("r_addend","h4","")
                elsif machine=64 then
                    r_offset = decode("relocation offset","h8","")
                    r_info = decode("r_info","h8","")
                    if atom(r_info) then
                        r_symidx = floor(r_info/#100000000)
                        r_type = and_bits(r_info,#FFFFFFFF)
                    else
                        {r_symidx,r_type} = r_info
                    end if
                    if r_type>=0 and r_type<length(R_X86_DESCS) then
                        desc = R_X86_DESCS[r_type+1]
                    end if
                    r_addend = decode("r_addend","h8","")
                else
                    ?9/0
                end if
                if r_type=R_386_RELATIVE then
                    if r_symidx!=0 then ?9/0 end if
                    res[tabidx][$-1][R_NOTES] = sprintf("%s",{desc})
                elsif p_hash=-1 then
                    res[tabidx][$-1][R_NOTES] = sprintf("%s, symtab[%d]=???",{desc,r_symidx})
                else
                    name = st_names[r_symidx+1]
                    res[tabidx][$-1][R_NOTES] = sprintf("%s, symtab[%d]=%s",{desc,r_symidx,name})
                    knownAddr = append(knownAddr,r_offset)
                    knownNames = append(knownNames,name)
                end if
                size -= p_vals[relaent]
            end while
--      elfv[$][$] = address - elfv[$][$]
        end if
    end if

    return 1
end function

procedure decode_ELF_code_segment(integer idx, integer justsettab, integer supported)
--sequence p_offsets
--sequence p_vaddrs
--sequence p_fileszs
string desc
--integer dsidx
--integer size = p_fileszs[idx]
integer size = iff(idx>0?p_fileszs[idx]:shsizes[-idx])
atom taddr
string asm,hex,analysis
sequence line
--integer ilen
atom ilen

    if idx<0 then
        desc = shdescs[-idx]
    else
        csidx = find(idx,sCodeSegments)
        if csidx=0 then ?9/0 end if
        if csidx=1 then
            desc = "Code Segment"
        else
            desc = sprintf("Code Segment(%d)",csidx)
        end if
    end if
    SetTabIdx(desc)
    if justsettab then return end if    -- DEV reorder them all at the end instead...
--DEV this could be on phtab or pstab...
    if idx>0 then
        set_seetab(desc,idx)
--DEV??
--  else
--      set_seetab2(desc,idx,???)
    end if
--  CSvaddr = p_vaddrs[idx]
    CSvaddr = iff(idx>0?p_vaddrs[idx]:shaddrs[-idx])
    if CSvaddr=0 or supported=-1 then
--?1
--      address = 0
        address = CSvaddr
        elfv = append(elfv,{desc,address,address+size})
-- 1/12/14:
--      if e_machine=40 then    -- ARM
--          while ? do
--              line = {address,sprintf("%08x:  %s",{taddr,asm}),"-",hex,analysis}
--              res[tabidx] = append(res[tabidx],line)
--              address += 4 (2 for thumb mode?)
--          end while
--      else
        binary_dump(size,"%08x")
--      end if
        return
    end if
    --DEV note this is x86:
    CSvsize = size
    code_section = binary
--  address = p_offsets[idx]
    address = iff(idx>0?p_offsets[idx]:shoffsets[-idx])
    elfv = append(elfv,{desc,address,0})    -- erm?
--  decodeinit(CSvaddr, p_offsets[idx], machine)
    decodeinit(CSvaddr, address, machine, arch_ELF)
    while addr<CSvaddr+size do
        ilen = addr
        {asm,taddr,hex,analysis} = p2asm:decode()
--      line = {taddr,asm,"-",hex,analysis}
        ilen = addr-ilen
        line = {address,sprintf("%08x:  %s",{taddr,asm}),"-",hex,analysis}
        address += ilen
        res[tabidx] = append(res[tabidx],line)
    end while
    elfv[$][$] = address
--/*
ff938368:       e92d4010        stmdb   sp!, {r4, lr}
ff93836c:       e59f0020        ldr     r0, [pc, #32]   ; ff938394: (ffac13cc) 
ff938370:       ebfcc3fd        bl      ff86936c <_binary_dump_bin_start+0x5936c -847876>
ff938374:       eb01cf03        bl      ff9abf88 <_binary_dump_bin_start+0x19bf88 +474132>
ff938378:       e3a00000        mov     r0, #0  ; 0x0
ff93837c:       e8bd8010        ldmia   sp!, {r4, pc}
// this is obviously an entry point, because      ^^ is a "return"
ff938380:       e24f1020        sub     r1, pc, #32     ; ff938368: (e92d4010) 
ff938384:       e28f000c        add     r0, pc, #12     ; ff938398: (74706143)  *"Capture.Create"
ff938388:       eafcc355        b       ff8690e4 <_binary_dump_bin_start+0x590e4 -848548>
// another
ff93838c:       e28f0004        add     r0, pc, #4      ; ff938398: (74706143)  *"Capture.Create"
ff938390:       eafcc355        b       ff8690ec <_binary_dump_bin_start+0x590ec -848548>
// this is data, referenced from 0xff93836c followed by some text
ff938394:       ffac13cc        undefined instruction 0xffac13cc
"Capture.Create":
ff938398:       74706143        ldrvcbt r6, [r0], #-323
ff93839c:       2e657275        mcrcs   2, 3, r7, cr5, cr5, {3}
ff9383a0:       61657243        cmnvs   r5, r3, asr #4
ff9383a4:       00006574        andeq   r6, r0, r4, ror r5
--*/
end procedure

function decode_ELF_data_segment(integer idx)
string desc
integer dsidx
integer size = p_fileszs[idx]
    addr = p_vaddrs[idx]
    address = p_offsets[idx]
--  if p_types[idx]=PT_INTERP then -- interpreter
--      desc = "Interpreter"
--  else
    if p_types[idx]!=PT_LOAD then ?9/0 end if
    dsidx = find(idx,sDataSegments)
    if dsidx=0 then ?9/0 end if
    if dsidx=1 then
        desc = "Data Segment"
    else
        desc = sprintf("Data Segment(%d)",dsidx)
    end if
--  end if
    SetTabIdx(desc)
--?desc
    set_seetab(desc,idx)    -- DEV phtab/pstab
    elfv = append(elfv,{desc,address,0})
    if size then
        {} = phix_datadump(size,"%08x")
    end if
    elfv[$][$] = address
    return 1
end function

function dump_ELF_interpreter(integer idx)
string desc
--integer dsidx
integer size = p_fileszs[idx]
    addr = p_vaddrs[idx]
    address = p_offsets[idx]
    desc = "Interpreter"
    SetTabIdx(desc)
    set_seetab(desc,idx)    -- DEV phtab/pstab (or both!)
    elfv = append(elfv,{"Interpreter",address,0})
    if size then
--      {} = phix_datadump(size,"%08x")
        binary_dump(size,"%08x")
    end if
--/*
    size = roundto(size,4)-size
--28/3/16:
--  if size!=0 then
    if address+size>file_size then
?{address,"+",size,">",file_size,":=",file_size-address}
        size = file_size-address
    end if
    if size>0 then
        binary_dump(size,"padding")
    end if
--*/
    elfv[$][$] = address
    return 1
end function

--                  mask    , divisor
constant OOO    = {#0E000000,#02000000},
         OOOO   = {#0F000000,#01000000},
         OPCODE = {#01E00000,#00200000},
         RN     = {#000F0000,#00010000},
         RD     = {#0000F000,#00001000},
         RS     = {#00000F00,#00000100},
         RM     = {#0000000F,#00000001},
         S      = {#00100000,#00100000},
         SHIFT  = {#00000060,#00000020},
         SHIFTH = {#00000F80,#00000080},
         ROTATE = {#00000F00,#00000100},
         LIT8   = {#000000FF,#00000001},
         LIT12  = {#00000FFF,#00000001},
         L      = {#01000000,#01000000},
         OFFSET = {#00FFFFFF,#00000001},
         P      = {#01000000,#01000000},
         U      = {#00800000,#00800000},
         X      = {#00400000,#00400000},
         W      = {#00200000,#00200000},
         Y      = {#00100000,#00100000},
         X2     = {#00008000,#00008000},
         OP1    = {#00F00000,#00100000},
         OP2    = {#000000E0,#00000020},
         Z      = {#00000010,#00000010},
         REG16  = {#0000FFFF,#00000001},
         REG15  = {#00007FFF,#00000001},
         SWI    = {#00FFFFFF,#00000001}

constant ops = {"and","eor","sub","rsb",
                "add","adc","sbc","rsc",
                "tst","teq","cmp","cmn",
                "orr","mov","bic","mvn"}
-- hs==cs, lo=cc
constant ccs = {"eq","ne","cs","cc",
                "mi","pl","vs","vc",
                "hi","ls","ge","lt",
                "gt","le", "" ,"nv"}
constant AL = 15 -- (not out by 1)

constant ss = {"","s"}

constant R = {"r0","r1","r2","r3",
              "r4","r5","r6","r7",
              "r8","r9","r10","fp",
              "ip","sp","lr","pc"}

constant SP = 13, -- (out by 1)
         SPBIT = #2000 -- (bit 13)

constant ls = {"","l"}
constant bs = {"","b"}
--constant mp = {"-","+"}
constant di = {"d","i"}
constant ab = {"a","b"}
constant usepushpop = 1         --  DEV: config option
constant usefead = 1            -- /
constant fe = "fe", ad = "ad"   -- fd/fa/ed/ea

constant ws = {"","!"}

constant shifts = {"lsl",   -- (==asl) [use lsl 0 for a nop]
                   "lsr",
                   "asr",
                   "ror"}   -- (ror 0 (a nop) means rrx instead)

constant m4 = {-4,4}

constant hsbsh = {"h","sb","sh"}

function mask(atom ins, sequence m)
integer res = and_bits(ins,m[1])/m[2]
    return res
end function

function dump_ELF_arm(integer idx, string desc)
--
-- Note: I don't claim to know what I'm doing here. I'm using a 15-year-old cribsheet from a
--  Nintendo GameBoy Advance(!!) and matching results from https://www.onlinedisassembler.com
--  (erm, it would probably be better to match the output of "arm-linux-objdump -d test.elf")
-- Sadly, sample arm elf binaries are in pitiful short supply around where I live.
-- Update: Best reference yet found: http://www.heyrick.co.uk/armwiki/Category:Opcodes
-- maybe: http://www.peter-cockerell.net/aalp/html/frames.html
--
integer size = shsizes[idx]
atom ins
integer ooo, cond, opcode, Rn, Rd, Rm, Rs, s, shift, shifth, rot, lit8, offset
integer p, u, x, w, y, reg_list, lit12, cp_num
string asm, err = "", xtra, regs
    addr = shaddrs[idx]
    address = shoffsets[idx]
    SetTabIdx(desc)
    -- (Phix programs don't have section headers, btw)
    set_seetab2(desc,idx,pstab)
    elfv = append(elfv,{desc,address,0})
    if size then
--      addsymtabsep("--CODE--")    -- (temp)   [worked fine!]

        while size do
            ins = decode(sprintf("%08x",addr),"h4","unknown")
            size -= 4
            addr += 4
            cond = floor(ins/#10000000)+1
--          if cond=16 then ?9/0 end if
            if cond=16 then return fatal("???") end if
            ooo = mask(ins,OOO)
            Rn = mask(ins,RN)
            Rd = mask(ins,RD)
            Rs = mask(ins,RS)
            Rm = mask(ins,RM)
--if ??=0 then return fatal("SBZ error") end if
--if ??=1 then return fatal("SBO error") end if
            if ooo=0b000
            and (and_bits(ins,#10)=0 or and_bits(ins,#80)=0) then
                opcode = mask(ins,OPCODE)
                s = mask(ins,S)
                shift = mask(ins,SHIFT)
                shifth = mask(ins,SHIFTH)
                if opcode=0b1101        -- mov
                or opcode=0b1111 then   -- mvn
                    if Rn!=0 then err = "Rn SBZ" end if
--                  Rd = Rn
                end if
                if opcode=0b1000        -- tst
                or opcode=0b1001        -- teq
                or opcode=0b1010        -- cmp
                or opcode=0b1011 then   -- cmn
                    if s=0 then err = "s!=1" end if
                end if
                asm = ops[opcode+1]&ccs[cond]&ss[s+1]&" "&R[Rd+1]
                if opcode!=0b1101       -- mov
                and opcode!=0b1111 then -- mvn
                    asm &= ", "&R[Rn+1]
                end if
                asm &= ", "&R[Rm+1]
                if and_bits(ins,#10)=0 then
                    if shifth!=0
                    or shift!=0 then
                        --DEV???
--                      asm &= sprintf(" (shifth=0b%05b, shift=%02b)",{shifth,shift})
                        asm &= sprintf(", %s %d",{shifts[shift+1],shifth})
                    end if
                else
                    asm &= sprintf(", %s %s",{shifts[shift+1],R[Rs+1]})
                end if
                if find(asm,{"mov r0, r0"}) then
                    asm = sprintf("nop (%s)",{asm})
                end if
                res[tabidx][$][R_NOTES] = asm
                if length(err) then return fatal(err) end if
--              exit
            elsif ooo=0b000
              and mask(ins,OPCODE)=0b0000
              and and_bits(ins,#F0)=0b10010000 then
--            and and_bits(ins,#F0)=#90 then
                s = mask(ins,S)
                if Rd!=0 then err = sprintf("  *** SBZ is #%x ***",Rd) end if
                Rd = Rn
                asm = "mul"&ccs[cond]&ss[s+1]&" "&R[Rd+1]&", "&R[Rm+1]&", "&R[Rs+1]&err
                err = ""
                res[tabidx][$][R_NOTES] = asm
--              if length(err) then return fatal(err) end if

            elsif ooo=0b000
              and mask(ins,Z)=1
              and and_bits(ins,#E0)>#80 then
                shift = mask(ins,SHIFT)
                s = mask(ins,S)
                if shift=1 or s=1 then
                    p = mask(ins,P)     -- pre/post indexing
                    u = mask(ins,U)     -- up/down
                    x = mask(ins,X)     -- byte/word (I - 0=immediate, 1=register)
                    w = mask(ins,W)     -- write-back
                    -- (Rs and Rm are addr_mode here)
                    asm = iff(s=0?"str":"ldr")&ccs[cond]&hsbsh[shift]&" "&R[Rd+1]&", "
--DEV need help here! (on putting this in, quickly realised it was disassembling data not code anyway)
                    asm &= sprintf("??P=%d,U=%d,I=%d,W=%d,Rn=%s,Rs=0b%04b,Rm=%04b",{p,u,x,w,R[Rn+1],Rs,Rm})
                    res[tabidx][$][R_NOTES] = asm
                end if

            elsif ooo=0b001 then
--DEV msr*2
                opcode = mask(ins,OPCODE)
                rot = mask(ins,ROTATE)
                lit8 = mask(ins,LIT8)
                if opcode=0b1101        -- mov
                or opcode=0b1111 then   -- mvn
                    if Rn!=0 then err = "Rn SBZ" end if
                end if
                asm = ops[opcode+1]&ccs[cond]&" "&R[Rd+1]
                if opcode!=0b1101       -- mov
                and opcode!=0b1111 then -- mvn
                    asm &= ", "&R[Rn+1]
                end if
                if rot!=0 and lit8!=0 then
                    atom tmp = lit8*power(2,32-rot*2)
                    tmp = and_bits(tmp,#FFFFFFFF)+floor(tmp/#100000000)
                    asm &= sprintf(", %d",tmp)
                else
                    asm &= sprintf(", %d",lit8)
                    if rot!=0 then
                        asm &= sprintf(" (rotate=%04b)",{rot})
                    end if
                end if
                res[tabidx][$][R_NOTES] = asm
                if length(err) then return fatal(err) end if
--              exit
            elsif ooo=0b010 then
                p = mask(ins,P)     -- pre/post indexing
                u = mask(ins,U)     -- up/down
                x = mask(ins,X)     -- byte/word
                w = mask(ins,W)     -- write-back
                y = mask(ins,Y)     -- load/store
                asm = iff(y=0?"str","ldr")&ccs[cond]&bs[x+1]
                if p=0 and w=1 then
                    asm &= "t"
--                  w = 0
                end if
                asm &= " "&R[Rd+1]&", "
                lit12 = mask(ins,LIT12)
                xtra = ""
                if u=0 then
                    lit12 = 0-lit12
                end if
                if p then
                    asm &= sprintf("[%s, %d]",{R[Rn+1],lit12})
                    if Rn=15 then -- pc
                        xtra = sprintf(" (#%08x)",{addr+lit12+4})
                    end if
                else
                    asm &= sprintf("[%s], %d",{R[Rn+1],lit12})
                end if
                if p=1 and w=1 then
                    asm &= "!"
                end if
                res[tabidx][$][R_NOTES] = asm&xtra
            elsif ooo=0b011
              and and_bits(ins,#10)=0 then
                p = mask(ins,P)     -- pre/post indexing
                u = mask(ins,U)     -- up/down
                x = mask(ins,X)     -- byte/word
                w = mask(ins,W)     -- write-back
                y = mask(ins,Y)     -- load/store
--              s = mask(ins,S)
                shift = mask(ins,SHIFT)
                shifth = mask(ins,SHIFTH)
                asm = iff(y=0?"str","ldr")&ccs[cond]&bs[x+1]
                if p=0 and w=1 then
                    asm &= "t"
--                  w = 0
                end if
                asm &= " "&R[Rd+1]&", "
                if opcode!=0b1101       -- mov
                and opcode!=0b1111 then -- mvn
                    asm &= ", "&R[Rn+1]
                end if
                asm &= ", "&R[Rm+1]
--              if and_bits(ins,#10)=0 then
                if shifth!=0
                or shift!=0 then
                        --DEV???
--                      asm &= sprintf(" (shifth=0b%05b, shift=%02b)",{shifth,shift})
                    asm &= sprintf(", %s %d",{shifts[shift+1],shifth})
                end if
--              else
--                  asm &= sprintf(", %s %s",{shifts[shift+1],R[Rs+1]})
--              end if
                if p=1 and w=1 then
                    asm &= "!"
                end if
                res[tabidx][$][R_NOTES] = asm
--              if length(err) then return fatal(err) end if

            elsif ooo=0b100 then
                p = mask(ins,P)
                u = mask(ins,U)
                x = mask(ins,X)
                w = mask(ins,W)
                y = mask(ins,Y)
--push/pop (done):
--stmdb = stmfd = push (if Rn=sp and w=1) [full ascending]
--ldmia = ldmfd = pop (if Rn=sp and w=0 and sp is in the list)
--stmib = stmfa, ldmda = ldmfa [full descending]
--stmda = stmed, ldmib = ldmed [empty descending]
--stmia = stmea, ldmdb = ldmea [empty ascending]
                reg_list = mask(ins,REG16)
                if usepushpop
                and cond=AL                                     -- always
                and Rn=SP                                       -- sp
                and u!=p and u=y                                -- db or ia
                and y!=w                                        -- stm! or ldm(no!)
                and (y=0 or and_bits(reg_list,SPBIT)!=0) then   -- (w=1 or sp in list)
                    asm = iff(y=0?"push {":"pop {")
--              elsif cond=AL
--                and u=0
--                and p=1
--                and y=0 then
--                  if Rn=SP and w=1 then
--                      asm = "?push {"
--                  else
--                      asm = "?stmfd "&R[Rn+1]&ws[w+1]&", {"
--                  end if
--              elsif cond=AL
--                and u=1
--                and p=0
--                and y=1 then
--                  if Rn=SP
--                  and and_bits(reg_list,SPBIT)
--                  and w=0 then
--                      asm = "?pop {"
--                  else
--                      asm = "?ldmfd "&R[Rn+1]&ws[w+1]&", {"
--                  end if
                else
                    --y u p                 y=p     y=u
                    --0 0 0 stmda   stmed   1(e)    1(d)
                    --0 0 1 stmdb   stmfd   0(f)    1(d)
                    --0 1 0 stmia   stmea   1(e)    0(a)
                    --0 1 1 stmib   stmfa   0(f)    0(a)
                    --1 0 0 ldmda   ldmfa   0(f)    0(a)
                    --1 0 1 ldmdb   ldmea   1(e)    0(a)
                    --1 1 0 ldmia   ldmfd   0(f)    1(d)
                    --1 1 1 ldmib   ldmed   1(e)    1(d)
                    xtra = iff(usefead?fe[(y=p)+1]&ad[(y=u)+1]
                                      :di[u+1]&ab[p+1])
                    asm = iff(y=0?"stm","ldm")&ccs[cond]&xtra&" "&R[Rn+1]&ws[w+1]&", {"
                end if

                if x=0 then
--                  asm &= sprintf(" (Rn=%s, P=%d, U=%d, X=0, W=%d, Y=%d, Regs=%016b)",{R[Rn+1],p,u,w,y,reg_list})
--                  asm &= sprintf(" Regs=%016b ",{reg_list})
                    regs = ""
                    for i=1 to 16 do
                        if and_bits(reg_list,1) then
                            if length(regs) then
                                regs &= ","
                            end if
                            regs &= R[i]
                        end if
                        reg_list = floor(reg_list/2)
                    end for
                    --DEV
--                  asm &= sprintf(" (Rn=%s, P=%d, U=%d, X=0, W=%d, Y=%d, Regs=%016b)",{R[Rn+1],p,u,w,y,reg_list})
--                  asm &= sprintf(" Regs=%016b ",{reg_list})
                    asm &= regs&"}"
                else
                    --DEV just do the non-hatted top two, for now:
                    err = "unpredictable or ^"
                    x = mask(ins,X2)
                    if x=0 then
                        -- (I assume there is a typo on the crib sheet, otherwise the
                        --  two unpredictables in the "100"s overlap with the last 2)
                        if w=1 then err = "UNPREDICTABLE" end if
                    end if
                    reg_list = mask(ins,REG15)
                    --DEV
                    asm &= sprintf(" (X2=%d, Regs=%015b)",{x,reg_list})
                end if
                res[tabidx][$][R_NOTES] = asm
                if length(err) then return fatal(err) end if
            elsif ooo=0b101 then
                offset = mask(ins,OFFSET)
                if offset>#7FFFFF then
                    offset -= #1000000
                end if
                asm = "b"&ls[mask(ins,L)+1]&ccs[cond]&sprintf(" #%08x",addr+offset*4+4)
                res[tabidx][$][R_NOTES] = asm
            elsif ooo=0b110 then
--          elsif 0 then
                -- NB *not* checked against anything
                -- stc/ldc
                p = mask(ins,P)
--LDC    p,CRd,[Rn,#20] ;short form (N=0), pre-indexed
--STCL   p,CRd,[Rn,#-32]! ;long form (N=1), pre-indexed with writeback
--LDCNEL p,CRd,[Rn],#-100 ;long form (N=1), post-indexed
                u = mask(ins,U)
                x = mask(ins,X) -- (N)
                w = mask(ins,W)
                y = mask(ins,Y)
--              Rn = mask(ins,RN)   -- (already set)
--              Rd = mask(ins,RD)   -- ("")
                cp_num = mask(ins,RS)
                offset = mask(ins,LIT8)*m4[u+1]
                if p=0 and w=0 then return fatal("p=0 and w=0 ?!??") end if
                asm = iff(y=0?"stc":"ldc")&ls[x+1]&ccs[cond]&sprintf(" p%d,c%s,",{cp_num,R[Rd+1]})
                if p then
                    asm &= sprintf("[%s, %d]",{R[Rn+1],offset})
                    if Rn=15 then -- pc
                        xtra = sprintf(" (#%08x)",{addr+offset+4})
                    end if
                else
                    asm &= sprintf("[%s], %d",{R[Rn+1],offset})
                end if
--              if p=1 and w=1 then
                if w=1 then -- (???)
                    asm &= "!"
                end if
                res[tabidx][$][R_NOTES] = asm

            elsif ooo=0b111 then
--          elsif 0 then
                -- NB *not* checked against anything
                p = mask(ins,P)
                if p=0 then             -- cdp/mcr/mrc
                    integer op1 = mask(ins,OP1) -- (/2 if z=1)
                    Rn = mask(ins,RN)
                    Rd = mask(ins,RD)
                    cp_num = mask(ins,RS)
                    integer op2 = mask(ins,OP2)
                    integer z = mask(ins,Z)
                    if z=0 then op1 = floor(op1/2) end if
                    Rm = mask(ins,RM)
--DEV/SUG??: (arbitrarily nest and daisy-chain conditionals)
--iff(a=0?"a=0":b=0?"b=0":"a&b!=0")
--iff(a=0?b=0?"a&b=0":"b!=0":"a!=0")
                    asm = iff(z=0?"cdp":iff(mask(ins,Y)=0?"mcr":"mrc"))&ccs[cond]
--                  asm = iff(z=0?"cdp":mask(ins,Y)=0?"mcr":"mrc")&ccs[cond]
                    asm &= sprintf(" p%d,%d,",{cp_num,op1})
                    asm &= iff(z=0?"c":"")&R[Rd+1]&",c"&R[Rn+1]&",c"&R[Rm+1]&sprintf(",%d",op2)
--                  ?9/0
                else                    -- swi
                    asm = "swi"&ccs[cond]&sprintf(" %d",mask(ins,SWI))
                end if
                res[tabidx][$][R_NOTES] = asm
--/*
--  void printasm (FILE *out, unsigned int x, unsigned int adr)
--  {
--      char buf[1000];
--      int i, j;
--      char *cond[] = { "==", "!=", "c", "!c", "<0", ">=0",  "OVF", "!OVF", "HI", "LS", ">=", "<", ">", "<=", "", "UNC" };
--      char *op[] = { "&", "!", "-", "*-1+", "+", "+c+", "-!c-", "*-1-!c+", "?&", "?!", "?-", "?+", "|", "->", "&!", "->~" };
--      // char *shift[] = { "LSL", "LSR", "ASR",  "RR" };
--      char *shift[] = { "<<", ">>", "->>", ">>>" };
--      unsigned int Rn, Rd, Rs, Rm;
--      unsigned int adr1;
--      int adrinstr;
--      int trouve;
--
--      adrinstr = adr;
--
--      Rn = field (x, 0xF0000);
--      Rd = field (x, 0xF000);
--      Rs = field (x, 0xF00);
--      Rm = field (x, 0xF);
--
--      i = 0;
--
--      for (j=0; j<nadr; j++)
--          if (x == tabadr[j].adr)
--          {
--              if (dasm)
--              {
--                  i += sprintf (buf+i, "%s", tabadr[j].name);
--                  goto outbuf;
--              }
--              else
--                  i += sprintf (buf+i, "#%X == %s ", x, tabadr[j].name);
--          }
--
--      if (x >= beginstrings && x <= endstrings)
--      {
--          i += sprintf (buf+i, "strings+%X", x-beginstrings);
--          goto outbuf;
--      }
--
--      i += sprintf (buf+i, cond[x>>28]);
--      // i += sprintf (buf+i, "(%x)", x>>28);
--      i += sprintf (buf+i, " ");
--
--      if (match (x, 0x1200010, 0xFF000F0))
--          i += sprintf (buf+i, "BX [R%X]", Rm);
--
--      else if (match (x, 0xF0000000, 0xF0000000)) /* unconditional */
--          i += sprintf (buf+i, "#%07X", x & 0xFFFFFFF);
--
--      /*
--      else if (match (x, 0xA000000, 0xF000000))
--          i += sprintf (buf+i, "B RF+4*%X == %X", field (x, 0xFFFFFF), adr+8+4*sfield(x,0xFFFFFF));
--      */
--      else if (match (x, 0xA000000, 0xF000000))
--      {
--          // i += sprintf (buf+i, "BL RF+4*%X == %X",  field (x, 0xFFFFFF), adr+8+4*sfield(x,0xFFFFFF));
--          trouve = 0;
--          for (j=0; j<nadr; j++)
--              if ((int)(tabadr[j].adr) == adr+8+4*sfield(x,0xFFFFFF))
--              {
--                  trouve = 1;
--                  i += sprintf (buf+i, "GOTO %s", tabadr[j].name);
--              }
--          if (!trouve)
--              i += sprintf (buf+i, "GOTO %X", adr+8+4*sfield(x,0xFFFFFF));
--      }
--
--      else if (match (x, 0xB000000, 0xF000000))
--      {
--          // i += sprintf (buf+i, "BL RF+4*%X == %X",  field (x, 0xFFFFFF), adr+8+4*sfield(x,0xFFFFFF));
--          trouve = 0;
--          for (j=0; j<nadr; j++)
--              if ((int)(tabadr[j].adr) == adr+8+4*sfield(x,0xFFFFFF))
--              {
--                  trouve = 1;
--                  i += sprintf (buf+i, "%s ()", tabadr[j].name);
--              }
--          if (!trouve)
--              i += sprintf (buf+i, "%X ()", adr+8+4*sfield(x,0xFFFFFF));
--      }
--      else if (match (x, 0x1000000, 0xF900010)) /* misc */
--          // i += sprintf (buf+i, "#%07X misc", x & 0xFFFFFFF);
--          i += sprintf (buf, "%X", x);
--      else if (match (x, 0x1000010, 0xF900090)) /* misc */
--          // i += sprintf (buf+i, "#%07X misc", x & 0xFFFFFFF);
--          i += sprintf (buf, "%X", x);
--
--      /*
--      else if (match (x, 0x3A00000, 0xFFF0F00))
--          i += sprintf (buf+i, "R%X=%X", field (x, 0xF000), field (x, 0xFF));
--      else if (match (x, 0x1A00000, 0xFFF0FF0))
--          i += sprintf (buf+i, "R%X=R%X", field (x, 0xF000), field (x, 0xF));
--      else if (match (x, 0x2800000, 0xFF00F00))
--          i += sprintf (buf+i, "R%X=R%X+%X", field (x, 0xF000), field (x, 0xF0000), field (x, 0xFF));
--      else if (match (x, 0x0800000, 0xFF00FF0))
--          i += sprintf (buf+i, "R%X=R%X+R%X", field (x, 0xF000), field (x, 0xF0000), field (x, 0xF));
--      else if (match (x, 0x2400000, 0xFF00F00))
--          i += sprintf (buf+i, "R%X=R%X-%X", field (x, 0xF000), field (x, 0xF0000), field (x, 0xFF));
--      else if (match (x, 0x0400000, 0xFF00FF0))
--          i += sprintf (buf+i, "R%X=R%X-R%X", field (x, 0xF000), field (x, 0xF0000), field (x, 0xF));
--      
--      else if (match (x, 0x5900000, 0xFF00000))
--          i += sprintf (buf+i, "R%X=[R%X+%X]", field (x, 0xF000), field (x, 0xF0000), field (x, 0xFFF));
--      else if (match (x, 0x5800000, 0xFF00000))
--          i += sprintf (buf+i, "[R%X+%X]=R%X", field (x, 0xF0000), field (x, 0xFFF), field (x, 0xF000));
--      */
--
--      else if (match (x, 0x9200000, 0xFF00000))
--          i += sprintf (buf+i, "PUSH R%X %04X", field (x, 0xF0000), field (x, 0xFFFF));
--      else if (match (x, 0x8B00000, 0xFF00000))
--          i += sprintf (buf+i, "POP R%X %04X", field (x, 0xF0000), field (x, 0xFFFF));
--
--      else if (match (x, 0x1A00000, 0xFF00FF0)) /* move with register */
--          i += sprintf (buf+i, "R%X = R%X", Rd, Rm);
--      else if (match (x, 0x1B00000, 0xFF00010)) /* move with register, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X", Rd, Rm);
--
--      else if (match (x, 0x1A00000, 0xFF00010)) /* move with register shifted by immediate */
--          i += sprintf (buf+i, "R%X = R%X %s %X", Rd, Rm, shift[field(x,0x60)], field(x,0xF80));
--      else if (match (x, 0x1B00000, 0xFF00010)) /* move with register shifted by immediate, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s %X", Rd, Rm, shift[field(x,0x60)], field(x,0xF80));
--      else if (match (x, 0x1A00010, 0xFF00090)) /* move with register shifted by register */
--          i += sprintf (buf+i, "R%X = R%X %s R%X", Rd, Rm, shift[field(x,0x60)], Rs);
--      else if (match (x, 0x1B00010, 0xFF00090)) /* move with register shifted by register, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s R%X", Rd, Rm, shift[field(x,0x60)], Rs);
--      else if (match (x, 0x3A00000, 0xFF00000)) /* move immediate */
--          i += sprintf (buf+i, "R%X = %X", Rd, rotate (field(x,0xFF), field(x,0xF00)));
--      else if (match (x, 0x3B00000, 0xFF00000)) /* move immediate, update condition codes */
--          i += sprintf (buf+i, "R%X ?= %X", Rd, rotate (field(x,0xFF), field(x,0xF00)));
--
--      else if (match (x, 0x0000000, 0xE100FF0)) /* data processing with register */
--          i += sprintf (buf+i, "R%X = R%X %s R%X", Rd, Rn, op[field(x,0x1E00000)], Rm);
--      else if (match (x, 0x0100000, 0xE100FF0)) /* data processing with register, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s R%X", Rd, Rn, op[field(x,0x1E00000)], Rm);
--
--      else if (match (x, 0x0000000, 0xE100010)) /* data processing with register shifted by immediate */
--          i += sprintf (buf+i, "R%X = R%X %s R%X %s %X", Rd, Rn, op[field(x,0x1E00000)], Rm, shift[field(x,0x60)], field(x,0xF80));
--      else if (match (x, 0x0100000, 0xE100010)) /* data processing with register shifted by immediate, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s R%X %s %X", Rd, Rn, op[field(x,0x1E00000)], Rm, shift[field(x,0x60)], field(x,0xF80));
--      else if (match (x, 0x0000010, 0xE100090)) /* data processing with register shifted by register */
--          i += sprintf (buf+i, "R%X = R%X %s R%X %s R%X", Rd, Rn, op[field(x,0x1E00000)], Rm, shift[field(x,0x60)], Rs);
--      else if (match (x, 0x0100010, 0xE100090)) /* data processing with register shifted by register, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s R%X %s R%X", Rd, Rn, op[field(x,0x1E00000)], Rm, shift[field(x,0x60)], Rs);
--      else if (match (x, 0x2000000, 0xE100000)) /* data processing immediate */
--          i += sprintf (buf+i, "R%X = R%X %s %X", Rd, Rn, op[field(x,0x1E00000)], rotate (field(x,0xFF), field(x,0xF00)));
--      else if (match (x, 0x2100000, 0xE100000)) /* data processing immediate, update condition codes */
--          i += sprintf (buf+i, "R%X ?= R%X %s %X", Rd, Rn, op[field(x,0x1E00000)], rotate (field(x,0xFF), field(x,0xF00)));
--
--      else if (match (x, 0x4000000, 0xE000000)) /* load store immediate offset */
--      {
--          char s;
--          char *af;
--          char adr[30];
--          char mem[30];
--          unsigned int im;
--          if (x & 0x800000)
--              s = '+';
--          else
--              s = '-';
--          im = field(x,0xFFF);
--          if (match (x, 0x4000000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X,%c=%X", Rn, s, im);
--          }
--          else if (match (x, 0x4200000, 0xF200000))
--          {
--              af = "=U";
--              sprintf (adr, "R%X,%c=%X", Rn, s, im);
--          }
--          else if (match (x, 0x5000000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X%c%X", Rn, s, im);
--              if (Rn == 0xF)
--              { 
--                  if (s == '+')
--                      adr1 = adrinstr + 8 + im;
--                  else
--                      adr1 = adrinstr + 8 - im;
--                  if (dasm)
--                      sprintf (adr, "%X", adr1);
--                  else
--                      sprintf (adr+strlen(adr), "==%X", adr1);
--                  for (j=0; j<nadr; j++)
--                      if (adr1 == tabadr[j].adr)
--                      {
--                          if (dasm)
--                              sprintf (adr, "%s", tabadr[j].name);
--                          else
--                              sprintf (adr+strlen(adr), "==%s", tabadr[j].name);
--                      }
--                      
--              }
--          }
--          else if (match (x, 0x5200000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X%c=%X", Rn, s, im);
--          }
--          if (x & 0x400000)
--              sprintf (mem, "$[%s]", adr);
--          else
--              sprintf (mem, "[%s]", adr);
--          if (x & 0x100000)
--              i += sprintf (buf+i, "R%X %s %s", Rd, af, mem);
--          else
--              i += sprintf (buf+i, "%s %s R%X", mem, af, Rd);
--          
--      }
--
--      else if (match (x, 0x6000000, 0xE000010)) /* load store register offset */
--      {
--          char s;
--          char *af;
--          char adr[30];
--          char mem[30];
--          char im[30];
--  //  fprintf (fdasm, "*1*");
--          if (x & 0x800000)
--              s = '+';
--          else
--              s = '-';
--  //  fprintf (fdasm, "*2*");
--          sprintf (im, "R%X %s %X", Rm, shift[field(x,0x60)], field(x,0xF80));
--  //  fprintf (fdasm, "*3*");
--          if (match (x, 0x6000000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X,%c=%s", Rn, s, im);
--          }
--          else if (match (x, 0x6200000, 0xF200000))
--          {
--              af = "=U";
--              sprintf (adr, "R%X,%c=%s", Rn, s, im);
--          }
--          else if (match (x, 0x7000000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X%c%s", Rn, s, im);
--          }
--          else if (match (x, 0x7200000, 0xF200000))
--          {
--              af = "=";
--              sprintf (adr, "R%X%c=%s", Rn, s, im);
--          }
--          else
--          {
--              af = "?";
--              sprintf (adr, "?");
--          }
--  //  fprintf (fdasm, "*4");
--          if (x & 0x400000)
--              sprintf (mem, "$[ %s]", adr);
--          else
--              sprintf (mem, "[%s]", adr);
--  /*  fprintf (fdasm, "*5*");
--      fprintf (fdasm, "*i=%d*", i);
--      fprintf (fdasm, "*Rd=%X*", Rd);
--      fprintf (fdasm, "*af=%s*", af);
--      fprintf (fdasm, "*mem=%s*", mem);
--  */      if (!strcmp (af, "?"))
--              i += sprintf (buf, "%X", x);
--          else if (x & 0x100000)
--              i += sprintf (buf+i, "R%X %s %s", Rd, af, mem);
--          else
--              i += sprintf (buf+i, "%s %s R%X", mem, af, Rd);
--  //  fprintf (fdasm, "*6");
--      }
--
--      else if (match (x, 0x8000000, 0xE000000)) /* load store multiple */
--      {
--          char mem[30];
--          char *af;
--
--          if (x & 0x400000)
--              af = "?=";
--          else
--              af = "=";
--
--          if (match (x, 0x8000000, 0xFA00000)) sprintf (mem, "[R%X-]", Rn); else 
--          if (match (x, 0x8200000, 0xFA00000)) sprintf (mem, "[R%X-=]", Rn); else
--          if (match (x, 0x8800000, 0xFA00000)) sprintf (mem, "[R%X+]", Rn); else
--          if (match (x, 0x8A00000, 0xFA00000)) sprintf (mem, "[R%X+=]", Rn); else
--          if (match (x, 0x9000000, 0xFA00000)) sprintf (mem, "[R%X--]", Rn); else
--          if (match (x, 0x9200000, 0xFA00000)) sprintf (mem, "[R%X--=]", Rn); else
--          if (match (x, 0x9800000, 0xFA00000)) sprintf (mem, "[R%X++]", Rn); else
--          if (match (x, 0x9A00000, 0xFA00000)) sprintf (mem, "[R%X++=]", Rn); else
--          sprintf (mem, "?");
--
--          if (x & 0x100000)
--              i += sprintf (buf+i, "RR#%04X %s %s", field(x,0xFFFF), af, mem);
--          else
--              i += sprintf (buf+i, "%s %s RR#%04X", mem, af, field(x,0xFFFF));
--              
--      }
--
--      else if (match (x, 0x1000090, 0xFF00FF0)) /* swap */
--          i += sprintf (buf+i, "R%X = [R%X] = R%X", Rd, Rn, Rm);
--      else if (match (x, 0x1400090, 0xFF00FF0)) /* swap bytes */
--          i += sprintf (buf+i, "R%X = $[R%X] = R%X", Rd, Rn, Rm);
--
--      else if (match (x, 0x1900F9F, 0xFF00FFF)) /* LDREX */
--          i += sprintf (buf+i, "R%X X= [R%X]", Rd, Rn);
--      else if (match (x, 0x1800F9F, 0xFF00FFF)) /* STREX */
--          i += sprintf (buf+i, "[R%X] X= R%X", Rn, Rd);
--
--      else if (match (x, 0x19000D0, 0xFF00FF0)) /* load signed byte register offset */
--          i += sprintf (buf+i, "R%X = +$[R%X+R%X]", Rd, Rn, Rm);
--
--      else if (match (x, 0x04000D0, 0xE4000F0))
--      {
--          char mem[30];
--          char s;
--          unsigned int ofs;
--          ofs = (x&0xF) | ((x&0xF00)>>4);
--          if (x & 0x800000)
--              s = '+';
--          else
--              s = '-';
--          if (match (x, 0x04000D0, 0xE6000F0))
--              sprintf (mem, "$$[R%X,%c=%X]", Rn, s, ofs);
--          else if (match (x, 0x14000D0, 0xE6000F0))
--              sprintf (mem, "$$[R%X%c=%X]", Rn, s, ofs);
--          else if (match (x, 0x16000D0, 0xE6000F0))
--              sprintf (mem, "$$[R%X%c%X]", Rn, s, ofs);
--          else
--              sprintf (mem, "[?]");
--          if (x & 100000)
--              i += sprintf (buf+i, "R%X = %s", Rd, mem);
--          else
--              i += sprintf (buf+i, "%s = R%X", mem, Rd);
--      }
--
--      else if (match (x, 0x0000090, 0xFF0F0F0))
--          i += sprintf (buf+i, "R%X = R%X * R%X", field(x,0xF0000), field(x,0xF00), field(x,0xF));
--
--      else
--          i += sprintf (buf, "%X", x);
--  outbuf:
--      buf[i] = 0;
--      fprintf (out, "%s", buf);
--  }
--*/
            else
                ooo = mask(ins,OOOO)    -- (not OOO)
                asm = sprintf("unknown (%04b)",{ooo})
                res[tabidx][$][R_NOTES] = asm
--              exit
                return fatal(asm)
            end if
        end while
        if size then
            {} = phix_datadump(size,"%08x")
        end if
    end if
    size = roundto(size,4)-size
--  if size!=0 then
    if size!=0 and address<file_size then
        binary_dump(size,"padding")
    end if
    elfv[$][$] = address
    return 1
end function

function dump_ELF_misc(integer idx, string desc)
integer size = shsizes[idx]
    addr = shaddrs[idx]
    address = shoffsets[idx]
    SetTabIdx(desc)
    -- (Phix programs don't have section headers, btw)
    set_seetab2(desc,idx,pstab)
    elfv = append(elfv,{desc,address,0})
    if size then
        {} = phix_datadump(size,"%08x")
    end if
    size = roundto(size,4)-size
--  if size!=0 then
    if size!=0 and address<file_size then
        binary_dump(size,"padding")
    end if
    elfv[$][$] = address
    return 1
end function

function decode_ELF_section_headers(integer e_shnum)
-- (not actually required for executables)
integer sh_name
string desc
--integer sh_type
atom sh_type
integer sh_flags
integer sh_addr
integer sh_offset
integer sh_seetab
integer sh_size
integer sh_link
integer sh_info
integer sh_addralign
integer sh_entsize
    SetTabIdx("Section Headers")
    pstab = tabidx
    elfv = append(elfv,{"Section Headers",address,0})
--/*
typedefstruct {
UINT32 sh_name;
UINT32 sh_type;
UINT32 sh_flags;
UINT32 sh_addr;
UINT32 sh_offset;
UINT32 sh_size;
UINT32 sh_link;
UINT32 sh_info;
UINT32 sh_addralign;
UINT32 sh_entsize;
} Elf32_Shdr;
--*/
--DEV no idea which of these we actually need:
    shdescs = {}
    shtypes = {}
    shflags = {}
    shaddrs = {}        -- -> p_vaddrs
    shoffsets = {}      -- -> p_offsets
    shseetabs = {}      -- -> p_seetab
    shsizes = {}        -- -> p_fileszs
    shlinks = {}
    shinfos = {}
    shaddraligns = {}
    shentsizes = {}
    for i=1 to e_shnum do
        sh_name = decode("sh_name",4,"")
--      desc = sprintf("section %d: %s",{i-1,get_string(string_table+sh_name)})
--      res[tabidx][$][R_NOTES] = desc
        desc = get_string(string_table+sh_name)
        shdescs = append(shdescs,desc)
        res[tabidx][$][R_NOTES] = sprintf("section %d: %s",{i-1,desc})
        sh_type = decode("sh_type","h4","")
        shtypes = append(shtypes,sh_type)
        if    sh_type=0x0 then          desc = "null"
        elsif sh_type=0x1 then          desc = "progbits"
        elsif sh_type=0x2  then         desc = "symbol table"
        elsif sh_type=0x3  then         desc = "string table"
        elsif sh_type=0x4  then         desc = "relocation table + addends"
        elsif sh_type=0x5  then         desc = "symbol hash table"
        elsif sh_type=0x6  then         desc = "dynamic linking information"
        elsif sh_type=0x7  then         desc = "note"
        elsif sh_type=0x8  then         desc = "nobits"
        elsif sh_type=0x9  then         desc = "relocation table"
        elsif sh_type=0xa  then         desc = "shlib"
        elsif sh_type=0xb  then         desc = "dynamic linking symbol table"
        elsif sh_type=0xe  then         desc = "init array"
        elsif sh_type=0xf  then         desc = "fini array"
        elsif sh_type=0x10  then        desc = "preinit array"
        else                            desc = "?"
        end if
        res[tabidx][$][R_NOTES] = desc
--      shdescs = append(shdescs,desc)
        if machine=32 then
            sh_flags = decode("sh_flags","h4","")
            desc = decode_flags(ELFsflagSet,sh_flags)
            res[tabidx][$][R_NOTES] = desc
            sh_addr = decode("sh_addr","h4","")
            sh_offset = decode("sh_offset","h4","")
            sh_size = decode("sh_size","h4","")
        elsif machine=64 then
            sh_flags = decode("sh_flags","h8","")
            desc = decode_flags(ELFsflagSet,sh_flags)
            res[tabidx][$][R_NOTES] = desc
            sh_addr = decode("sh_addr","h8","")
            sh_offset = decode("sh_offset","h8","")
            sh_size = decode("sh_size","h8","")
        else
            ?9/0
        end if
        sh_seetab = length(res[tabidx])-1
--DEV unless there is already an entry from program headers/no - just update both...
        if sh_size!=0 then
            res[tabidx][sh_seetab][R_NOTES] = "*** (see tab ???) ***"   -- DEV (temp?)
        end if
        sh_link = decode("sh_link","h4","")
        sh_info = decode("sh_info","h4","")
        if machine=32 then
            sh_addralign = decode("sh_addralign","h4","")
            sh_entsize = decode("sh_entsize","h4","")
        elsif machine=64 then
            sh_addralign = decode("sh_addralign","h8","")
            sh_entsize = decode("sh_entsize","h8","")
        else
            ?9/0
        end if
        shflags = append(shflags,sh_flags)
        shaddrs = append(shaddrs,sh_addr)
        shoffsets = append(shoffsets,sh_offset)
        shseetabs = append(shseetabs,sh_seetab)
        shsizes = append(shsizes,sh_size)
        shlinks = append(shlinks,sh_link)
        shinfos = append(shinfos,sh_info)
        shaddraligns = append(shaddraligns,sh_addralign)
        shentsizes = append(shentsizes,sh_entsize)

        -- Check sh_addralign: 0 and 1 mean "no alignment", otherwise it 
        --  should be a power of 2, and 512K sounds more than enough.
        if not find(sh_addralign,{0x0,0x1,0x00002,0x00004,0x00008,
                                  0x00010,0x00020,0x00040,0x00080,
                                  0x00100,0x00200,0x00400,0x00800,
                                  0x01000,0x02000,0x04000,0x08000,
                                  0x10000,0x20000,0x40000,0x80000}) then
            return fatal("bad align")
        end if
--      p_flags = decode("p_flags","h4","")
--      desc = decode_flags(ELFpflagSet,p_flags)
--      res[tabidx][$][R_NOTES] = desc
        addsep()
    end for
    elfv[$][$] = address
    return 1
end function

--/*
section header:


Sections
An object file's section header table lets one locate all the file's sections. The section header table is an
array of Elf32_Shdr structures as described below. A section header table index is a subscript into this
array. The ELF header's e_shoff member gives the byte offset from the beginning of the file to the section
header table; e_shnum tells how many entries the section header table contains; e_shentsize
gives the size in bytes of each entry.
Some section header table indexes are reserved; an object file will not have sections for these special
indexes.
Figure 1-8: Special Section Indexes
Name Value _ _________________________
SHN_UNDEF 0
SHN_LORESERVE 0xff00
SHN_LOPROC 0xff00
SHN_HIPROC 0xff1f
SHN_ABS 0xfff1
SHN_COMMON 0xfff2
SHN_HIRESERVE 0xffff _ _________________________ . . . . . . . . .
SHN_UNDEF This value marks an undefined, missing, irrelevant, or otherwise meaningless section
reference. For example, a symbol "defined" relative to section number SHN_UNDEF
is an undefined symbol.
NOTE
Although index 0 is reserved as the undefined value, the section header table contains an entry for
index 0. That is, if the e_shnum member of the ELF header says a file has 6 entries in the section
header table, they have the indexes 0 through 5. The contents of the initial entry are specified later in
this section.
SHN_LORESERVE This value specifies the lower bound of the range of reserved indexes.
SHN_LOPROC through SHN_HIPROC
Values in this inclusive range are reserved for processor-specific semantics.
SHN_ABS This value specifies absolute values for the corresponding reference. For example,
symbols defined relative to section number SHN_ABS have absolute values and are
not affected by relocation.
SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN
COMMON or unallocated C external variables.
SHN_HIRESERVE This value specifies the upper bound of the range of reserved indexes. The system
reserves indexes between SHN_LORESERVE and SHN_HIRESERVE, inclusive; the
values do not reference the section header table. That is, the section header table
does not contain entries for the reserved indexes.
Sections contain all information in an object file, except the ELF header, the program header table, and the
section header table. Moreover, object files' sections satisfy several conditions.

Every section in an object file has exactly one section header describing it. Section headers may
exist that do not have a section.
Each section occupies one contiguous (possibly empty) sequence of bytes within a file.
Sections in a file may not overlap. No byte in a file resides in more than one section.
An object file may have inactive space. The various headers and the sections might not "cover"
every byte in an object file. The contents of the inactive data are unspecified.
A section header has the following structure.
Figure 1-9: Section Header
typedefstruct {
UINT32 sh_name;
UINT32 sh_type;
UINT32 sh_flags;
UINT32 sh_addr;
UINT32 sh_offset;
UINT32 sh_size;
UINT32 sh_link;
UINT32 sh_info;
UINT32 sh_addralign;
UINT32 sh_entsize;
} Elf32_Shdr;
sh_name This member specifies the name of the section. Its value is an index into the section
header string table section [see "String Table" below], giving the location of a nullterminated
string.
sh_type This member categorizes the section's contents and semantics. Section types and their
descriptions appear below.
sh_flags Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions
appear below.
sh_addr If the section will appear in the memory image of a process, this member gives the
address at which the section's first byte should reside. Otherwise, the member contains
0.
sh_offset This member's value gives the byte offset from the beginning of the file to the first
byte in the section. One section type, SHT_NOBITS described below, occupies no
space in the file, and its sh_offset member locates the conceptual placement in the
file.
sh_size This member gives the section's size in bytes. Unless the section type is
SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type
SHT_NOBITS may have a non-zero size, but it occupies no space in the file.
sh_link This member holds a section header table index link, whose interpretation depends
on the section type. A table below describes the values.

sh_info This member holds extra information, whose interpretation depends on the section type. 
A table below describes the values.
sh_addralign Some sections have address alignment constraints. For example, if a section holds a
doubleword, the system must ensure doubleword alignment for the entire section.
That is, the value of sh_addr must be congruent to 0, modulo the value of
sh_addralign. Currently, only 0 and positive integral powers of two are allowed.
Values 0 and 1 mean the section has no alignment constraints.
sh_entsize Some sections hold a table of fixed-size entries, such as a symbol table. For such a section,
this member gives the size in bytes of each entry. The member contains 0 if the
section does not hold a table of fixed-size entries.
A section header's sh_type member specifies the section's semantics.
Figure 1-10: Section Types, sh_type
Name Value _ _____________________________
SHT_NULL 0
SHT_PROGBITS 1
SHT_SYMTAB 2
SHT_STRTAB 3
SHT_RELA 4
SHT_HASH 5
SHT_DYNAMIC 6
SHT_NOTE 7
SHT_NOBITS 8
SHT_REL 9
SHT_SHLIB 10
SHT_DYNSYM 11
SHT_LOPROC 0x70000000
SHT_HIPROC 0x7fffffff
SHT_LOUSER 0x80000000
SHT_HIUSER 0xffffffff _ _____________________________ . . . . . . . . . . . . . . . . . . . .
SHT_NULL This value marks the section header as inactive; it does not have an associated section.
Other members of the section header have undefined values.
SHT_PROGBITS The section holds information defined by the program, whose format and meaning are
determined solely by the program.
SHT_SYMTAB and SHT_DYNSYM
These sections hold a symbol table. Currently, an object file may have only one section
of each type, but this restriction may be relaxed in the future. Typically,
SHT_SYMTAB provides symbols for link editing, though it may also be used for
dynamic linking. As a complete symbol table, it may contain many symbols unnecessary
for dynamic linking. Consequently, an object file may also contain a
SHT_DYNSYM section, which holds a minimal set of dynamic linking symbols, to save
space. See "Symbol Table" below for details.

SHT_STRTAB The section holds a string table. An object file may have multiple string table sections.
See "String Table" below for details.
SHT_RELA The section holds relocation entries with explicit addends, such as type Elf32_Rela
for the 32-bit class of object files. An object file may have multiple relocation sections.
See "Relocation" below for details.
SHT_HASH The section holds a symbol hash table. All objects participating in dynamic linking
must contain a symbol hash table. Currently, an object file may have only one hash
table, but this restriction may be relaxed in the future. See "Hash Table" in Part 2 for
details.
SHT_DYNAMIC The section holds information for dynamic linking. Currently, an object file may have
only one dynamic section, but this restriction may be relaxed in the future. See
"Dynamic Section" in Part 2 for details.
SHT_NOTE The section holds information that marks the file in some way. See "Note Section" in
Part 2 for details.
SHT_NOBITS A section of this type occupies no space in the file but otherwise resembles
SHT_PROGBITS. Although this section contains no bytes, the sh_offset member
contains the conceptual file offset.
SHT_REL The section holds relocation entries without explicit addends, such as type
Elf32_Rel for the 32-bit class of object files. An object file may have multiple relocation
sections. See "Relocation" below for details.
SHT_SHLIB This section type is reserved but has unspecified semantics. Programs that contain a
section of this type do not conform to the ABI.
SHT_LOPROC through SHT_HIPROC
Values in this inclusive range are reserved for processor-specific semantics.
SHT_LOUSER This value specifies the lower bound of the range of indexes reserved for application
programs.
SHT_HIUSER This value specifies the upper bound of the range of indexes reserved for application
programs. Section types between SHT_LOUSER and SHT_HIUSER may be used by
the application, without conflicting with current or future system-defined section
types.
Other section type values are reserved. As mentioned before, the section header for index 0
(SHN_UNDEF) exists, even though the index marks undefined section references. This entry holds the following.
Figure 1-11: Section Header Table Entry: Index 0
Name Value Note _ _____________________________________________________
sh_name 0 No name
sh_type SHT_NULL Inactive
sh_flags 0 No flags
sh_addr 0 No address
sh_offset 0 No file offset
sh_size 0 No size .. . . . . . .
.. . . . . . .

Figure 1-11: Section Header Table Entry: Index 0 (continued )
sh_link SHN_UNDEF No link information
sh_info 0 No auxiliary information
sh_addralign 0 No alignment
sh_entsize 0 No entries _ _____________________________________________________ .. . . . .
.. . . . .
A section header's sh_flags member holds 1-bit flags that describe the section's attributes. Defined
values appear below; other values are reserved.
Figure 1-12: Section Attribute Flags, sh_flags
Name Value _ ______________________________
SHF_WRITE 0x1
SHF_ALLOC 0x2
SHF_EXECINSTR 0x4
SHF_MASKPROC 0xf0000000 _ ______________________________ . . . . . .
If a flag bit is set in sh_flags, the attribute is "on" for the section. Otherwise, the attribute is "off" or
does not apply. Undefined attributes are set to zero.
SHF_WRITE The section contains data that should be writable during process execution.
SHF_ALLOC The section occupies memory during process execution. Some control sections do
not reside in the memory image of an object file; this attribute is off for those sections.
SHF_EXECINSTR The section contains executable machine instructions.
SHF_MASKPROC All bits included in this mask are reserved for processor-specific semantics.
Two members in the section header, sh_link and sh_info, hold special information, depending on
section type.

Figure 1-13: sh_link and sh_info Interpretation
sh_type sh_link sh_info _ _____________________________________________________________________
The section header index of
the string table used by
entries in the section.
SHT_DYNAMIC 0
_ _____________________________________________________________________
The section header index of
the symbol table to which
the hash table applies.
SHT_HASH 0
_ _____________________________________________________________________
SHT_REL
SHT_RELA
The section header index of
the associated symbol table.
The section header index of
the section to which the
relocation applies. _ _____________________________________________________________________
SHT_SYMTAB
SHT_DYNSYM
The section header index of
the associated string table.
One greater than the symbol
table index of the last
local symbol (binding
STB_LOCAL). _ _____________________________________________________________________
other SHN_UNDEF 0 _ _____________________________________________________________________ . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . .
Special Sections
Various sections hold program and control information. Sections in the list below are used by the system
and have the indicated types and attributes.
Figure 1-14: Special Sections
Name Type Attributes _ ___________________________________________________________
.bss SHT_NOBITS SHF_ALLOC + SHF_WRITE
.comment SHT_PROGBITS none
.data SHT_PROGBITS SHF_ALLOC + SHF_WRITE
.data1 SHT_PROGBITS SHF_ALLOC + SHF_WRITE
.debug SHT_PROGBITS none
.dynamic SHT_DYNAMIC see below
.dynstr SHT_STRTAB SHF_ALLOC
.dynsym SHT_DYNSYM SHF_ALLOC
.fini SHT_PROGBITS SHF_ALLOC + SHF_EXECINSTR
.got SHT_PROGBITS see below
.hash SHT_HASH SHF_ALLOC
.init SHT_PROGBITS SHF_ALLOC + SHF_EXECINSTR
.interp SHT_PROGBITS see below
.line SHT_PROGBITS none
.note SHT_NOTE none
.plt SHT_PROGBITS see below
.relname SHT_REL see below . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . .

Figure 1-14: Special Sections (continued )
.relaname SHT_RELA see below
.rodata SHT_PROGBITS SHF_ALLOC
.rodata1 SHT_PROGBITS SHF_ALLOC
.shstrtab SHT_STRTAB none
.strtab SHT_STRTAB see below
.symtab SHT_SYMTAB see below
.text SHT_PROGBITS SHF_ALLOC + SHF_EXECINSTR _ ___________________________________________________________ . . . . . . . . .
. . . . . . . . .
.bss This section holds uninitialized data that contribute to the program's memory image. By
definition, the system initializes the data with zeros when the program begins to run. The
section occupies no file space, as indicated by the section type, SHT_NOBITS.
.comment This section holds version control information.
.data and .data1
These sections hold initialized data that contribute to the program's memory image.
.debug This section holds information for symbolic debugging. The contents are unspecified.
.dynamic This section holds dynamic linking information. The section's attributes will include the
SHF_ALLOC bit. Whether the SHF_WRITE bit is set is processor specific. See Part 2 for
more information.
.dynstr This section holds strings needed for dynamic linking, most commonly the strings that
represent the names associated with symbol table entries. See Part 2 for more information.
.dynsym This section holds the dynamic linking symbol table, as "Symbol Table" describes. See
Part 2 for more information.
.fini This section holds executable instructions that contribute to the process termination code.
That is, when a program exits normally, the system arranges to execute the code in this
section.
.got This section holds the global offset table. See "Special Sections" in Part 1 and "Global
Offset Table" in Part 2 for more information.
.hash This section holds a symbol hash table. See "Hash Table" in Part 2 for more information.
.init This section holds executable instructions that contribute to the process initialization code.
That is, when a program starts to run, the system arranges to execute the code in this section
before calling the main program entry point (called main for C programs).
.interp This section holds the path name of a program interpreter. If the file has a loadable segment
that includes the section, the section's attributes will include the SHF_ALLOC bit; otherwise,
that bit will be off. See Part 2 for more information.
.line This section holds line number information for symbolic debugging, which describes the
correspondence between the source program and the machine code. The contents are
unspecified.

.note This section holds information in the format that "Note Section" in Part 2 describes.
.plt This section holds the procedure linkage table. See "Special Sections" in Part 1 and "Procedure
Linkage Table" in Part 2 for more information.
.relname and .relaname
These sections hold relocation information, as "Relocation" below describes. If the file has
a loadable segment that includes relocation, the sections' attributes will include the
SHF_ALLOC bit; otherwise, that bit will be off. Conventionally, name is supplied by the
section to which the relocations apply. Thus a relocation section for .text normally
would have the name .rel.text or .rela.text.
.rodata and .rodata1
These sections hold read-only data that typically contribute to a non-writable segment in
the process image. See "Program Header" in Part 2 for more information.
.shstrtab This section holds section names.
.strtab This section holds strings, most commonly the strings that represent the names associated
with symbol table entries. If the file has a loadable segment that includes the symbol string
table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.
.symtab This section holds a symbol table, as "Symbol Table" in this section describes. If the file
has a loadable segment that includes the symbol table, the section's attributes will include
the SHF_ALLOC bit; otherwise, that bit will be off.
.text This section holds the "text," or executable instructions, of a program.
Section names with a dot (.) prefix are reserved for the system, although applications may use these sections
if their existing meanings are satisfactory. Applications may use names without the prefix to avoid
conflicts with system sections. The object file format lets one define sections not in the list above. An
object file may have more than one section with the same name.
Section names reserved for a processor architecture are formed by placing an abbreviation of the architecture
name ahead of the section name. The name should be taken from the architecture names used for
e_machine. For instance .FOO.psect is the psect section defined by the FOO architecture. Existing
extensions are called by their historical names.
Pre-existing Extensions _ _______________________
.sdata .tdesc
.sbss .lit4
.lit8 .reginfo
.gptab .liblist
.conflict

String Table
String table sections hold null-terminated character sequences, commonly called strings. The object file
uses these strings to represent symbol and section names. One references a string as an index into the
string table section. The first byte, which is index zero, is defined to hold a null character. Likewise, a
string table's last byte is defined to hold a null character, ensuring null termination for all strings. A
string whose index is zero specifies either no name or a null name, depending on the context. An empty
string table section is permitted; its section header's sh_size member would contain zero. Non-zero
indexes are invalid for an empty string table.
A section header's sh_name member holds an index into the section header string table section, as designated
by the e_shstrndx member of the ELF header. The following figures show a string table with 25
bytes and the strings associated with various indexes.
Index + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 ______________________________________________________
0       \0  n   a   m   e   .   \0  V   a   r ______________________________________________________
10      i   a   b   l   e   \0  a   b   l   e ______________________________________________________
20      \0  \0  x   x   \0 ______________________________________________________ .. . . .
.. . . .
.. . . .
Figure 1-15: String Table Indexes
Index String _ _________________
0 none
1 name.
7 Variable
11 able
16 able
24 null string _ _________________ . . . . . . . .
As the example shows, a string table index may refer to any byte in the section. A string may appear
more than once; references to substrings may exist; and a single string may be referenced multiple times.
Unreferenced strings also are allowed.

Symbol Table
An object file's symbol table holds information needed to locate and relocate a program's symbolic
definitions and references. A symbol table index is a subscript into this array. Index 0 both designates
the first entry in the table and serves as the undefined symbol index. The contents of the initial entry are
specified later in this section.
Name Value ___________________
STN_UNDEF 0 ___________________ . .
A symbol table entry has the following format.
Figure 1-16: Symbol Table Entry
typedefstruct {
UINT32 st_name;
UINT32 st_value;
UINT32 st_size;
unsignedchar st_info;
unsignedchar st_other;
UINT16 st_shndx;
} Elf32_Sym;
st_name This member holds an index into the object file's symbol string table, which holds the
character representations of the symbol names. If the value is non-zero, it represents a
string table index that gives the symbol name. Otherwise, the symbol table entry has no
name.
NOTE
External C symbols have the same names in C and object files' symbol tables.
st_value This member gives the value of the associated symbol. Depending on the context, this
may be an absolute value, an address, etc.; details appear below.
st_size Many symbols have associated sizes. For example, a data object's size is the number of
bytes contained in the object. This member holds 0 if the symbol has no size or an
unknown size.
st_info This member specifies the symbol's type and binding attributes. A list of the values and
meanings appears below. The following code shows how to manipulate the values.
#define ELF32_ST_BIND ( i ) ( ( i ) > > 4 )
#define ELF32_ST_TYPE ( i ) ( ( i ) & 0 x f )
#define ELF32_ST_INFO ( b , t ) ( ( ( b ) < < 4 ) + ( ( t ) & 0 x f ) )

st_other This member currently holds 0 and has no defined meaning.
st_shndx Every symbol table entry is "defined" in relation to some section; this member holds the
relevant section header table index. As Figure 1-7 and the related text describe, some
section indexes indicate special meanings.
A symbol's binding determines the linkage visibility and behavior.
Figure 1-17: Symbol Binding, ELF32_ST_BIND
Name Value _ ____________________
STB_LOCAL 0
STB_GLOBAL 1
STB_WEAK 2
STB_LOPROC 13
STB_HIPROC 15 _ ____________________ . . . . . . .
STB_LOCAL Local symbols are not visible outside the object file containing their definition. Local
symbols of the same name may exist in multiple files without interfering with each
other.
STB_GLOBAL Global symbols are visible to all object files being combined. One file's definition of a
global symbol will satisfy another file's undefined reference to the same global symbol.
STB_WEAK Weak symbols resemble global symbols, but their definitions have lower precedence.
STB_LOPROC through STB_HIPROC
Values in this inclusive range are reserved for processor-specific semantics.
Global and weak symbols differ in two major ways.
When the link editor combines several relocatable object files, it does not allow multiple definitions
of STB_GLOBAL symbols with the same name. On the other hand, if a defined global symbol
exists, the appearance of a weak symbol with the same name will not cause an error. The link editor
honors the global definition and ignores the weak ones. Similarly, if a common symbol exists
(i.e., a symbol whose st_shndx field holds SHN_COMMON), the appearance of a weak symbol with
the same name will not cause an error. The link editor honors the common definition and ignores
the weak ones.
When the link editor searches archive libraries, it extracts archive members that contain definitions
of undefined global symbols. The member's definition may be either a global or a weak symbol.
The link editor does not extract archive members to resolve undefined weak symbols. Unresolved
weak symbols have a zero value.
In each symbol table, all symbols with STB_LOCAL binding precede the weak and global symbols. As
"Sections" above describes, a symbol table section's sh_info section header member holds the symbol				<<< DEV
table index for the first non-local symbol.

A symbol's type provides a general classification for the associated entity.
Figure 1-18: Symbol Types, ELF32_ST_TYPE
Name Value _ _____________________
STT_NOTYPE 0
STT_OBJECT 1
STT_FUNC 2
STT_SECTION 3
STT_FILE 4
STT_LOPROC 13
STT_HIPROC 15 _ _____________________ . . . . . . . . .
STT_NOTYPE The symbol's type is not specified.
STT_OBJECT The symbol is associated with a data object, such as a variable, an array, etc.
STT_FUNC The symbol is associated with a function or other executable code.
STT_SECTION The symbol is associated with a section. Symbol table entries of this type exist primarily
for relocation and normally have STB_LOCAL binding.
STT_FILE Conventionally, the symbol's name gives the name of the source file associated with the
object file. A file symbol has STB_LOCAL binding, its section index is SHN_ABS, and it
precedes the other STB_LOCAL symbols for the file, if it is present.
STT_LOPROC through STT_HIPROC
Values in this inclusive range are reserved for processor-specific semantics.
Function symbols (those with type STT_FUNC) in shared object files have special significance. When
another object file references a function from a shared object, the link editor automatically creates a procedure
linkage table entry for the referenced symbol. Shared object symbols with types other than
STT_FUNC will not be referenced automatically through the procedure linkage table.
If a symbol's value refers to a specific location within a section, its section index member, st_shndx,
holds an index into the section header table. As the section moves during relocation, the symbol's value
changes as well, and references to the symbol continue to "point" to the same location in the program.
Some special section index values give other semantics.
SHN_ABS The symbol has an absolute value that will not change because of relocation.
SHN_COMMON The symbol labels a common block that has not yet been allocated. The symbol's value
gives alignment constraints, similar to a section's sh_addralign member. That is, the
link editor will allocate the storage for the symbol at an address that is a multiple of
st_value. The symbol's size tells how many bytes are required.
SHN_UNDEF This section table index means the symbol is undefined. When the link editor combines
this object file with another that defines the indicated symbol, this file's references to the
symbol will be linked to the actual definition.

As mentioned above, the symbol table entry for index 0 (STN_UNDEF) is reserved; it holds the following.
Figure 1-19: Symbol Table Entry: Index 0
Name Value Note _ ______________________________________________
st_name 0 No name
st_value 0 Zero value
st_size 0 No size
st_info 0 No type, local binding
st_other 0
st_shndx SHN_UNDEF No section _ ______________________________________________ . . . . . . . .
. . . . . . . .
Symbol Values
Symbol table entries for different object file types have slightly different interpretations for the
st_value member.
In relocatable files, st_value holds alignment constraints for a symbol whose section index is
SHN_COMMON.
In relocatable files, st_value holds a section offset for a defined symbol. That is, st_value is an
offset from the beginning of the section that st_shndx identifies.
In executable and shared object files, st_value holds a virtual address. To make these files' symbols
more useful for the dynamic linker, the section offset (file interpretation) gives way to a virtual
address (memory interpretation) for which the section number is irrelevant.
Although the symbol table values have similar meanings for different object files, the data allow efficient
access by the appropriate programs.

Relocation
Relocation is the process of connecting symbolic references with symbolic definitions. For example, when
a program calls a function, the associated call instruction must transfer control to the proper destination
address at execution. In other words, relocatable files must have information that describes how to
modify their section contents, thus allowing executable and shared object files to hold the right information
for a process's program image. Relocation entries are these data.
Figure 1-20: Relocation Entries
typedefstruct {
UINT32 r_offset;
UINT32 r_info;
} Elf32_Rel;
typedefstruct {
UINT32 r_offset;
UINT32 r_info;
INT32 r_addend;
} Elf32_Rela;
r_offset This member gives the location at which to apply the relocation action. For a relocatable
file, the value is the byte offset from the beginning of the section to the storage unit affected
by the relocation. For an executable file or a shared object, the value is the virtual address of
the storage unit affected by the relocation.
r_info This member gives both the symbol table index with respect to which the relocation must be
made, and the type of relocation to apply. For example, a call instruction's relocation entry
would hold the symbol table index of the function being called. If the index is STN_UNDEF,
the undefined symbol index, the relocation uses 0 as the "symbol value." Relocation types
are processor-specific. When the text refers to a relocation entry's relocation type or symbol
table index, it means the result of applying ELF32_R_TYPE or ELF32_R_SYM, respectively,
to the entry's r_info member.
#define ELF32_R_SYM ( i ) ( ( i ) > > 8 )
#define ELF32_R_TYPE ( i ) ( ( unsignedchar ) ( i ) )
#define ELF32_R_INFO ( s , t ) ( ( ( s ) < < 8 ) + ( unsignedchar ) ( t ) )
r_addend This member specifies a constant addend used to compute the value to be stored into the
relocatable field.
As shown above, only Elf32_Rela entries contain an explicit addend. Entries of type Elf32_Rel store
an implicit addend in the location to be modified. Depending on the processor architecture, one form or
the other might be necessary or more convenient. Consequently, an implementation for a particular
machine may use one form exclusively or either form depending on context.

A relocation section references two other sections: a symbol table and a section to modify. The section
header's sh_info and sh_link members, described in "Sections" above, specify these relationships.
Relocation entries for different object files have slightly different interpretations for the r_offset
member.
In relocatable files, r_offset holds a section offset. That is, the relocation section itself describes
how to modify another section in the file; relocation offsets designate a storage unit within the
second section.
In executable and shared object files, r_offset holds a virtual address. To make these files' relocation
entries more useful for the dynamic linker, the section offset (file interpretation) gives way to
a virtual address (memory interpretation).
Although the interpretation of r_offset changes for different object files to allow efficient access by the
relevant programs, the relocation types' meanings stay the same.
Relocation Types
Relocation entries describe how to alter the following instruction and data fields (bit numbers appear in
the lower box corners).
Figure 1-21: Relocatable Fields
word32
31 0
word32 This specifies a 32-bit field occupying 4 bytes with arbitrary byte alignment. These values use
the same byte order as other word values in the 32-bit Intel Architecture.
01
3
31
02
2
03
1
04
0
0
0x01020304
Calculations below assume the actions are transforming a relocatable file into either an executable or a
shared object file. Conceptually, the link editor merges one or more relocatable files to form the output.
It first decides how to combine and locate the input files, then updates the symbol values, and finally performs
the relocation. Relocations applied to executable or shared object files are similar and accomplish
the same result. Descriptions below use the following notation.
A This means the addend used to compute the value of the relocatable field.
B This means the base address at which a shared object has been loaded into memory during
execution. Generally, a shared object file is built with a 0 base virtual address, but the execution
address will be different.

G This means the offset into the global offset table at which the address of the relocation entry's
symbol will reside during execution. See "Global Offset Table" in Part 2 for more information.
GOT This means the address of the global offset table. See "Global Offset Table" in Part 2 for more
information.
L This means the place (section offset or address) of the procedure linkage table entry for a symbol.
A procedure linkage table entry redirects a function call to the proper destination. The
link editor builds the initial procedure linkage table, and the dynamic linker modifies the
entries during execution. See "Procedure Linkage Table" in Part 2 for more information.
P This means the place (section offset or address) of the storage unit being relocated (computed
using r_offset).
S This means the value of the symbol whose index resides in the relocation entry.
A relocation entry's r_offset value designates the offset or virtual address of the first byte of the
affected storage unit. The relocation type specifies which bits to change and how to calculate their values.
The SYSTEM V architecture uses only Elf32_Rel relocation entries, the field to be relocated holds the
addend. In all cases, the addend and the computed result use the same byte order.
Figure 1-22: Relocation Types
Name Value Field Calculation _ __________________________________________________
R_386_NONE 0 none none
R_386_32 1 word32 S + A
R_386_PC32 2 word32 S + A - P
R_386_GOT32 3 word32 G + A - P
R_386_PLT32 4 word32 L + A - P
R_386_COPY 5 none none
R_386_GLOB_DAT 6 word32 S
R_386_JMP_SLOT 7 word32 S
R_386_RELATIVE 8 word32 B + A
R_386_GOTOFF 9 word32 S + A - GOT
R_386_GOTPC 10 word32 GOT + A - P _ __________________________________________________ . . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
Some relocation types have semantics beyond simple calculation.
R_386_GOT32 This relocation type computes the distance from the base of the global offset
table to the symbol's global offset table entry. It additionally instructs the link
editor to build a global offset table.
R_386_PLT32 This relocation type computes the address of the symbol's procedure linkage
table entry and additionally instructs the link editor to build a procedure linkage
table.
R_386_COPY The link editor creates this relocation type for dynamic linking. Its offset
member refers to a location in a writable segment. The symbol table index
specifies a symbol that should exist both in the current object file and in a shared
object. During execution, the dynamic linker copies data associated with the
shared object's symbol to the location specified by the offset.

R_386_GLOB_DAT This relocation type is used to set a global offset table entry to the address of the
specified symbol. The special relocation type allows one to determine the
correspondence between symbols and global offset table entries.
R_3862_JMP_SLOT The link editor creates this relocation type for dynamic linking. Its offset
member gives the location of a procedure linkage table entry. The dynamic
linker modifies the procedure linkage table entry to transfer control to the designated
symbol's address [see "Procedure Linkage Table" in Part 2].
R_386_RELATIVE The link editor creates this relocation type for dynamic linking. Its offset
member gives a location within a shared object that contains a value representing
a relative address. The dynamic linker computes the corresponding virtual
address by adding the virtual address at which the shared object was loaded to
the relative address. Relocation entries for this type must specify 0 for the symbol
table index.
R_386_GOTOFF This relocation type computes the difference between a symbol's value and the
address of the global offset table. It additionally instructs the link editor to build
the global offset table.
R_386_GOTPC This relocation type resembles R_386_PC32, except it uses the address of the
global offset table in its calculation. The symbol referenced in this relocation
normally is _GLOBAL_OFFSET_TABLE_, which additionally instructs the link
editor to build the global offset table.

--*/

function is_ELF_data(atom v)
integer dsi
atom vaddr
integer vsize
    for i=1 to length(sDataSegments) do
        dsi = sDataSegments[i]
        vaddr = p_vaddrs[dsi]
        vsize = p_fileszs[dsi]
        if v>=vaddr and v<=vaddr+vsize then
            return True
        end if
    end for
    return False
end function

function is_ELF_code(atom v)
integer dsi
atom vaddr
integer vsize
    for i=1 to length(sCodeSegments) do
        dsi = sCodeSegments[i]
--      vaddr = p_vaddrs[dsi]
        vaddr = iff(dsi>0?p_vaddrs[dsi]:shaddrs[-dsi])
--      vsize = p_fileszs[dsi]
        vsize = iff(dsi>0?p_fileszs[dsi]:shsizes[-dsi])
        if v>=vaddr and v<=vaddr+vsize then
            return True
        end if
    end for
    return False
end function

-- (more EF_ARM_XXX values can be found in arwendemo\elf.h & elf-llvm.h)
constant EF_ARM_SET = {{0x02,"EF_ARM_HASENTRY"}}

function decode_ELF()
--
-- Note that Phix only creates segments (program header table) not sections (linker info);
--  what little section header table entry handling is here was written before I realised
--  that, and is lightly tested, probably incomplete and unlikely to ever be extended.
--
-- See cwgtLinux.txt (from mpeforth) for an excellent introduction to low-level elf.
--
string ei_magic
integer ei_class
string desc
integer ei_data
integer ei_version
integer ei_osabi
integer ei_abiversion
integer e_type
integer e_machine
integer supported
integer e_version
--integer e_entry
atom e_entry
integer e_phoff
integer e_shoff
integer e_flags
integer ABIversion
integer e_ehsize
integer e_phentsize
integer e_phnum
integer e_shentsize
integer e_shnum
integer e_shstrndx
integer n
atom p_type
sequence codesegments

    elfv = {}
--  elfv = append(elfv,{"full file",0,file_size})   -- temp/test
    NotPhixMessages = {}
    SetTabIdx("ELF Header")
    ei_magic = decode("ei_magic","x4","ELF signature")                              -- 0x7F&"ELF"
    if ei_magic!="0x7F&\"ELF\"" then
        return resetTabs()
    end if
    ei_class = decode("ei_class",1,"")
    if ei_class=1 then
        desc = "32 bit"
        machine = 32
    elsif ei_class=2 then
        desc = "64 bit"
        machine = 64
    else
        return fatal("unknown architecture")
    end if
    res[tabidx][$][R_NOTES] = desc
    ei_data = decode("ei_data",1,"")
    if    ei_data=1 then    desc = "little endian"
    elsif ei_data=2 then    desc = "big endian"
    else return fatal("unknown data encoding")
    end if
    res[tabidx][$][R_NOTES] = desc
    ei_version = decode("ei_version",1,"")
    if ei_version=1 then
        desc = "current"
    else
        return fatal("unknown version")
    end if
    res[tabidx][$][R_NOTES] = desc
    ei_osabi = decode("ei_osabi",1,"")
    if    ei_osabi=0 then       desc = "System V"
    elsif ei_osabi=1 then       desc = "HP-UX"
    elsif ei_osabi=2 then       desc = "Linux"
    elsif ei_osabi=3 then       desc = "NetBSD"
    elsif ei_osabi=4 then       desc = "GNU/Hurd"
    elsif ei_osabi=5 then       desc = "86Open Common IA32 ABI"
    elsif ei_osabi=6 then       desc = "Solaris"
    elsif ei_osabi=7 then       desc = "Monterey"
    elsif ei_osabi=8 then       desc = "IRIX"
    elsif ei_osabi=9 then       desc = "FreeBSD"
    elsif ei_osabi=10 then      desc = "TRU64 Unix"
    elsif ei_osabi=11 then      desc = "Novel Modesto"
    elsif ei_osabi=12 then      desc = "OpenBSD"
    elsif ei_osabi=0x61 then    desc = "ARM"
    elsif ei_osabi=0xff then    desc = "standalone"
    else return fatal("unknown os abi")
    end if
    res[tabidx][$][R_NOTES] = desc
    ei_abiversion = decode("ei_abiversion",1,"")
    void = decode("ei_pad","h2","")
    void = decode("ei_pad","h2","")
    void = decode("ei_pad","h2","")
    -- not entirely convinced this is right (0 seems fine):
    void = decode("ei_size","h1","")
    e_type = decode("e_type",2,"")
    supported = 0
    if    e_type=0 then     desc = "No file type"
    elsif e_type=1 then     desc = "Relocatable file"
        --dev: (gets us further on the .o, but there are only sections not segments in the file...)
        supported = 1
    elsif e_type=2 then     desc = "Executable file"                supported = 1
    elsif e_type=3 then     desc = "Shared object file"             supported = 1
    elsif e_type=4 then     desc = "Core file"
--  elsif e_type>=0xff00
--    and e_type<=0xffff then
--      desc = "Processor-specific"
    else return fatal("unknown object file type")
    end if
    res[tabidx][$][R_NOTES] = desc
    if not supported then return fatal("unsupported file type") end if
    e_machine = decode("e_machine",2,"")
    --
    -- Quite ridiculuous really, I suppose, that I have bothered to transcribe each and every machine
    --  that I could find (mainly elf.h files), when the only one, apart from 386, I would ever even 
    --  vaguely (very vaguely) consider supporting is ARM.. Mind you, that does not stop you, does it?
    --
    supported = 0
    if    e_machine=0 then      desc = "No machine"                                                 -- EM_NONE
    elsif e_machine=1 then      desc = "AT&T WE 32100"                                              -- EM_M32
    elsif e_machine=2 then      desc = "SPARC"                                                      -- EM_SPARC
    elsif e_machine=3 then      desc = "Intel 386"                  supported = 1                   -- EM_386
    elsif e_machine=4 then      desc = "Motorola 68000"                                             -- EM_68K
    elsif e_machine=5 then      desc = "Motorola 88000"                                             -- EM_88K
    elsif e_machine=6 then      desc = "Intel 80486 (deprecated)"                                   -- EM_486
    elsif e_machine=7 then      desc = "intel 80860"                                                -- EM_860
    elsif e_machine=8 then      desc = "MIPS RS3000 Big-Endian"                                     -- EM_MIPS
    elsif e_machine=9 then      desc = "Amdahl"                                                     -- EM_S370          -- IBM System/370
    elsif e_machine=10 then     desc = "MIPS RS4000 Big-Endian"                                     -- EM_MIPS_RS4_BE   -- EM_MIPS_RS3_LE = 10, // MIPS RS3000 Little-endian
    elsif e_machine=11 then     desc = "RS6000"                                                     -- EM_RS6000
    elsif e_machine=15 then     desc = "Hewlett-Packard PA-RISC"                                    -- EM_PARISC        -- HPPA
    elsif e_machine=16 then     desc = "nCUBE"                                                      -- EM_nCUBE
    elsif e_machine=17 then     desc = "Fujitsu VPP500"                                             -- EM_VPP500
    elsif e_machine=18 then     desc = "Sun's \"v8plus\""                                           -- EM_SPARC32PLUS   -- Enhanced instruction set SPARC
    elsif e_machine=19 then     desc = "Intel 80960"                                                -- EM_960
    elsif e_machine=20 then     desc = "PowerPC"                                                    -- EM_PPC
    elsif e_machine=21 then     desc = "64-bit PowerPC"                                             -- EM_PPC64
    elsif e_machine=22 then     desc = "IBM System/390"                                             -- EM_S390
    elsif e_machine=23 then     desc = "IBM SPU/SPC"                                                -- EM_SPU
    elsif e_machine=36 then     desc = "NEC V800 series"                                            -- EM_V800
    elsif e_machine=37 then     desc = "Fujitsu FR20"                                               -- EM_FR20
    elsif e_machine=38 then     desc = "TRW RH32"                                                   -- EM_RH32
    elsif e_machine=39 then     desc = "Motorola M*core"                                            -- EM_MMA   -- EM_RCE = 39, // Motorola RCE, -- Fujitsu MMA
    elsif e_machine=40 then     desc = "ARM"                        supported = -1                  -- EM_ARM
    elsif e_machine=41 then     desc = "Digital Alpha"                                              -- EM_FAKE_ALPHA    -- DEC Alpha
    elsif e_machine=42 then     desc = "Hitachi SH"                                                 -- EM_SH
    elsif e_machine=43 then     desc = "SPARC v9 64-bit"                                            -- EM_SPARCV9
    elsif e_machine=44 then     desc = "Siemens Tricore embedded processor"                         -- EM_TRICORE
    elsif e_machine=45 then     desc = "Argonaut RISC Core"                                         -- EM_ARC
    elsif e_machine=46 then     desc = "Hitachi H8/300"                                             -- EM_H8_300
    elsif e_machine=47 then     desc = "Hitachi H8/300H"                                            -- EM_H8_300H
    elsif e_machine=48 then     desc = "Hitachi H8S"                                                -- EM_H8S
    elsif e_machine=49 then     desc = "Hitachi H8/500"                                             -- EM_H8_500
    elsif e_machine=50 then     desc = "Intel IA-64 Processor"                                      -- EM_IA_64         -- Intel Merced
    elsif e_machine=51 then     desc = "Stanford MIPS-X"                                            -- EM_MIPS_X
    elsif e_machine=52 then     desc = "Motorola Coldfire"                                          -- EM_COLDFIRE
    elsif e_machine=53 then     desc = "Motorola M68HC12"                                           -- EM_68HC12
    elsif e_machine=54 then     desc = "Fujitsu Multimedia Accelerator"                             -- EM_MMA
    elsif e_machine=55 then     desc = "Siemens PCP"                                                -- EM_PCP
    elsif e_machine=56 then     desc = "Sony nCPU embedded RISC processor"                          -- EM_NCPU
    elsif e_machine=57 then     desc = "Denso NDR1 microprocessor"                                  -- EM_NDR1
    elsif e_machine=58 then     desc = "Motorola Star*Core processor"                               -- EM_STARCORE
    elsif e_machine=59 then     desc = "Toyota ME16 processor"                                      -- EM_ME16
    elsif e_machine=60 then     desc = "STMicroelectronics ST100 processor"                         -- EM_ST100
    elsif e_machine=61 then     desc = "Advanced Logic Corp. TinyJ embedded processor"              -- EM_TINYJ
--  elsif e_machine=62 then     desc = "x86-64 (AMD Opteron)"       supported = 1                   -- EM_X86_64
    elsif e_machine=62 then     desc = "x86-64"                     supported = 1                   -- EM_X86_64
    elsif e_machine=63 then     desc = "Sony DSP Processor"                                         -- EM_PDSP
    elsif e_machine=64 then     desc = "Digital Equipment Corp. PDP-10"                             -- EM_PDP10
    elsif e_machine=65 then     desc = "Digital Equipment Corp. PDP-11"                             -- EM_PDP11
    elsif e_machine=66 then     desc = "Siemens FX66 microcontroller"                               -- EM_FX66
    elsif e_machine=67 then     desc = "STMicroelectromnics ST9+ 8/16 bit microcontroller"          -- EM_ST9PLUS
    elsif e_machine=68 then     desc = "STMicroelectromnics ST7 8-bit microcontroller"              -- EM_ST7
    elsif e_machine=69 then     desc = "Motorola MC68HC16 Microcontroller"                          -- EM_68HC16
    elsif e_machine=70 then     desc = "Motorola MC68HC11 Microcontroller"                          -- EM_68HC11
    elsif e_machine=71 then     desc = "Motorola MC68HC08 Microcontroller"                          -- EM_68HC08
    elsif e_machine=72 then     desc = "Motorola MC68HC05 Microcontroller"                          -- EM_68HC05
    elsif e_machine=73 then     desc = "Silicon Graphics SVx"                                       -- EM_SVX
    elsif e_machine=74 then     desc = "STMicroelectronics ST19 8-bit microcontroller"              -- EM_ST19
    elsif e_machine=75 then     desc = "Digital VAX"                                                -- EM_VAX
    elsif e_machine=76 then     desc = "Axis Communications 32-bit embedded processor"              -- EM_CRIS
    elsif e_machine=77 then     desc = "Infineon Technologies 32-bit embedded processor"            -- EM_JAVELIN
    elsif e_machine=78 then     desc = "Element 14 64-bit DSP Processor"                            -- EM_FIREPATH
    elsif e_machine=79 then     desc = "LSI Logic 16-bit DSP Processor"                             -- EM_ZSP
    elsif e_machine=80 then     desc = "Donald Knuth's educational 64-bit processor"                -- EM_MMIX
    elsif e_machine=81 then     desc = "Harvard University machine-independent object files"        -- EM_HUANY
    elsif e_machine=82 then     desc = "SiTera Prism"                                               -- EM_PRISM
    elsif e_machine=83 then     desc = "Atmel AVR 8-bit microcontroller"                            -- EM_AVR
    elsif e_machine=84 then     desc = "Fujitsu FR30"                                               -- EM_FR30
    elsif e_machine=85 then     desc = "Mitsubishi D10V"                                            -- EM_D10V
    elsif e_machine=86 then     desc = "Mitsubishi D30V"                                            -- EM_D30V
    elsif e_machine=87 then     desc = "NEC v850"                                                   -- EM_V850
    elsif e_machine=88 then     desc = "Mitsubishi M32R"                                            -- EM_M32R
    elsif e_machine=89 then     desc = "Matsushita MN10300"                                         -- EM_MN10300
    elsif e_machine=90 then     desc = "Matsushita MN10200"                                         -- EM_MN10200
    elsif e_machine=91 then     desc = "picoJava"                                                   -- EM_PJ
    elsif e_machine=92 then     desc = "OpenRISC 32-bit embedded processor"                         -- EM_OPENRISC
    elsif e_machine=93 then     desc = "ARC International ARCompact processor"                      -- EM_ARC_COMPACT (old spelling/synonym: EM_ARC_A5)
    elsif e_machine=94 then     desc = "Tensilica Xtensa Architecture"                              -- EM_XTENSA
    elsif e_machine=95 then     desc = "Alphamosaic VideoCore processor"                            -- EM_VIDEOCORE
    elsif e_machine=96 then     desc = "Thompson Multimedia General Purpose Processor"              -- EM_TMM_GPP
    elsif e_machine=97 then     desc = "National Semiconductor 32000 series"                        -- EM_NS32K
    elsif e_machine=98 then     desc = "Tenor Network TPC processor"                                -- EM_TPC
    elsif e_machine=99 then     desc = "Trebia SNP 1000 processor"                                  -- EM_SNP1K
    elsif e_machine=100 then    desc = "STMicroelectronics (www.st.com) ST200"                      -- EM_ST200
    elsif e_machine=101 then    desc = "Ubicom IP2xxx microcontroller family"                       -- EM_IP2K
    elsif e_machine=102 then    desc = "MAX Processor"                                              -- EM_MAX
    elsif e_machine=103 then    desc = "National Semiconductor CompactRISC microprocessor"          -- EM_CR
    elsif e_machine=104 then    desc = "Fujitsu F2MC16"                                             -- EM_F2MC16
    elsif e_machine=105 then    desc = "Texas Instruments embedded microcontroller msp430"          -- EM_MSP430
    elsif e_machine=106 then    desc = "Analog Devices Blackfin (DSP) processor"                    -- EM_BLACKFIN
    elsif e_machine=107 then    desc = "S1C33 Family of Seiko Epson processors"                     -- EM_SE_C33
    elsif e_machine=108 then    desc = "Sharp embedded microprocessor"                              -- EM_SEP
    elsif e_machine=109 then    desc = "Arca RISC Microprocessor"                                   -- EM_ARCA
    elsif e_machine=110 then    desc = "PKU-Unity Ltd. and MPRC of Peking University"               -- EM_UNICORE
    elsif e_machine=111 then    desc = "eXcess: 16/32/64-bit configurable embedded CPU"             -- EM_EXCESS
    elsif e_machine=112 then    desc = "Icera Semiconductor Inc. Deep Execution Processor"          -- EM_DXP
    elsif e_machine=113 then    desc = "Altera Nios II soft-core processor"                         -- EM_ALTERA_NIOS2
    elsif e_machine=114 then    desc = "National Semiconductor CompactRISC CRX"                     -- EM_CRX
    elsif e_machine=115 then    desc = "Motorola XGATE embedded processor"                          -- EM_XGATE
    elsif e_machine=116 then    desc = "Infineon C16x/XC16x processor"                              -- EM_C166
    elsif e_machine=117 then    desc = "Renesas M16C series microprocessors"                        -- EM_M16C
    elsif e_machine=118 then    desc = "Microchip Technology dsPIC30F Digital Signal Controller"    -- EM_DSPIC30F
    elsif e_machine=119 then    desc = "Freescale Communication Engine RISC core"                   -- EM_CE
    elsif e_machine=120 then    desc = "Renesas M32C series microprocessors"                        -- EM_M32C
    elsif e_machine=131 then    desc = "Altium TSK3000 core"                                        -- EM_TSK3000
    elsif e_machine=132 then    desc = "Freescale RS08 embedded processor"                          -- EM_RS08
    elsif e_machine=133 then    desc = "Analog Devices SHARC family of 32-bit DSP processors"       -- EM_SHARC
    elsif e_machine=134 then    desc = "Cyan Technology eCOG2 microprocessor"                       -- EM_ECOG2
    elsif e_machine=135 then    desc = "Sunplus S+core7 RISC processor"                             -- EM_SCORE7
    elsif e_machine=136 then    desc = "New Japan Radio (NJR) 24-bit DSP Processor"                 -- EM_DSP24
    elsif e_machine=137 then    desc = "Broadcom VideoCore III processor"                           -- EM_VIDEOCORE3
    elsif e_machine=138 then    desc = "RISC processor for Lattice FPGA architecture"               -- EM_LATTICEMICO32
    elsif e_machine=139 then    desc = "Seiko Epson C17 family"                                     -- EM_SE_C17
    elsif e_machine=140 then    desc = "The Texas Instruments TMS320C6000 DSP family"               -- EM_TI_C6000
    elsif e_machine=141 then    desc = "The Texas Instruments TMS320C2000 DSP family"               -- EM_TI_C2000
    elsif e_machine=142 then    desc = "The Texas Instruments TMS320C55x DSP family"                -- EM_TI_C5500
    elsif e_machine=160 then    desc = "STMicroelectronics 64bit VLIW Data Signal Processor"        -- EM_MMDSP_PLUS
    elsif e_machine=161 then    desc = "Cypress M8C microprocessor"                                 -- EM_CYPRESS_M8C
    elsif e_machine=162 then    desc = "Renesas R32C series microprocessors"                        -- EM_R32C
    elsif e_machine=163 then    desc = "NXP Semiconductors TriMedia architecture family"            -- EM_TRIMEDIA
    elsif e_machine=164 then    desc = "Qualcomm Hexagon processor"                                 -- EM_HEXAGON
    elsif e_machine=165 then    desc = "Intel 8051 and variants"                                    -- EM_8051
    elsif e_machine=166 then    desc = "STMicroelectronics STxP7x family"                           -- EM_STXP7X (of configurable and extensible RISC processors)
    elsif e_machine=167 then    desc = "Andes Technology compact code size embedded RISC"           -- EM_NDS32 (processor family)
    elsif e_machine=168 then    desc = "Cyan Technology eCOG1X family"                              -- EM_ECOG1/EM_ECOG1X
    elsif e_machine=169 then    desc = "Dallas Semiconductor MAXQ30 Core Micro-controllers"         -- EM_MAXQ30
    elsif e_machine=170 then    desc = "New Japan Radio (NJR) 16-bit DSP Processor"                 -- EM_XIMO16
    elsif e_machine=171 then    desc = "M2000 Reconfigurable RISC Microprocessor"                   -- EM_MANIK
    elsif e_machine=172 then    desc = "Cray Inc. NV2 vector architecture"                          -- EM_CRAYNV2
    elsif e_machine=173 then    desc = "Renesas RX family"                                          -- EM_RX
    elsif e_machine=174 then    desc = "Imagination Technologies META processor architecture"       -- EM_METAG
    elsif e_machine=175 then    desc = "MCST Elbrus general purpose hardware architecture"          -- EM_MCST_ELBRUS
    elsif e_machine=176 then    desc = "Cyan Technology eCOG16 family"                              -- EM_ECOG16
    elsif e_machine=177 then    desc = "National Semiconductor CompactRISC CR16 16-bit"             -- EM_CR16 (microprocessor)
    elsif e_machine=178 then    desc = "Freescale Extended Time Processing Unit"                    -- EM_ETPU
    elsif e_machine=179 then    desc = "Infineon Technologies SLE9X core"                           -- EM_SLE9X
    elsif e_machine=180 then    desc = "Intel L10M"                                                 -- EM_L10M
    elsif e_machine=181 then    desc = "Intel K10M"                                                 -- EM_K10M
    elsif e_machine=183 then    desc = "ARM AArch64"                                                -- EM_AARCH64
    elsif e_machine=185 then    desc = "Atmel Corporation 32-bit microprocessor family"             -- EM_AVR32
    elsif e_machine=186 then    desc = "STMicroeletronics STM8 8-bit microcontroller"               -- EM_STM8
    elsif e_machine=187 then    desc = "Tilera TILE64 multicore architecture family"                -- EM_TILE64
    elsif e_machine=188 then    desc = "Tilera TILEPro multicore architecture family"               -- EM_TILEPRO
    elsif e_machine=190 then    desc = "NVIDIA CUDA architecture"                                   -- EM_CUDA
    elsif e_machine=191 then    desc = "Tilera TILE-Gx multicore architecture family"               -- EM_TILEGX
    elsif e_machine=192 then    desc = "CloudShield architecture family"                            -- EM_CLOUDSHIELD
    elsif e_machine=193 then    desc = "KIPO-KAIST Core-A 1st generation processor family"          -- EM_COREA_1ST
    elsif e_machine=194 then    desc = "KIPO-KAIST Core-A 2nd generation processor family"          -- EM_COREA_2ND
    elsif e_machine=195 then    desc = "Synopsys ARCompact V2"                                      -- EM_ARC_COMPACT2
    elsif e_machine=196 then    desc = "Open8 8-bit RISC soft processor core"                       -- EM_OPEN8
    elsif e_machine=197 then    desc = "Renesas RL78 family"                                        -- EM_RL78
    elsif e_machine=198 then    desc = "Broadcom VideoCore V processor"                             -- EM_VIDEOCORE5
    elsif e_machine=199 then    desc = "Renesas 78KOR family"                                       -- EM_78KOR
    elsif e_machine=200 then    desc = "Freescale 56800EX Digital Signal Controller (DSC)"          -- EM_56800EX
    elsif e_machine=0x9026 then desc = "Alpha"                                                      -- EM_ALPHA
    else desc = "unknown machine type"
    end if
    res[tabidx][$][R_NOTES] = desc
    if supported=0 then return fatal("unsupported machine type") end if
    e_version = decode("e_version",4,"")
    if    e_version=0 then      desc = "no version(?)"
    elsif e_version=1 then      desc = "current"
    else return fatal("unknown version")
    end if
    res[tabidx][$][R_NOTES] = desc
    if machine=32 then
        e_entry = decode("e_entry","h4","")
--      if e_machine=40 then
        if e_machine=0x28 then  -- ARM
            if and_bits(e_entry,0b01)=0b01 then
                desc = "Thumb code"
            elsif and_bits(e_entry,0b11)=0b00 then
                desc = "ARM code"
            else -- 0b10
                return fatal("reserved")
            end if
            res[tabidx][$][R_NOTES] = desc
        end if
        e_phoff = decode("e_phoff","h4","program header table")
        e_shoff = decode("e_shoff","h4","section header table")
    elsif machine=64 then
        e_entry = decode("e_entry","h8","")
--      if e_machine=40 then
        if e_machine=0x28 then  -- ARM
            if and_bits(e_entry,0b01)=0b01 then
                desc = "Thumb code"
            elsif and_bits(e_entry,0b11)=0b00 then
                desc = "ARM code"
            else -- 0b10
                return fatal("reserved")
            end if
            res[tabidx][$][R_NOTES] = desc
        end if
        e_phoff = decode("e_phoff","h8","program header table")
        e_shoff = decode("e_shoff","h8","section header table")
    else
        ?9/0
    end if
    e_flags = decode("e_flags","h4","")
    if e_machine=0x28 then  -- ARM
        ABIversion = floor(e_flags/#1000000)
        e_flags = and_bits(e_flags,#00FFFFFF)
        res[tabidx][$][R_NOTES] = sprintf("ABI version %d, %s",{ABIversion,decode_flags(EF_ARM_SET,e_flags)})
    else
        if e_flags!=0 then
--          return fatal("e_flags should be 0") 
            res[tabidx][$][R_NOTES] = "*** ??? ***"
        end if
    end if
    e_ehsize = decode("e_ehsize","h2","ELF header size")
    --DEV will depend on ei_class?
    if machine=32 then
        if e_ehsize!=0x34 then return fatal("e_ehsize should be 0x34") end if
    elsif machine=64 then
        if e_ehsize!=0x40 then return fatal("e_ehsize should be 0x40") end if
    else
        ?9/0
    end if
    e_phentsize = decode("e_phentsize",2,"program header table entry size")
    e_phnum = decode("e_phnum",2,"number of program header entries")
    if e_phnum!=0 then
        if e_phoff=0 then return fatal("e_phoff is 0") end if
        if machine=32 then
            if e_phentsize!=32 then return fatal("e_phentsize should be 32") end if
        elsif machine=64 then
            if e_phentsize!=56 then return fatal("e_phentsize should be 56") end if
        else
            ?9/0
        end if
    end if
    e_shentsize = decode("e_shentsize",2,"section header entry size")
    e_shnum = decode("e_shnum",2,"number of section header entries")
    if e_shnum!=0 then
        if e_shoff=0 then return fatal("e_shoff is 0") end if
        if machine=32 then
            if e_shentsize!=40 then return fatal("e_shentsize should be 40") end if
--DEV nothing (yet) to test this on...
        elsif machine=64 then
            if e_shentsize!=64 then return fatal("e_shentsize should be 64") end if
        else
            ?9/0
        end if
    end if
    e_shstrndx = decode("e_shstrndx",2,"section name string table index")

    elfv = append(elfv,{"ELF Header",0,address})
--DEV
--  address = e_shoff + e_shentsize*e_shstrndx + 16
--  string_table = decode("string table","h4","")
    string_table = get_number(e_shoff+e_shentsize*e_shstrndx+16, 4)
--  desc = sprintf("%08x",string_table)
--  res[tabidx][$][R_NOTES] = desc
--  if e_phoff!=address then
--      -- if this triggers (often/for non-corrupt files), figure out how to deal with it:
--      return fatal("program header does not immediately follow")
--      -- it may just be: (!)
--  end if
--  if e_phoff>e_shoff then
--      return fatal("e_phoff>e_shoff not yet coded for...")
--  end if
--  n = e_phoff-address
--  if n then
--      void = decode("padding",n,"")
--  end if
--  if decode_ELF_program_headers(e_phnum,e_phentsize) then
    if e_phnum!=0 then
-- 1/12/14:
        address = e_phoff
        if decode_ELF_program_headers(e_phnum) then
--      if decode_ELF_program_headers(e_phoff, e_phnum, e_shoff, e_shnum) then
            if e_shnum!=0 then
                address = e_shoff
                if decode_ELF_section_headers(e_shnum) then
                    -- Phix does not create sections, so we anaylse no further
                end if
                sCodeSegments = {}
--?sCodeSegments
                sDataSegments = {}
--added 27/3/16 (otherwise decode_ELF_dynamic_segment() crashes)
            else
                shtypes = {}
            end if

            -- We are only interested in attempting deep analysis of
            --  Phix-generated ELF files
            if 00 then
                if e_shnum=0
                and p_types={PT_LOAD,PT_LOAD}           -- exactly 2 loadable sections,
                and p_flagss={PF_R+PF_X,PF_R+PF_W} then     -- one for code, one for data
--DEV min/max of PT_LOAD sections...
                    DSvaddr = p_vaddrs[2]
                    DSvsize = p_fileszs[2]
--DEV put this back... (if interpreter/supported=0 proves to be insufficient)
--if 0 then  NOW UNLIKELY TO EVER BE ENUF...
--              decode_ELF_code_segment(1,supported)
--              if not decode_ELF_data_segment(2) then return 0 end if
--end if
                end if
            else
                r_isdata = routine_id("is_ELF_data")
                r_iscode = routine_id("is_ELF_code")
            end if
            --DEV ... and remove this loop (once we start getting some Phix Elf to work)
            -- erm, **NO**, as we now have (or shortly will have) a dynamic segment...
            if 1 then
                codesegments = {}
--?p_types
                for i=1 to length(p_types) do
--DEV/SUG
-- log all memory adresses when dissassembling code segment (in order, duplicates removed),
-- and use them for a "smart dump" of the data segment.
                    p_type = p_types[i]
-- 1/12/14:
--                  if p_type=PT_LOAD then  -- loadable
                    if p_type=PT_LOAD and (e_shoff=0 or e_shnum=0) then
--DEV and machine = 386?
                        if p_flagss[i]=PF_R+PF_X
                        or p_flagss[i]=PF_R+PF_W+PF_X then  -- for fdbg
--                          decode_ELF_code_segment(i,supported)
                            decode_ELF_code_segment(i,1,supported)  -- (justsettab=1)
                            codesegments = append(codesegments,i)
--?{codesegments,sCodeSegments} --DEV...
                        elsif p_flagss[i]=PF_R+PF_W then
                            if not decode_ELF_data_segment(i) then return 0 end if
                        end if
                    elsif p_type=PT_DYNAMIC then -- Dynamic linking information
                        if not decode_ELF_dynamic_segment(i) then return 0 end if
                    elsif p_type=PT_INTERP then -- interpreter
--                      if not decode_ELF_data_segment(i) then return 0 end if
                        if not dump_ELF_interpreter(i) then return 0 end if
                        if e_shnum!=0 then
                            n = find(".interp",shdescs)
                            if n!=0 then
                                -- (Phix programs don't have section headers, btw)
                                set_seetab2("Interpreter",n,pstab)
                            end if
                        end if
--                  supported = 0
--DEV/SUG:
--                  else
--                      hex_dump(...)
                    end if
                end for
                if e_shnum!=0 then
                    -- (Phix programs don't have section headers, btw)
                    for i=1 to length(shdescs) do
                        desc = shdescs[i]
                        if desc=".dynsym" then
                            -- (Phix programs don't have section headers, btw)
                            set_seetab2("Symtab",i,pstab)
--DEV not thumb...
--IMAGE_SCN_MEM_16BIT?
                        elsif e_machine=0x28                        -- ARM
                          and supported=-1                          -- ARM
                          and and_bits(e_entry,0b11)=0b00           -- *NOT* Thumb
                          and shflags[i]=SHF_ALLOC+SHF_EXECINSTR then
                            if dump_ELF_arm(i,desc) then end if
-- 17/9/16: (experimental)
                        elsif find(desc,{
                                         ".plt",        --DEV code...
                                         ".text",       --DEV code...
                                        }) then
--DEV fixme: (pstab??}
                            set_seetab2(desc,i,pstab)
                            sCodeSegments = append(sCodeSegments,-i)
                            decode_ELF_code_segment(-i,1,supported) -- (justsettab=1)
                            codesegments = append(codesegments,-i)

--DEV all of the following, of course, deserve a full and detailed treatment instead of this quick and dirty binary dump...
                        elsif find(desc,{
                                         ".dynstr",
                                         ".rel.plt",
                                         ".plt",        --DEV code...
                                         ".text",       --DEV code...
                                         ".rodata",
                                         ".preinit_array",
                                         ".init_array",
                                         ".fini_array",
                                         ".ctors",
                                         ".got",
                                         ".comment",
                                         ".debug_aranges",
                                         ".debug_pubnames",
                                         ".debug_info",
                                         ".debug_abbrev",
                                         ".debug_line",
                                         ".debug_frame",
                                         ".debug_str",
                                         ".debug_loc",
                                         ".ARM.attributes",
                                         ".shstrtab",
                                         ".symtab",
                                         ".strtab"
                                        }) then
                            if dump_ELF_misc(i,desc) then end if
                        end if
                    end for
                end if
                for i=1 to length(codesegments) do
--1/12/14:
--?222
                    decode_ELF_code_segment(codesegments[i],0,supported)
--                  decode_ELF_code_segment(codesegments[i],0,supported,e_machine)
                end for
                r_isdata = -1
                r_iscode = -1
            end if
        end if
    end if
--1/12/14 moved into decode_ELF_program_headers...
    -- sections are only needed for linking (Phix-generated ELF files do 
    --  not have any sections; this was written before I decided on that)
    -- Update: arm elf files //need// sections, specifically symtab(!!!)
    --  to differentiate arm and thumb code, and it is .text, I think, 
    --  that we actually want to disassemble...
--  if e_shnum!=0 then
--      address = e_shoff
--      if decode_ELF_section_headers(e_shnum) then
--          -- Phix does not create sections, so we anaylse no further
--      end if
--  end if
    ShowNotPhix()
    return 1
end function

constant fdescs = {"key","inter","disposable","generated","info"}
constant cdescs = {"?? unknown ??","H263","screen","On2VP6","On2VP6a","screen2","AVC"}
constant fmtdescs = {"Linear PCMpe","ADPCM","MP3","Linear PCMle",
                     "Nellymoser16km","Nellymoser8km","Nellymoser",
                     "G711a","G711mu","reserved","AAC","Speex",
                     "MP38k","Device-specific"}
constant samplingrates = {"5.5kHz","11kHz","22kHz","44kHz"}
constant audiosizes = {"8-bit samples","16-bit samples"}
constant audiotypes = {"mono","stereo"}
constant scripttypes = {"Number","Boolean","String","Object","MovieClip","Null","Undefined",
                        "Reference","ECMA array","Object end marker","Strict array",
                        "Date","Long String"}

function decode_FLV()
--
-- This may not be of much use...
--
string signature
integer version
string desc
integer flags
integer hsize
atom lastpacket
integer packettype
integer filtered
integer payloadsize
integer timestamplower
integer timestampupper
integer streamID
integer ftc, frametype, codecid
string fdesc, cdesc, sdesc, zdesc, tdesc
integer frst, soundformat, soundrate, soundsize, soundtype
integer scripttype
integer valuesize
integer packetcount

--trace(1)
    SetTabIdx("FLV Header")
    signature = decode("signature","x3","FLV signature")                                -- "FLV"
    if signature!="FLV" then
        return resetTabs()
    end if
--Signature     byte[3] "FLV"   Always "FLV"
--Version uint8 1       Currently 0x01 is only valid
--Flags uint8 bitmask   0x05    Bitmask: 0x04 is audio, 0x01 is video (so 0x05 is audio+video)
--Header Size   uint32_be       9       Used to skip a newer expanded header
    version = decode("version",1,"should be 1")
    if version!=1 then
        return fatal("unknown version")
    end if
    flags = decode("flags",1,"")
    desc = decode_flags(FLVhFlagSet,flags)
    res[tabidx][$][R_NOTES] = desc
    asHex = 1
    hsize = decode("header size","h4","")
    asHex = 0
    if hsize!=9 then
        return fatal("9 expected")
    end if
--Start of Last Packet  uint32_be       0       For first packet set to NULL
--Packet Type           uint8           18      For first packet set to AMF Metadata
--Payload Size          uint24_be       varies  Size of packet data only
--Timestamp Lower       uint24_be       0       For first packet set to NULL
--Timestamp Upper       uint8           0       Extension to create a uint32_be value
--Stream ID             uint24_be       0       For first stream of same type set to NULL
--Payload Data          freeform        varies  Data as defined by packet type
    SetTabIdx("FLV Packets")

    packetcount = 0
    asHex = 1
    while address<file_size-15 do
        lastpacket = decode("last packet","h4","")
        if not integer(lastpacket) then
            asHex = 0
            return fatal("not integer(lastpacket)")
        end if
        if lastpacket!=0 then
            desc = sprintf("(at #%08x)",address-4-lastpacket)
            res[tabidx][$][R_NOTES] = desc
        end if
        packettype = decode("packet type","h1","")
        filtered = and_bits(packettype,#20)
        packettype -= filtered
        if packettype=0x08 then
            desc = "audio"
        elsif packettype=0x09 then
            desc = "video"
        elsif packettype=0x12 then
            desc = "script data"
        else
            desc = "*** ??? ***"
        end if
        if filtered!=0 then -- aka encrypted
            desc &= " (filtered)"
            packettype += filtered  -- (just skip, no decode)
        end if
        res[tabidx][$][R_NOTES] = desc
        payloadsize = decode("payload size","h3","")
        timestamplower = decode("timestamp lower","h3","")
        timestampupper = decode("timestamp upper","h1","")
        streamID = decode("streamID","h3","")
        --DEV audiotagheader, videotagheader?
        if packettype=8 then    -- audio, show audiotagheader details
            frst = decode("frst","h1","")
            soundformat = floor(frst/#10)
            soundrate = floor(and_bits(frst,#0C)/#04)
            soundsize = floor(and_bits(frst,#02)/#02)
            soundtype = and_bits(frst,#01)
            fdesc = fmtdescs[soundformat+1]
            sdesc = samplingrates[soundrate+1]
            zdesc = audiosizes[soundsize+1]
            tdesc = audiotypes[soundtype+1]
            desc = sprintf("%s %s %s %s",{fdesc,sdesc,zdesc,tdesc})
            res[tabidx][$][R_NOTES] = desc
            address += payloadsize-1
        elsif packettype=9 then -- video, show videotagheade|r details
            ftc = decode("ftc","h1","")
            frametype = floor(ftc/#10)
            codecid = and_bits(ftc,#0F)
            if frametype>=1 and frametype<=length(fdescs) then
                fdesc = fdescs[frametype]
            else
                fdesc = "??? *** ???"
            end if
            if codecid<2 or codecid>length(cdescs) then
                cdesc = cdescs[1]
            else
                cdesc = cdescs[codecid]
            end if
            desc = sprintf("Frame type %d [%s], CodecID = %d [%s]",{frametype,fdesc,codecid,cdesc})
            res[tabidx][$][R_NOTES] = desc
            address += payloadsize-1
        elsif packettype=18 then    -- scriptdata
--DEV much more work to be done here: check for encrypted[done], decode the whole section (loop and complete restructure/refactor/subroutine out)
            -- ScriptTagBody:
            --  Name SCRIPTDATAVALUE (Type=2 (string))          \  as           -- (**currently this is the only thing decoded**)
            --  Value SCRIPTDATAVALUE (Type=8 (ECMA array))     / below

            -- SCRIPTDATAVALUE:
            --  Type UI8
            --  ScriptDataValue as below for type 0/1/2/3/7/8/10/11/12 (4->error, 5/6 skip zero bytes, 9 invalid at top level)
            scripttype = decode("scripttype","h1","")
            if scripttype<0 or scripttype>12 then
                desc = "*** ??? ***"
            else
                desc = scripttypes[scripttype+1]
            end if
            res[tabidx][$][R_NOTES] = desc
            if scripttype=0 then
                -- DOUBLE
                {} = decode("double","h4","")
                valuesize = 4
            elsif scripttype=1 then
                -- UI8
                {} = decode("boolean","h1","")
                valuesize = 1
            elsif scripttype=2 then
                -- SCRIPTDATASTRING:
                --  StringLength UI16  length in bytes
                --  StringData STRING  up to 65536 bytes, no terminating null
                xlen = decode("length","h2","")
                {} = decode("string","x","")
                valuesize = xlen+2
            elsif scripttype=3 then
                --constant scripttypes = {"Number","Boolean","String","Object","MovieClip","Null","Undefined",
                --                      "Reference","ECMA array","Object end marker","Strict array",
                --                      "Date","Long String"}
                ?9/0
                -- SCRIPTDATAOBJECT:
                --  ObjectProperties SCRIPTDATAOBJECTPROPERTY[]
                --                      PropertyName SCRIPTDATASTRING (see 2)
                --                      PropertyData SCRIPTDATAVALUE (this whole block)
                --  List Terminator SCRIPTDATAOBJECTEND (see 9) [ie if string len (xlen) is 0 and the next byte is 9]
                {} = decode("Object","h1","")
                valuesize = 1
            elsif scripttype=7 then
                ?9/0 --(complete but not tested)
                -- UI16
                {} = decode("Reference","h2","")
                valuesize = 2
            elsif scripttype=8 then
                ?9/0
                -- SCRIPTDATAECMAARRAY:
                --  ECMAArrayLength UI32  ("Approximate number of items in ECMA array")
                --  Variables       SCRIPTDATAOBJECTPROPERTY[] (see 3)
                --  List Terminator SCRIPTDATAOBJECTEND (see 9) [ie if string len (xlen) is 0 and the next byte is 9]
                {} = decode("ECMA array","h1","")
                valuesize = 1
            elsif scripttype=9 then
                ?9/0 -- see 3 (and 8), not sure this would ever trigger (at top level)
                -- SCRIPTDATAOBJECTEND
                --  ObjectEndMarker UI8[3]  Shall be 0,0,9
                {} = decode("Object end marker","h1","")
                valuesize = 1
            elsif scripttype=10 then
                ?9/0
                -- SCRIPTDATASTRICTARRAY:
                --  StrictArrayLength   UI32
                --  StractArayValue  SCRIPTDATAVALUE[StrictArrayLength]  -- (may contain undefined, assume type 6 and no data?)
                {} = decode("Strict array","h1","")
                valuesize = 1
            elsif scripttype=11 then
                ?9/0
                -- SCRIPTDATADATE:
                --  DateTime            DOUBLE milliseconds since Jan 1, 1970 UTC
                --  LocalDateTimeOffset SI16 (local time offset in minute from UTC (==GMT)
                {} = decode("Date","h1","")
                valuesize = 1
            elsif scripttype=12 then
                ?9/0
                -- SCRIPTDATALONGSTRING
                --  StringLength    UI32    length in bytes
                --  StringData      STRING (no terminating NUL) [as per 2 but up to 4GB]
                {} = decode("Long String","h1","")
                valuesize = 1
            else
                res[tabidx] = append(res[tabidx],{address,"*** ??? ***",0,0,""})
                valuesize = 0
            end if
            address += payloadsize-(valuesize+1)
        else
            address += payloadsize
        end if
        packetcount += 1
        if packetcount>=20 then
--          {} = fatal("first 20 packets listed; remainder skipped")
            res[tabidx] = append(res[tabidx],{address,"first 20 packets listed; remainder skipped",0,0,""})
            exit
        end if
    end while
    asHex = 0
    return 1
end function

constant DB_MAGIC = 77
constant DB_MAJOR = 2, DB_MINOR = 5

function decode_EDB_file()
-- woefully incomplete!
integer dbmagic
integer dbmajor
integer dbminor
atom pTables
atom nFree
atom pFree
atom pInit
atom nTables

    SetTabIdx("EDB Header")
    dbmagic = decode("DB_MAGIC","h1","")
    dbmajor = decode("DB_MAJOR",1,"")
    dbminor = decode("DB_MINOR",1,"")
    if dbmagic!=DB_MAGIC
    or dbmajor!=DB_MAJOR
    or dbminor!=DB_MINOR then
        return resetTabs()
    end if
    pTables = decode("pTable","h4","pointer to tables")
    nFree = decode("nFree","h4","number of free blocks")
    pFree = decode("pFree","h4","pointer to free list")
    pInit = decode("pInit","h4","initial table block")
    nTables = decode("nTables","h4","number of tables")
--  -- 15: initial table block:
--  put4(8+INIT_TABLES*SIZEOF_TABLE_HEADER)  -- allocated size
--  -- 19:
--  put4(0)   -- number of tables that currently exist
--  -- 23: initial space for tables
--  putn(repeat(0, INIT_TABLES*SIZEOF_TABLE_HEADER))
--  -- initial space for free list
--  put4(4+INIT_FREE*8)   -- allocated size
--  putn(repeat(0, INIT_FREE*8))

    return 1
end function

function decode_ICO_file()
-- (If interested in this stuff, have a look through axtra.ew as well.)
integer size
integer idReserved
integer idType
string desc
integer idCount
integer bWidth, bHeight, bColorCount, bReserved, wPlanes, wBitCount, dwBytesInRes, dwImageOffset
sequence images
integer k
--integer biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage, 
atom biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage,
        biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant

    SetTabIdx("ICO File")
    size = file_size
    idReserved = decode("idReserved",2,"(must be 0)")
    if idReserved!=0 then return fatal("error") end if
    idType = decode("idType",2,"")
    if idType=1 then
        desc = "icon"
    elsif idType=2 then
        desc = "cursor"
    else
        return fatal("unknown type")
    end if
    res[tabidx][$][R_NOTES] = desc
    idCount = decode("idCount",2,"")
    size -= 6
    images = {}
    for i=1 to idCount do
        bWidth = decode("bWidth",1,"")
        bHeight = decode("bHeight",1,"")
        bColorCount = decode("bColorCount",1,"")
        bReserved = decode("bReserved",1,"(must be 0)")
        if bReserved!=0 then return fatal("error") end if
        wPlanes = decode("wPlanes",2,"")
        wBitCount = decode("wBitCount",2,"")
        dwBytesInRes = decode("dwBytesInRes",4,"")
        dwImageOffset = decode("dwImageOffset","h4","")
        images = append(images,{dwImageOffset,dwBytesInRes,length(res[tabidx]),bColorCount})
        size -= 16
    end for
    images = sort(images)
    for i=1 to length(images) do
        {dwImageOffset,dwBytesInRes,k,bColorCount} = images[i]
        if address<dwImageOffset then
            size -= dwImageOffset-address
            binary_dump(dwImageOffset-address,"padding")
        end if
--      binary_dump(dwBytesInRes,sprintf("ICONIMAGE[%d]",i))
        desc = sprintf("[%d]",i)
        res[tabidx][k][R_NOTES] = desc
        if 0 then
            binary_dump(dwBytesInRes,desc)
            size -= dwBytesInRes
        else
            -- this is too much:
            --      biSize = decode("biSize",4,sprintf("ICONIMAGE[%d]",i))
            biSize = decode("biSize",4,sprintf("BITMAPINFOHEADER[%d]",i))
--      biSize = decode("biSize",4,desc)
            biWidth = decode("biWidth",4,"")
            biHeight = decode("biHeight",4,"")
            biPlanes = decode("biPlanes",2,"(should be 1)")
            biBitCount = decode("biBitCount",2,"")
            biCompression = decode("biCompression",4,"(should be 0)")
            biSizeImage = decode("biSizeImage",4,"")
            biXPelsPerMeter = decode("biXPelsPerMeter",4,"(should be 0)")
            biYPelsPerMeter = decode("biYPelsPerMeter",4,"(should be 0)")
            biClrUsed = decode("biClrUsed",4,"(should be 0)")
            biClrImportant = decode("biClrImportant",4,"(should be 0)")
            size -= 40
            dwBytesInRes -= 40
--/*
    if    bColorCount<=2 then               palSize = 2     bpp = 1
    elsif bColorCount<=16 then              palSize = 16    bpp = 4
    elsif bColorCount<=256 then             palSize = 256   bpp = 8
    elsif bColorCount<=16777216 then        palSize = 0     bpp = 24
    else
        xpmErrFlag = XPM_ERR_COLORS
        xpmErrMsg = "Too many colours(?): "&xpmErrMsg
        if integer(xpm) then close(xpm) end if
        return NULL
    end if

    -- calculate the size of the BITMAPINFO header
    headerSize = sizeofstruct(BITMAPINFOHEADER) + (sizeofstruct(RGBQUAD) * palSize)

--*/
            binary_dump(dwBytesInRes,desc)
            size -= dwBytesInRes
        end if
    end for
--/*
typedef struct tagBITMAPINFOHEADER {
  DWORD biSize;
  LONG  biWidth;
  LONG  biHeight;
  WORD  biPlanes;
  WORD  biBitCount;
  DWORD biCompression;
  DWORD biSizeImage;
  LONG  biXPelsPerMeter;
  LONG  biYPelsPerMeter;
  DWORD biClrUsed;
  DWORD biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

typedef struct tagRGBQUAD {
  BYTE rgbBlue;
  BYTE rgbGreen;
  BYTE rgbRed;
  BYTE rgbReserved;
} RGBQUAD;
                   
typdef struct
{
   BITMAPINFOHEADER   icHeader;      // DIB header
   RGBQUAD         icColors[1];   // Color table
   BYTE            icXOR[1];      // DIB bits for XOR mask
   BYTE            icAND[1];      // DIB bits for AND mask
} ICONIMAGE, *LPICONIMAGE;
--*/
    if size!=0 then
        binary_dump(size,"-")
        return fatal(sprintf("** %d bytes not analysed **",size))
    end if
    return 1
end function

function decode_BMP_file()
-- (incomplete)
integer size
string bfType
integer bfSize, bfReserved1, bfReserved2, bfOffBits
--integer idReserved
--integer idType
--string desc
--integer idCount
--integer bWidth, bHeight, bColorCount, bReserved, wPlanes, wBitCount, dwBytesInRes, dwImageOffset
--sequence images
--integer k
integer biSize, biWidth, biHeight, biPlanes, biBitCount, biCompression, biSizeImage,
        biXPelsPerMeter, biYPelsPerMeter, biClrUsed, biClrImportant

    SetTabIdx("Bitmap File")
    size = file_size
    -- BITMAPFILEHEADER
    bfType = decode("bfType","x2","signature (should be \"BM\")")
    if bfType!="BM" then return fatal("bad signature") end if
    bfSize = decode("bfSize",4,"")
    bfReserved1 = decode("bfReserved1",2,"(must be 0)")
    bfReserved2 = decode("bfReserved2",2,"(must be 0)")
    bfOffBits = decode("bfOffBits",4,"")
    size -= 14 -- sizeofstruct(BITMAPFILEHEADER)
    -- BITMAPINFOHEADER
    biSize = decode("biSize",4,"BITMAPINFOHEADER(40)")
    biWidth = decode("biWidth",4,"")
    biHeight = decode("biHeight",4,"")
    biPlanes = decode("biPlanes",2,"(must be 1)")
    biBitCount = decode("biBitCount",2,"")
    biCompression = decode("biCompression",4,"(should be 0)")
    biSizeImage = decode("biSizeImage",4,"")
    biXPelsPerMeter = decode("biXPelsPerMeter",4,"(should be 0)")
    biYPelsPerMeter = decode("biYPelsPerMeter",4,"(should be 0)")
    biClrUsed = decode("biClrUsed",4,"(should be 0)")
    biClrImportant = decode("biClrImportant",4,"(should be 0)")
    size -= 40 -- sizeof(BITMAPINFOHEADER)

--/*
    idReserved = decode("idReserved",2,"(must be 0)")
    if idReserved!=0 then return fatal("error") end if
    idType = decode("idType",2,"")
    if idType=1 then
        desc = "icon"
    elsif idType=2 then
        desc = "cursor"
    else
        return fatal("unknown type")
    end if
    res[tabidx][$][R_NOTES] = desc
    idCount = decode("idCount",2,"")
    size -= 6
    images = {}
    for i=1 to idCount do
        bWidth = decode("bWidth",1,"")
        bHeight = decode("bHeight",1,"")
        bColorCount = decode("bColorCount",1,"")
        bReserved = decode("bReserved",1,"(must be 0)")
        if bReserved!=0 then return fatal("error") end if
        wPlanes = decode("wPlanes",2,"")
        wBitCount = decode("wBitCount",2,"")
        dwBytesInRes = decode("dwBytesInRes",4,"")
        dwImageOffset = decode("dwImageOffset","h4","")
        images = append(images,{dwImageOffset,dwBytesInRes,length(res[tabidx]),bColorCount})
        size -= 16
        end for
    images = sort(images)
    for i=1 to length(images) do
        {dwImageOffset,dwBytesInRes,k,bColorCount} = images[i]
        if address<dwImageOffset then
            size -= dwImageOffset-address
            binary_dump(dwImageOffset-address,"padding")
        end if
--      binary_dump(dwBytesInRes,sprintf("ICONIMAGE[%d]",i))
        desc = sprintf("[%d]",i)
        res[tabidx][k][R_NOTES] = desc
if 01 then
        binary_dump(dwBytesInRes,desc)
        size -= dwBytesInRes
else
-- this is too much:
--      biSize = decode("biSize",4,sprintf("ICONIMAGE[%d]",i))
        biSize = decode("biSize",4,sprintf("BITMAPINFOHEADER[%d]",i))
--      biSize = decode("biSize",4,desc)
        biWidth = decode("biWidth",4,"")
        biHeight = decode("biHeight",4,"")
        biPlanes = decode("biPlanes",2,"(should be 1)")
        biBitCount = decode("biBitCount",2,"")
        biCompression = decode("biCompression",4,"(should be 0)")
        biSizeImage = decode("biSizeImage",4,"")
        biXPelsPerMeter = decode("biXPelsPerMeter",4,"(should be 0)")
        biYPelsPerMeter = decode("biYPelsPerMeter",4,"(should be 0)")
        biClrUsed = decode("biClrUsed",4,"(should be 0)")
        biClrImportant = decode("biClrImportant",4,"(should be 0)")
        size -= 40
        dwBytesInRes -= 40
--/*
    if    bColorCount<=2 then               palSize = 2     bpp = 1
    elsif bColorCount<=16 then              palSize = 16    bpp = 4
    elsif bColorCount<=256 then             palSize = 256   bpp = 8
    elsif bColorCount<=16777216 then        palSize = 0     bpp = 24
    else
        xpmErrFlag = XPM_ERR_COLORS
        xpmErrMsg = "Too many colours(?): "&xpmErrMsg
        if integer(xpm) then close(xpm) end if
        return NULL
    end if

    -- calculate the size of the BITMAPINFO header
    headerSize = sizeofstruct(BITMAPINFOHEADER) + (sizeofstruct(RGBQUAD) * palSize)

--*/
        binary_dump(dwBytesInRes,desc)
        size -= dwBytesInRes
end if
    end for
--*/
--/*
typedef struct tagRGBQUAD {
  BYTE rgbBlue;
  BYTE rgbGreen;
  BYTE rgbRed;
  BYTE rgbReserved;
} RGBQUAD;
                   
typdef struct
{
   BITMAPINFOHEADER   icHeader;      // DIB header
   RGBQUAD         icColors[1];   // Color table
   BYTE            icXOR[1];      // DIB bits for XOR mask
   BYTE            icAND[1];      // DIB bits for AND mask
} ICONIMAGE, *LPICONIMAGE;
--*/
    if size!=0 then
        binary_dump(size,"-")
        return fatal(sprintf("** %d bytes not analysed **",size))
    end if
    return 1
end function

--/*
constant fields|descs = {"signature"|"(Should be \"Mod\\0\")",
                         "size"|"size (in bytes"}
--*/

function hex4(string s)
integer ch = 0
atom res = 0, mul = 1
    for i=1 to length(s) do
        if i>1 and ch='\\' then
            ch = s[i]
            if ch='0' then
                ch = 0
            elsif ch='n' then
                ch = '\n'
            else
                ?9/0
            end if
        else
            ch = s[i]
        end if
        if ch!='\\' then
            res += ch*mul
            mul *= #100
        end if
    end for
    return res
end function

function str4(atom h4)
integer ch
string res = ""
--  repeat(' ',4)
    for i=1 to 4 do
        ch = and_bits(h4,#FF)
        h4 = floor(h4/#100)
        if ch='\0' then
            res &= "\\0"
        elsif ch='\n' then
            res &= "\\n"
        else
            res &= ch
        end if
--      res[i] = and_bits(h4,#FF)
    end for
    return res
end function

constant MI_SIGNATURE   = hex4("Mod\0")     -- 00646F4D
constant MI_VERSION     = hex4("\nVer")     -- 7265560A
constant MI_FILENAME    = hex4("\nFil")     -- 6C69460A
constant MI_END         = hex4("\nEnd")     -- 646E450A
constant MI_FILESIZE    = hex4("\nSiz")     -- 7A69530A
constant MI_TIMESTAMP   = hex4("\nTst")     -- 7473540A
constant MI_CODECRC     = hex4("\nCcr")     -- 7263430A
--constant MI_USER      = hex4("\nUs\0")    -- 0073550A -- User data record (ORed with NM_xxx)
constant MI_USRLABEL    = hex4("\nUs1")     -- 3173550A -- See NM_LABEL etc
constant MI_ANALCOMM    = hex4("\nUs:")     -- 3A73550A
constant MI_MRULABEL    = hex4("\nUsq")     -- 7173550A
constant MI_APIARG      = hex4("\nUs9")     -- 3973550A
constant MI_STRUCT      = hex4("\nUs>")     -- 3E73550A
constant MI_CASE        = hex4("\nUs?")     -- 3F73550A
constant MI_CALLFINT    = hex4("\nCfi")     -- 6966430A
constant MI_CALLFMOD    = hex4("\nCfm")     -- 6D66430A
constant MI_CALLFABS    = hex4("\nCfa")     -- 6166430A
constant MI_JDDATA      = hex4("\nJdt")     -- 74644A0A
constant MI_SWDATA      = hex4("\nSwi")     -- 6977530A
constant MI_ANALPACK    = hex4("\nAnc")     -- 636E410A -- Record with compressed analysis data
--constant MI_INT3BREAK = 7470420A -- Record with breakpoint data
--constant MI_INT3BRKC  = 6370420A -- Record with checked breakpoint data
constant MI_ANALYSIS    = hex4("\nAna")     -- 616E410A
constant MI_SAVEAREA    = hex4("\nSva")     -- 6176530A
constant MI_PATCH       = hex4("\nPat")     -- 7461500A
constant MI_PROCDATA    = hex4("\nPrc")     -- 6372500A

-- OllyDbg 2:
constant MI_INFOS       = hex4("\nFcr")     -- 7263460A
constant MI_DATA        = hex4("\nDat")     -- 7461440A
constant MI_CBR         = hex4("\nCbr")     -- 7262430A
constant MI_LBR         = hex4("\nLbr")     -- 72624C0A
constant MI_CAS         = hex4("\nCas")     -- 7361430A
constant MI_MNE         = hex4("\nMne")     -- 656E4D0A
constant MI_MBA         = hex4("\nMba")     -- 61624D0A
constant MI_PRD         = hex4("\nPrd")     -- 6472500A
constant MI_LSA         = hex4("\nLsa")     -- 61734C0A
constant MI_SAVE        = hex4("\nSav")     -- 7661530A
constant MI_RTC         = hex4("\nRtc")     -- 6374520A
constant MI_RTP         = hex4("\nRtp")     -- 7074520A

--printf(1,"%08x\n",hex4("\nFcr"))
--printf(1,"%08x\n",hex4("\nAnc"))
--if getc(0) then end if
--printf(1,"%08x\n",MI_USRLABEL)
--      ("Infos", "\nFcr", F_["CRC2"]), #?
--?str4(MI_INT3BREAK)   \nBpt
--?str4(MI_INT3BRKC)    \nBpc
--?str4(MI_ANALPACK)    \nAnc


constant {knowntags, knowntagdescs} = columnize({
         {MI_SIGNATURE,  "Module info signature"},
         {MI_FILENAME,   "Record with full path of executable"},
         {MI_VERSION,    "Version"},
         {MI_FILESIZE,   "Record with file size"},
         {MI_TIMESTAMP,  "Record with timestamp file data"},
         {MI_CODECRC,    "Record with CRC of code for analysis"},
         {MI_USRLABEL,   "User label"},
         {MI_ANALCOMM,   "Analysis comment"},
         {MI_MRULABEL,   "MRU label"},
         {MI_APIARG,     "API Arg"},
         {MI_STRUCT,     "struct"},
         {MI_CASE,       "case description"},
         {MI_CALLFINT,   "Record with internal call"},
         {MI_CALLFINT,   "Record with internal call"},
         {MI_CALLFMOD,   "Record with intermodular call"},
         {MI_CALLFABS,   "Record with absolute call"},
         {MI_JDDATA,     "Record with all module jump data"},
         {MI_SWDATA,     "Record with switch data"},
         {MI_ANALPACK,   "Record with compressed analysis data"},
--       {MI_USER,       "0x0073550A -- \"Mod\0\"; User data record (ORed with NM_xxx)"},
--       {MI_INT3BREAK,  "0x7470420A -- \"Mod\0\"; Record with breakpoint data"},
--       {MI_INT3BRKC,   "0x6370420A -- \"Mod\0\"; Record with checked breakpoint data"},
         {MI_ANALYSIS,   "Record with analysis data"},
         {MI_SAVEAREA,   "Record with general-purpose save area"},
         {MI_PATCH,      "Patch"},
         {MI_PROCDATA,   "Record with procedure data"},
         {MI_END,        "End of module info data"},
        -- OllyDbg 2:
         {MI_INFOS,      "Infos"},
         {MI_DATA,       "Data"},
         {MI_CBR,        "CBR"},
         {MI_LBR,        "LBR"},
         {MI_CAS,        "CAS"},
         {MI_MNE,        "MNE"},
         {MI_MBA,        "MBA"},
         {MI_PRD,        "PRD"},
         {MI_LSA,        "MRU entries"},
         {MI_SAVE,       "Save"},
         {MI_RTC,        "RTC"},
         {MI_RTP,        "RTP"},
        $},{1,2})

constant sizeofFILETIME = 8

function decode_UDD_file()
-- this may be out of date (1.0.4) [see also udd/*.py]
--/*
.UDD (User-Defined Data) file consists of unaligned variable-length records.
Each record has the following format:

+define MI_FILENAME 0x 6C69460A // Record with full path of executable
+define MI_FILESIZE 0x 7A69530A L // Record with file size
+define MI_TIMESTAMP 0x 7473540A L // Record with timestamp file data
#define MI_USER 0x 0073550A L // User data record (ORed with NM_xxx)
#define MI_INT3BREAK 0x 7470420A L // Record with breakpoint data
#define MI_INT3BRKC 0x 6370420A L // Record with checked breakpoint data
+define MI_ANALYSIS 0x 616E410A L // Record with analysis data
+define MI_ANALPACK 0x 636E410A L // Record with compressed analysis data
+define MI_CODECRC 0x 7263430A L // Record with CRC of code for analysis
+define MI_SAVEAREA 0x 6176530A L // Record with general-purpose save area
+define MI_END 0x 646E450A L // End of module info data

struct t_record {
long tag; // Unique tag (MI_xxx) identifying record type
long size; // Size of data, bytes (may be 0)
char data[size]; // Data itself
};

(Try to read tags as ASCII text). File must begin with MI_SIGNATURE record
containing 22-byte string "Module info file v1.1\0". All other records are
optional. If OllyDbg doesn't know the meaning of the record, it simply ignores
it. This assures backward compatibility: breakpoints set by v1.02, for example,
will appear in OllyDbg v1.00.


MI_FILENAME contains full path to the file.


MI_FILESIZE contains 32-bit file size. (I haven't heard yet about .exe or .dll
that is longer than 4G bytes).


MI_TIMESTAMP is formed as follows:

FILETIME tlastwrite;
// Get timestamp (time of last update) and size of executable file.
hf=CreateFile(pmod->path,0,FILE_SHARE_READ|FILE_SHARE_WRITE,
NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
if (hf==INVALID_HANDLE_VALUE)
return; // Unable to query executable file
GetFileTime(hf,NULL,NULL,&tlastwrite);
filesize=GetFileSize(hf,NULL); // Here you has file size for MI_FILESIZE
CloseHandle(hf);
Saverecord(f,MI_TIMESTAMP,sizeof(tlastwrite),&tlastwrite);


For you, the most important record is MI_USER. I use it to save all types of
user data that are text. Size of data in MI_USER+xx records never exceeds 260
bytes (including terminal '\0'). I don't use MI_USER directly; instead, it is
ORed with type of user data (NM_XXX) shifted 24 bits to the left (so NM_XXX
comes into the most significant byte of the tag).

#define NM_LABEL 0x31 // User-defined label
#define NM_EXPORT 0x32 // Exported (global) name
#define NM_IMPORT 0x33 // Imported name
#define NM_LIBRARY 0x34 // Name from library or object file
#define NM_CONST 0x35 // User-defined constant
#define NM_COMMENT 0x36 // User-defined comment
#define NM_LIBCOMM 0x37 // Comment from library or object file
#define NM_BREAK 0x38 // Condition related with breakpoint
#define NM_ARG 0x39 // Arguments decoded by analyser
#define NM_ANALYSE 0x3A // Comment added by analyser
#define NM_BREAKEXPR 0x3B // Expression related with breakpoint
#define NM_BREAKEXPL 0x3C // Explanation related with breakpoint
#define NM_STRUCT 0x3E // Code structure decoded by analyzer
#define NM_INSPECT 0x40 // Several last inspect expressions
#define NM_WATCH 0x41 // Watch expressions
#define NM_ASM 0x42 // Several last assembled strings
#define NM_FINDASM 0x43 // Several last find assembler strings
#define NM_LASTWATCH 0x48 // Several last watch expressions
#define NM_SOURCE 0x49 // Several last source search strings

#define NMHISTORY 0x40 // Converts NM_xxx to type of init list

struct t_midata {
long offset; // Offset of symbol from the beginning of the module
char sztext[size-4]; // Zero-terminated symbolic name, 256 bytes max
};

Following user data types are associated with some module and can appear in any
.udd file:

NM_LABEL, // User-defined label
NM_LIBRARY, // Name extracted by object scanner
NM_COMMENT, // User-defined comment
NM_LIBCOMM, // Comment generated by object scanner
NM_BREAK, // Condition related with breakpoint
NM_BREAKEXPR, // Expression related with breakpoint
NM_BREAKEXPL, // Explanation related with breakpoint
NM_ANALYSE, // Comment added by analyser
NM_ARG // Decoding of known function

.udd file of main module (.exe) also keeps watch expressions and history lists
(they appear if you open pull-down window of the combobox). For this data,
offset field is simply a 1-based ordinal:

NM_LABEL | NMHISTORY, // List of last entered labels
NM_COMMENT | NMHISTORY, // List of last entered comments
NM_BREAK | NMHISTORY, // List of last entered break conditions
NM_BREAKEXPR | NMHISTORY, // List of last break expressions
NM_BREAKEXPL | NMHISTORY, // List of last break explanations
NM_INSPECT, // Inspect expressions
NM_WATCH, // Watch expressions
NM_ASM, // Several last assembled strings
NM_FINDASM, // Several last find assembler strings
NM_LASTWATCH, // Several last watch expressions
NM_SOURCE // Several last source search strings


When OllyDbg encounters MI_END, it stops file processing.

from plugin.h:
+define MI_SIGNATURE   00646F4D    // Module info signature
+define MI_VERSION     7265560A    // OllyDbg version
+define MI_FILENAME    6C69460A    // Record with full name of executable
+define MI_FILESIZE    7A69530A    // Record with file size
+define MI_TIMESTAMP   7473540A    // Record with timestamp file data
#define MI_SFXENTRY    6566530A    // Real entry of SFX-able module
+define MI_PATCH       7461500A    // Record with patch data
#define MI_USER        0073550A    // Record with NM_xxx, add it to hibyte
+define MI_PROCDATA    6372500A    // Record with procedure data
+define MI_SWDATA      6977530A    // Record with switch data
+define MI_CALLFINT    6966430A    // Record with internal call
+define MI_CALLFMOD    6D66430A    // Record with intermodular call
+define MI_CALLFABS    6166430A    // Record with absolute call
#define MI_INT3BREAK   7470420A    // Record with breakpoint data
#define MI_INT3BRKC    6370420A    // Record with checked breakpoint data
#define MI_HDWRBREAK   7262480A    // Record with hardware breakpoint data
+define MI_JDDATA      74644A0A    // Record with all module jump data
+define MI_ANALYSIS    616E410A    // Record with analysis data
+define MI_ANALPACK    636E410A    // Record with compressed analysis data
#define MI_TRACE       6172540A    // Record with trace data
#define MI_TRACEPACK   6372540A    // Record with compressed trace data
+define MI_CODECRC     7263430A    // Record with CRC of code for analysis
+define MI_SAVEAREA    6176530A    // Record with general-purpose save area
+define MI_END         646E450A    // End of module info data

// Names saved in the data file of module they appear.
#define NM_PLUGCMD     0x30            // Plugin commands to execute at break
#define NM_LABEL       0x31            // User-defined label
#define NM_EXPORT      0x32            // Exported (global) name
#define NM_IMPORT      0x33            // Imported name
#define NM_LIBRARY     0x34            // Name from library or object file
#define NM_CONST       0x35            // User-defined constant
#define NM_COMMENT     0x36            // User-defined comment
#define NM_LIBCOMM     0x37            // Comment from library or object file
#define NM_BREAK       0x38            // Condition related with breakpoint
#define NM_ARG         0x39            // Arguments decoded by analyzer
#define NM_ANALYSE     0x3A            // Comment added by analyzer
#define NM_BREAKEXPR   0x3B            // Expression related with breakpoint
#define NM_BREAKEXPL   0x3C            // Explanation related with breakpoint
#define NM_ASSUME      0x3D            // Assume function with known arguments
#define NM_STRUCT      0x3E            // Code structure decoded by analyzer
#define NM_CASE        0x3F            // Case description decoded by analyzer
// Names saved in the data file of main module.
#define NM_INSPECT     0x40            // Several last inspect expressions
#define NM_WATCH       0x41            // Watch expressions
#define NM_ASM         0x42            // Several last assembled strings
#define NM_FINDASM     0x43            // Several last find assembler strings
#define NM_LASTWATCH   0x48            // Several last watch expressions
#define NM_SOURCE      0x49            // Several last source search strings
#define NM_REFTXT      0x4A            // Several last ref text search strings
#define NM_GOTO        0x4B            // Several last expressions to follow
#define NM_GOTODUMP    0x4C            // Several expressions to follow in Dump
#define NM_TRPAUSE     0x4D            // Several expressions to pause trace

--*/
integer size
integer eaddr   -- error address
--string tag
atom tag
integer tagsize
integer k
string desc
string version
string filename
atom nVer
atom nSiz
object nTst
atom nCrc
atom nOffset
string userlabel
integer nType
atom pFileTime
atom RVA
integer nCategory

    SetTabIdx("UDD File")
    size = file_size
    while 1 do
        eaddr = address
        tag = decode("tag","h4","")
        size -= 4
        k = find(tag,knowntags)
        desc = str4(tag)&" - "
        if k=0 then
            desc &= "unknown"
            printf(1,"see %08x\n",eaddr)
        else
            desc &= knowntagdescs[k]
        end if
        res[tabidx][$][R_NOTES] = desc
        if tag=MI_END then exit end if  -- (there may be 4 bytes of null padding/size of zero following, by design, in /every/ case)
        tagsize = decode("size",4,"")
        size -= 4
        if tag=MI_SIGNATURE then
            xlen = tagsize
            version = decode("version","x","")
            if find(version,{"Module info file v1.1\\0",
                             "Module info file v2.01g\\0"}) then    -- DEV incomplete
                desc = "(good)"
            else
                -- this app may work just fine, or it may fail, 
                --  possibly rather badly/cryptically/subtly...
                desc = "(unrecognised)"
            end if
            res[tabidx][$][R_NOTES] = desc
        elsif tag=MI_FILENAME then
            xlen = tagsize
            filename = decode("filename","x","")
        elsif tag=MI_VERSION then
            for i=1 to 4 do
                nVer = decode(sprintf("version[%d]",i),"h4","")
                desc = sprintf("%d",nVer)
                res[tabidx][$][R_NOTES] = desc
            end for
        elsif tag=MI_FILESIZE then
            nSiz = decode("size","h4","")
            desc = sprintf("%d",nSiz)
            res[tabidx][$][R_NOTES] = desc
        elsif tag=MI_TIMESTAMP then
            nTst = decode("filetime","h8","")
--DEV tryme (if we can trigger an oops) (#03FF = 1023
--          if sequence(nTst) then
--              nTst = nTst[2]+nTst[1]*#100000000
--          end if
--          nTst = floor((nTst-(11644473600*10000000))/10000000)
--          nTst = floor(nTst/10000000)-11644473600
            if atom(nTst) then
                nTst = floor((nTst-(11644473600*10000000))/10000000)
            else
                ?"oops filedump line 9152"
                pFileTime = allocate(sizeofFILETIME)
                poke4(pFileTime,reverse(nTst))
                --DEV windows only: [erm, actually it's fine]
                nTst = FILETIMEtoDateTimeStamp(pFileTime)
                free(pFileTime)
            end if
            --DEV windows only:
-->         res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(nTst))
--          timedate td = adjust_timedate(Jan1st1970,nTst)
--          res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
            res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,nTst))
        elsif tag=MI_CODECRC then
            nCrc = decode("crc","h4","")
        elsif tag=MI_USRLABEL
           or tag=MI_ANALCOMM
           or tag=MI_MRULABEL
           or tag=MI_APIARG
           or tag=MI_MBA then
            nOffset = decode("offset","h4","")
            xlen = tagsize-4
            userlabel = decode("text","x","")
        elsif tag=MI_STRUCT
          and find(tagsize,{6,7}) then
            nOffset = decode("offset","h4","(guess)")
            if tagsize=6 then
                nType = decode("type","h2","(guess)")   -- I,E,B
            elsif tagsize=7 then
                nType = decode("type","h3","(guess)")   -- II, IB, IE
            end if
        elsif tag=MI_INFOS then
            nSiz = decode("size","h4","")
            desc = sprintf("%d",nSiz)
            res[tabidx][$][R_NOTES] = desc
            nTst = decode("filetime","h8","")
--DEV tryme (if we can trigger an oops)
--          if sequence(nTst) then
--              nTst = nTst[2]+nTst[1]*#100000000
--          end if
--          nTst = floor((nTst-(11644473600*10000000))/10000000)
--          nTst = floor(nTst/10000000)-11644473600
            if atom(nTst) then
                nTst = floor((nTst-(11644473600*10000000))/10000000)
            else
                ?"oops filedump line 9195"
                pFileTime = allocate(sizeofFILETIME)
                poke4(pFileTime,reverse(nTst))
                --DEV windows only: [erm, actually its' fine]
                nTst = FILETIMEtoDateTimeStamp(pFileTime)
                free(pFileTime)
            end if
            --DEV windows only:
-->         res[tabidx][$][R_NOTES] = sprintf("%s, %s (ish)",DateTimeStampToString(nTst))
--          timedate td = adjust_timedate(Jan1st1970,nTst)
--          res[tabidx][$][R_NOTES] = format_timedate(td,"Mmm dth yyyy hh:mm:ss")
            res[tabidx][$][R_NOTES] = format_timedate(adjust_timedate(Jan1st1970,nTst))
            nSiz = decode("unk","h4","(crc?)")
            nSiz = decode("zero?","h4","")
            nSiz = decode("zero?","h4","")
        elsif tag=MI_DATA
           or tag=MI_LSA then
            RVA = decode("RVA","h4","")
            nCategory = decode("category","h1","")
            if nCategory>' ' and nCategory<='z' then
                desc = sprintf("\'%s\'",nCategory)
                res[tabidx][$][R_NOTES] = desc
            end if
            xlen = tagsize-5
            if xlen>60 then
                k = xlen
                userlabel = ""
                desc = "text"
                xlen = 60
                while 1 do
                    userlabel &= decode(desc,"x","")
                    k -= 60
                    if k<60 then
                        if k<0 then exit end if
                        xlen = k
                    end if
                    desc = "<continued>"
                end while
            else
                userlabel = decode("text","x","")
            end if
            for i=1 to length(userlabel) do
                integer ch = userlabel[i]
                if ch>=#80 then
                    if ch=#A0 then
                        desc = "*"
                    else
                        desc = sprintf("%d",ch)
                    end if
                    desc = sprintf("lptype %s, type %s",{desc,userlabel[i+1..$]})
                    res[tabidx][$][R_NOTES] = desc
                    exit
                end if
            end for
        else
--if not find(tag,{MI_CASE}) then -- (temp)
--          printf(1,"see %08x\n",address)
--end if
            binary_dump(tagsize,"-?")
        end if
        size -= tagsize
        if size=0 then exit end if
    end while

    if size!=0 then
        binary_dump(size,"-")
        if size>4 then
            return fatal(sprintf("** %d bytes not analysed **",size))
        end if
    end if
    return 1
end function

procedure reset_tabidx()
integer len
integer lenrt, maxlen
sequence maxlens = repeat(-1,length(titles))

--?"reset_tabidx"
    tabidx = IupGetInt(tabs,"VALUEPOS")+1
    if tabidx<1 or tabidx>length(res) then ?9/0 end if
    lenrt = length(res[tabidx])
    for c=1 to length(titles) do
        maxlen = length(titles[c])
        for l=1 to lenrt do
            len = min(40,length(lvFormat(l,c)))
            if len>maxlen then
                maxlen = len
                if len=40 then exit end if
            end if
        end for
        maxlens[c] = maxlen
    end for
    awidths[tabidx] = maxlens
    IupSetInt(matrix, "NUMLIN", lenrt)
end procedure

procedure loadError(sequence msg)
    SetTabIdx("Error")
    res[1] = {{0,"",0,0,msg}}
    reset_tabidx()
end procedure

--with trace
function is_so_or_bin(string filename, string extension)
-- treat eg "libglfw.so.3.1" as "libglfw.so"
integer ch
--trace(1)
    if find(extension,{"","so","bin","o","2_arm"}) then return 1 end if
    for i=length(filename) to 1 by -1 do
        ch = filename[i]
        if ch='.' then
            extension = lower(filename[i+1..$])
            if find(extension,{"so","bin"}) then return 1 end if
            for j=length(extension) to 1 by -1 do
                ch = extension[j]
                if ch<'0' or ch>'9' then exit end if
                extension = extension[1..j-1]
            end for
            if length(extension) then exit end if
            filename = filename[1..i-1]
        elsif find(ch,"\\/") then
            exit
        end if
    end for
    return 0
end function

procedure load_file(string filename)
integer fn
integer id
string extension
integer ch
sequence todo, todos

    --DEV/progressbar/statusbar:
    ?"load_file"
    res = {}
    for i=1 to length(tabids) do
        id = tabids[i]
        if id!=0 then
-->         setTextColour(id, #000000) -- black
--          IupSetAttributeHandle(tabs,"TABIMAGE1", load_image_LogoTecgraf());
--          IupSetHandle("RedFlag", image);
--          IupSetAttribute(tabs, "TABIMAGE", 1, RedFlag)
            IupSetAttributeId(tabs, "TABIMAGE", 1, NULL)
--          IupSetAttributeId(tabs, "TABIMAGE", 1, NULL) -- yes (clears)
        end if
    end for
    fn = open(filename,"rb")
    if fn=-1 then
        loadError("cannot open "&filename)
        return
    end if
    extension = ""
    for i=length(filename) to 1 by -1 do
        ch = filename[i]
        if ch='.' then
            extension = lower(filename[i+1..$])
            exit
        elsif find(ch,"\\/") then
            exit
        end if
    end for
    for i=length(filename) to 1 by -1 do
        if find(filename[i],"\\/") then
            lastpath = filename[1..i]
            exit
        end if
    end for
    if seek(fn,-1)!=0 then
        close(fn)
        loadError("error seeking to end of file")
        return
    end if
    file_size = where(fn)
--printf(1,"filesize:#%08x\n",file_size)
    if seek(fn,0)!=0 then
        close(fn)
        loadError("error seeking to start of file")
        return
    end if
    binary = repeat(' ',file_size)
    for i=1 to file_size do
        binary[i] = getc(fn)
    end for
    close(fn)

--  address = 0
    void = resetTabs()  -- Note: You may want to call this again, if decode_X fails, before calling decode_Y.
                        --       (As things stand, tests on extension mean only one decode_XXX() is called.)
--trace(1)
--  if find(extension,{"","so","bin"})        and decode_ELF()!=-1 then
    if is_so_or_bin(filename,extension)       and decode_ELF()!=-1 then
        filetype = "ELF executable"
    elsif extension="flv"                     and decode_FLV()!=-1 then
        filetype = "FLV"
    elsif extension="edb"                     and decode_EDB_file()!=-1 then
        filetype = "Database file"
    elsif extension="ico"                     and decode_ICO_file()!=-1 then
        filetype = "icon file"
    elsif extension="bmp"                     and decode_BMP_file()!=-1 then
        filetype = "bitmap file"
    elsif extension="udd"                     and decode_UDD_file()!=-1 then
        filetype = "udd file"
    elsif find(extension,{"exe","dll"})       and decode_DOS_Header() then
        filetype = "PE executable"
        if address=e_lfanew -- (added 10/1/14)
        or decode_DOS_Stub() then
            if decode_PE_Header() then
                todo = {}
                if nImportSection then
                    todo = append(todo,{PointerToRawData[nImportSection],routine_id("decode_import_section"),{}})
                end if
                if nExportSection then
                    todo = append(todo,{PointerToRawData[nExportSection],routine_id("decode_export_section"),{}})
                end if
                if nRelocSection then
                    todo = append(todo,{PointerToRawData[nRelocSection],routine_id("decode_relocations"),{}})
                end if
                if nExceptions then
                    todo = append(todo,{PointerToRawData[nExceptions],routine_id("decode_exceptions"),{}})
                end if
                for i=1 to length(sDataSections) do
                    todo = append(todo,{PointerToRawData[sDataSections[i]],routine_id("decode_data_section"),{i}})
                end for
                for i=1 to length(sCodeSections) do
                    todo = append(todo,{PointerToRawData[sCodeSections[i]],routine_id("decode_code_section"),{i}})
                end for
                if nResourceSection then
                    todo = append(todo,{PointerToRawData[nResourceSection],routine_id("decode_resource_section"),{}})
                end if
                -- first create the tabs in file order...
                todos = sort(todo)
                for i=1 to length(todos) do
                    {} = call_func(todos[i][2],todos[i][3]&1)
                end for
                -- ...but populate them in logical order
                for i=1 to length(todo) do
                    {} = call_func(todo[i][2],todo[i][3]&0)
                end for
            end if
        end if
        ShowNotPhix()
    else
        filetype = "???"
--      void = resetTabs()
        address = 0
        SetTabIdx("Binary dump")
        binary_dump(file_size, "-")
    end if
    ?"load_file<"
    --  reset_tabidx()
    --> setText(Main,sprintf("%s file dump [%s]",{filetype,filename}))
    IupSetStrAttribute(maindlg,"TITLE","%s file dump [%s]",{filetype,filename})
    currentfilename = filename

end procedure

--string lastoutpath
--     lastoutpath = ""

--DEV:
--constant TEXTFILES = {"Text Files", "*.txt;*.csv",
--                    "txt files",  "*.txt",
--                    "csv files",  "*.csv"}

procedure print_file()
-- This is very basic, nothing fancy at all.
-- It saves to a file, rather than prints to a printer.
integer fn
object rt
integer len
sequence d

--> name = getSaveFileName(Main,lastpath,TEXTFILES,0)
--?"open"
--Ihandle filedlg;
--
--      filedlg = IupFileDlg();
--      IupSetAttribute(filedlg, "DIALOGTYPE", "OPEN");
--      IupSetAttribute(filedlg, "EXTFILTER", "Text Files|*.txt|All Files|*.*|");
--      IupSetAttributeHandle(filedlg, "PARENTDIALOG", IupGetDialog(item_open));
--
--      IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT);
--      if IupGetInt(filedlg, "STATUS")!= -1 then
--          string filename = IupGetAttribute(filedlg, "VALUE");
--          open_file(item_open, filename);
--      end if
--
--      IupDestroy(filedlg);

Ihandle filedlg
string name = ""

--  if UseNativeDialog
--  and platform()=WINDOWS then
--      atom hWnd = IupGetAttributePtr(dlg,"HWND")
--      object res = newGetSaveFileName(hWnd,encoding:=0)
--      if string(res) then
--          filename = res
--      end if
--  else
    filedlg = IupFileDlg()

--18/11/17 (untested)
--  IupSetAttributePtr(filedlg, "PARENTDIALOG", maindlg)
    IupSetAttributeHandle(filedlg, "PARENTDIALOG", maindlg)
    IupSetAttribute(filedlg, "DIALOGTYPE", "SAVE")
    IupSetAttribute(filedlg, "TITLE", "Save")
--DEV TEXTFILES
--      IupSetAttributes(filedlg, "FILTER = \" .bmp\", FILTERINFO = \"Bitmap Files\"")
--      IupSetAttributes(filedlg, "FILTER = \"*.bmp\", FILTERINFO = \"Bitmap Files\"")
--      IupSetAttribute(filedlg, "EXTFILTER", "Text files|*.txt;*.exw|All Files|*.*|")
--      IupSetInt(filedlg, "FILTERUSED", 2)

    IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT)

    integer status = IupGetInt(filedlg, "STATUS")
    if status>=0 then   -- normal or new (not cancel)
        name = IupGetAttribute(filedlg, "VALUE")
    end if

    IupDestroy(filedlg)

--  end if
--  if sequence(name) and length(name)=1 then
--      name = name[1]
    if length(name) then
--      if string(name) then
--          for i=length(name) to 1 by -1 do
--              if find(name[i],"\\/") then
--                  lastoutpath = name[1..i]
--                  exit
--              end if
--          end for
        fn = open(name,"w")
        if fn=-1 then
-->             void = messageBox("Error","Cannot open "&name,MB_OK)
            IupMessage("Error","Cannot open "&name)
        else
            for t=1 to length(tabnames) do
                tabidx = t
                rt = res[tabidx]
                if sequence(rt) and length(rt)>0 then
                    name = tabnames[tabidx]
                    printf(fn,"%s\n%s\n",{name,repeat('=',length(name))})
                    len = length(rt)
                    d = repeat("",length(titles))
                    for i=1 to len do
                        for j=1 to length(titles) do
                            d[j] = lvFormat(i,j)
                        end for
--                          printf(fn,"%s,%s,%s,%s,%s\n",d)
                        printf(fn,"%s\n",{join(d,",")})
                    end for
                end if
            end for
            close(fn)
--              reset_tabidx()
        end if
--      end if
    end if
end procedure

function print_cb(Ihandle /*file_print*/)
--?"print_cb"
    print_file()
    return IUP_DEFAULT;
end function
constant cb_print = Icallback("print_cb")

procedure help()
    IupMessage("filedump version 0.2","""
Analyse and display file contents.

Supports PE and ELF executables, both 32 and 64 bit. Note that the primary 
purpose is for Phix-generated files, so eg imports buried in the middle of a 
.text or .data section are not likely to be analysed.

For PE and ELF files, you can press F9 to invoke "pw.exe GraphR.exw", which 
displays a simple visual representation of the memory/file layout.

Also handles .ico files. I started on flv and edb files but did not get very far. 
If it does not recognise the file contents, it just performs a plain binary dump.""")
end procedure

function help_cb(Ihandle /*ih*/)
    help()
    return IUP_DEFAULT;
end function
constant cb_help = Icallback("help_cb")

--DEV
--constant FILTER = {"All Executables", "*.exe;*.dll",
--                 "exe files",       "*.exe",
--                 "dll files",       "*.dll",
--                 "icon files",      "*.ico;*.cur",
--                 "flv files",       "*.flv",
--                 "edb files",       "*.edb",
--                 "All Files",       "*.*"}

function open_cb(Ihandle /*file_open*/)
--?"open"
--Ihandle filedlg;
--string d
--
--  if save_check(item_open) then
--      d = IupConfigGetVariableStr(config, "MainWindow", "LastDirectory");
--
--      filedlg = IupFileDlg();
--      IupSetAttribute(filedlg, "DIALOGTYPE", "OPEN");
--      IupSetAttribute(filedlg, "EXTFILTER", "Text Files|*.txt|All Files|*.*|");
--      IupSetAttributeHandle(filedlg, "PARENTDIALOG", IupGetDialog(item_open));
--      IupSetStrAttribute(filedlg, "DIRECTORY", d);
--
--      IupPopup(filedlg, IUP_CENTERPARENT, IUP_CENTERPARENT);
--      if IupGetInt(filedlg, "STATUS")!= -1 then
--          string filename = IupGetAttribute(filedlg, "VALUE");
--          open_file(item_open, filename);
--
--          d = IupGetAttribute(filedlg, "DIRECTORY");
--          IupConfigSetVariableStr(config, "MainWindow", "LastDirectory", d);
--      end if
--
--      IupDestroy(filedlg);
--  end if

Ihandle filedlg2
string filename = ""

--  if UseNativeDialog
--  and platform()=WINDOWS then
--      atom hWnd = IupGetAttributePtr(dlg,"HWND")
--      object res = newGetOpenFileName(hWnd,encoding:=0)
--      if string(res) then
--          filename = res
--      end if
--/*
--DEV document (other/fileopenN)
--  A windows-only [Vista and later] file open dialog with an [optional] ansi/utf8/utf16le/utf16be encoding dropdown.
--  If using pGUI and the latter is not needed, you should use the standard cross-platform IupFileDlg (or IupGetFile) instead,
--  and as per Edix the required code for IupFileDlg should also be present as well, for use on non-windows systems.
--include builtins\fileopenN.e
--
--global function newGetOpenFileName(atom hWnd=NULL, object filters=NULL, object extension=NULL, object default_folder=NULL, integer encoding=1)
--
-- hWnd is, obviously enough, the [optional] handle of a window you would like to act as the parent of the open/save dialog.
--  When using pGUI, can be obtained from an Ihandle dlg [=IupDialog(..)] using atom hWnd = IupGetAttributePtr(dlg,"HWND").
-- filters can be NULL or something like { {"Text Document (*.txt)", "*.txt"}, 
--                                         {"All Documents (*.*)", "*.*"} }
-- extension can be NULL or {idx,"doc"[,flags]} or {idx,NULL[,flags]}:
--  idx is an index to filters, to set the default type index. If filters is NULL then idx is ignored, conversely if extension is 
--  NULL then an idx of 1 is assumed. The second "doc" part specifies a default file extension, ie/eg "fred" is actually saved as 
--  "fred.doc" (and is not worth setting during file open). Note that manually changing the filter drop-down (if present) will
--  automatically override this. The third "flags" part, if present, allows additional options such as FOS_ALLOWMULTISELECT.
-- Specifying a default folder of say "C:\temp" causes the standard behaviour of setting the folder to use if there is not a
--  recently used folder value available. Specifying a default folder of {"C:\temp"} overrides any recently used folder value.
--  Edita, for example, uses the latter to force open/save in the directory associated with the current file tab, however most
--  applications would not benefit from such brutally forceful behaviour.
-- Specifying an encoding of 0 suppresses the encoding drop-down, otherwise specify 1..4 for default(ansi)/utf8/utf16le/utf16be.
--  eg .reg files should [as opposed to must] always be stored as utf16le; so removing the option avoids potential mishap,
--  or .avi/mp3/jpg files: anything selected would have to be completely ignored anyway. Note that when encoding is set 0,
--  the result is a single string, whereas when left as the default or explicitly specified this returns {encoding,name},
--  or 0 if the user cancels the operation. Note that FOS_ALLOWMULTISELECT can only be specified on open (not save), and 
--  both automatically suppresses the custom encoding drop-down, and returns an array of strings, with no encoding flags.
--
-- Returns: 0                        - if user cancels the operation
--          {"name","name","name"}   - if (not cancelled and) FOS_ALLOWMULTISELECT is specified
--          "name"                   - if (not cancelled and not FOS_ALLOWMULTISELECT and) encoding is set to 0
--          {encoding(=1..4),"name"} - if none of the above are true
--
--  return filedialog(OPEN,hWnd,filters,extension,default_folder,encoding)
--end function

--pp(newGetOpenFileName(NULL,NULL,{0,0,FOS_ALLOWMULTISELECT}))
--pp(newGetOpenFileName(NULL,NULL,{0,0,0}))
--pp(newGetOpenFileName(getHwnd(id),NULL,{0,0,0}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{1,"txt"}))
--pp(newGetOpenFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{2,NULL}))  -- fine
--pp(newGetSaveFileName(NULL))
--pp(newGetSaveFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{1,"txt"}))
--pp(newGetSaveFileName(NULL,{{"Text Documents (*.txt)","*.txt"},{"All Documents (*.*)","*.*"}},{2,NULL}))
--pp(newGetSaveFileName(NULL,NULL,NULL,"C:\\Windows",2))
--pp(newGetSaveFileName(NULL,NULL,NULL,"C:\\Windows",0))
--trace(1)
--  res = newGetSaveFileName(NULL,NULL,NULL,"C:\\Program Files (x86)\\Phix\\demo\\win32dibademo",0)
--  res = newGetSaveFileName(NULL,NULL,NULL,"C:\\Program Files (x86)\\Phix\\demo\\win32dibademo")
        pp(res)
        {} = wait_key()
--*/
--  else
    filedlg2 = IupFileDlg()

--18/11/17 (untested)
--  IupSetAttributePtr(filedlg2, "PARENTDIALOG", maindlg)
    IupSetAttributeHandle(filedlg2, "PARENTDIALOG", maindlg)
--      IupSetAttribute(filedlg2, "DIALOGTYPE", "OPEN")
    IupSetAttribute(filedlg2, "TITLE", "Open")
--DEV exe,dll,so|All? (see FILTER)
--      IupSetAttributes(filedlg2, "FILTER = \" .bmp\", FILTERINFO = \"Bitmap Files\"")
--      IupSetAttributes(filedlg2, "FILTER = \"*.bmp\", FILTERINFO = \"Bitmap Files\"")
--      IupSetAttribute(filedlg2, "EXTFILTER", "Text files|*.txt;*.exw|All Files|*.*|")
--      IupSetInt(filedlg2, "FILTERUSED", 2)

    IupPopup(filedlg2, IUP_CENTERPARENT, IUP_CENTERPARENT)

    integer status = IupGetInt(filedlg2, "STATUS")
    if status=0 then    -- normal, existing file
        filename = IupGetAttribute(filedlg2, "VALUE")
    end if

    IupDestroy(filedlg2)

--  end if
    if length(filename) then
--?filename
        load_file(filename)
    end if
    return IUP_DEFAULT;
end function
constant cb_open = Icallback("open_cb")

function nibble(integer c)
    if c>='0' and c<='9' then return c-'0' end if
    if c>='A' and c<='F' then return c-'A'+10 end if
    if c>='a' and c<='f' then return c-'a'+10 end if
    ?9/0 -- (more guards required on the getAddr call?)
end function

function getAddr(string addrstr)
integer res = 0
    for i=1 to length(addrstr) do
        res = res*#10+nibble(addrstr[i])
    end for
    return res
end function

procedure clicked(integer k)
integer tgtaddr
-->     k = getIndex(MainLV)
--  integer k = IupGetInt(matrix,"FOCUSCELL") -- (we only want the line)
--?{"clicked",k}
    if k!=0 then
        sequence line = res[tabidx][k]
        string notes = line[R_NOTES]
        if match("see #",notes)=1 then
--          ?line
--          printf(1,"%08x\n",getAddr(notes[6..13]))
            if line[R_DESC]="UnwindData" then
                tgtaddr = getAddr(notes[6..13])
            else
                -- (more guards may be required to avoid crashes here...)
                tgtaddr = getAddr(notes[6..13])-(getAddr(line[R_DESC][1..8])-line[R_ADDR])
            end if
--          printf(1,"%08x\n",tgtaddr)
            for i=1 to length(res[tabidx]) do
                if res[tabidx][i][R_ADDR]=tgtaddr then
--printf(1,"setIndex(%d)\n",i)
--                      if i>9 and i<length(res[tabidx]) then
--                          setIndex(MainLV,min(i+15,length(res[tabidx])))
--                      end if
--DEV/SUG (alt-left or something...)
--goback[tabidx] = append(goback[tabidx],k)
-->                     k = sendMessage(MainLV,LVM_GETCOUNTPERPAGE,0,0)
-->                     void = sendMessage(MainLV,LVM_ENSUREVISIBLE,max(0,i-floor(k/5)),0)
-->                     void = sendMessage(MainLV,LVM_ENSUREVISIBLE,min(length(res[tabidx]),i+floor(k*4/5)),0)
-->                     setIndex(MainLV,i)
--?{{{{i}}}}
                    integer origin = IupGetInt(matrix,"ORIGIN")
                    integer numlin = IupGetInt(matrix,"NUMLIN_VISIBLE")
                    if i<origin
                    or i>=origin+numlin then
                        IupSetInt(matrix,"ORIGIN",i-6)
                    end if
                    {} = enteritem_cb(matrix, i, 1)
                    IupRedraw(matrix)
                    exit
                end if
            end for
--  nDataSection = sDataSections[idx]
--  address = PointerToRawData[nDataSection]
--  SectionNames[nDataSection] = desc
--  addr = SH_VirtualAddress[nDataSection]+ImageBase
--
--      symptr = decode(sprintf("%08x: symptr",{addr}),fmt,"")
--
--  line = {address,description,size,0,notes}

--*16
--*10
--              ? = toNumber
--      res[tabidx][$][R_NOTES] = sprintf("see #%08x",symptr)
--constant R_TITLE = 1  -- idx to lvcolumns[j] [ie "Address".."Notes"]
--constant R_DESC = 2   -- idx to res
--constant R_NOTES = 5  -- idx to res
--
--  -- set scroll index to be in relative to cursor place in file
        end if
    end if
end procedure

function click_cb(Ihandle self, integer l, integer c, atom pStatus)
    if c>=1 and c<=length(titles)
    and l>0 then    -- (ignore title clicks)
        if iup_isdouble(pStatus) then
            clicked(l)
        end if
    end if
    return IUP_DEFAULT
end function
constant cb_click = Icallback("click_cb")

function tabchange_cb(Ihandle /*tabs*/, Ihandln /*new_tab*/, Ihandln old_tab)
sequence widths
    if old_tab!=NULL then
        -- save column widths, origin, and focus on the old tab
        widths = repeat(0,IupGetInt(matrix,"NUMCOL"))
        for i=1 to length(widths) do
            widths[i] = IupGetIntId(matrix,"RASTERWIDTH",i)
        end for
        awidths[tabidx] = widths
        origins[tabidx] = IupGetAttribute(matrix,"ORIGIN")
        current[tabidx] = IupGetAttribute(matrix,"FOCUSCELL")
    end if
    -- set column widths, origin, focus, and linecount on the new tab
    tabidx = IupGetInt(tabs,"VALUEPOS")+1
if tabidx!=0 then
    if awidths[tabidx]=-1 then reset_tabidx() end if
    widths = awidths[tabidx]
    integer width = IupGetInt(maindlg,"RASTERSIZE")-75
    integer total_width = sum(widths)
    IupSetIntId(matrix,"RASTERWIDTH",0,0)
    for i=1 to length(widths) do
        integer new_width = max(floor((widths[i]/total_width)*width),10)
        IupSetIntId(matrix,"RASTERWIDTH",i,new_width)
    end for
    IupSetInt(matrix, "NUMLIN", length(res[tabidx]))
    IupSetAttribute(matrix,"ORIGIN",origins[tabidx])
    IupSetAttribute(matrix,"FOCUSCELL",current[tabidx])
    integer {l,c} = IupGetIntInt(matrix,"FOCUSCELL")
    {} = enteritem_cb(matrix,l,c)   -- (needed to update the display)
    IupSetFocus(matrix)
    IupRedraw(matrix)
end if
--DEV I used this (in listview.exw) to set MINSIZE: 
--IupSetAttribute(dlg, "TITLE", IupGetAttribute(dlg,"SIZE"))
    return IUP_DEFAULT
end function
constant cb_tabchange = Icallback("tabchange_cb")

function key_cb(Ihandle /*ih*/, atom c)
--DEV CR follow link (as per click_cb), alt left(/right) to follow link stack
    if c=K_CR then
        integer l = IupGetInt(matrix,"FOCUSCELL") -- (we only want the line)
        clicked(l)
    elsif c=K_cO then
        return open_cb(file_open)
    elsif c=K_cP then
        return print_cb(file_print)
    elsif c=K_F1 then
        help()
    elsif c=K_F3 then
        dump_import_table()
    elsif c=K_F9 then
        {} = graph_cb(file_graph)
    elsif c=K_cPGUP then
        integer pos = IupGetInt(tabs,"VALUEPOS")
        if pos>0 then
            Ihandle old_tab = IupGetAttributePtr(tabs,"VALUE_HANDLE")
            IupSetInt(tabs,"VALUEPOS",pos-1)
            Ihandle new_tab = IupGetAttributePtr(tabs,"VALUE_HANDLE")
            return tabchange_cb(tabs,new_tab,old_tab)
        end if
    elsif c=K_cPGDN then
        integer pos = IupGetInt(tabs,"VALUEPOS")
        if pos+1<IupGetInt(tabs,"COUNT") then
            Ihandle old_tab = IupGetAttributePtr(tabs,"VALUE_HANDLE")
            IupSetInt(tabs,"VALUEPOS",pos+1)
            Ihandle new_tab = IupGetAttributePtr(tabs,"VALUE_HANDLE")
            return tabchange_cb(tabs,new_tab,old_tab)
        end if
    elsif c=K_cHOME then
        IupSetInt(matrix,"ORIGIN",0)
        return enteritem_cb(matrix,1,1)
    elsif c=K_cEND then
        integer i = length(res[tabidx])
        integer origin = IupGetInt(matrix,"ORIGIN")
        integer numlin = IupGetInt(matrix,"NUMLIN_VISIBLE")
        if i<origin
        or i>=origin+numlin then
            IupSetInt(matrix,"ORIGIN",i-6)
        end if
        return enteritem_cb(matrix, i, 1)
    end if
    return iff(c=K_ESC?IUP_CLOSE:IUP_CONTINUE)
end function
constant cb_key = Icallback("key_cb")

procedure main()

    IupOpen()
    clipboard = IupClipboard()
    file_open = IupMenuItem("&Open\tCtrl O",cb_open)
    file_print = IupMenuItem("&Print\tCtrl P",cb_print)
    file_copy = IupMenuItem("&Copy filename",cb_copyname)
    file_graph = IupMenuItem("&Graphic view\tF9",cb_graph)
    file_exit = IupMenuItem("E&xit\t\tEsc/Alt F4",cb_exit)
    Ihandle file_menu = IupMenu({file_open,
                                 file_print,
                                 file_copy,
                                 file_graph,
                                 file_exit})
    IupSetCallback(file_menu, "OPEN_CB", Icallback("file_menu_open_cb"));
    Ihandle help_menu = IupMenu({IupMenuItem("&About\tF1",cb_help)})

    Ihandle menu = IupMenu({IupSubmenu("&File",file_menu),
                            IupSubmenu("&Help",help_menu)})

    tabs = IupTabs()
    IupSetCallback(tabs, "TABCHANGE_CB", cb_tabchange)
    RedFlag = get_image("RedFlag.png")
--  IupSetHandle("RedFlag", get_image("RedFlag.png"))
    matrix = IupMatrix()
    --IMPORTANT: HEIGHT0 tells IupMatrix that we are gonna have column titles at line 0
    IupSetInt(matrix, "HEIGHT0", 10);
    IupSetAttribute(matrix, "RESIZEMATRIX", "YES");
    IupSetAttribute(matrix, "MARKMODE", "LIN");
    IupSetAttribute(matrix, "MARKAREA", "CONTINUOUS");
--  IupSetAttribute(matrix, "READONLY", "YES"); -- with VALUE_CB set, non-setting of VALUE_EDIT_CB (also) makes it read-only
    IupSetAttribute(matrix, "HIDEFOCUS", "YES");
    IupSetAttribute(matrix, "FRAMECOLOR", "220 220 220");
    IupSetAttribute(matrix, "BORDER", "NO");
    IupSetAttribute(matrix, "CURSOR", "ARROW");
    IupSetAttribute(matrix, "ALIGNMENT", "ALEFT");
    IupSetAttribute(matrix, "ALIGNMENTLIN0", "ALEFT");

    IupSetCallback(matrix, "VALUE_CB",      cb_value)
    IupSetCallback(matrix, "ENTERITEM_CB",  cb_enteritem)
    IupSetCallback(matrix, "CLICK_CB",      cb_click)
    IupSetCallback(matrix, "COLRESIZE_CB",  cb_colresize)
--  IupSetCallback(matrix, "RELEASE_CB",    demo:cb_release)
--  IupSetCallback(matrix, "K_ANY",         cb_key)

    IupSetInt(matrix, "NUMCOL", length(titles))
    IupSetInt(matrix, "NUMCOL_VISIBLE", length(titles))
--  IupSetInt(matrix, "NUMLIN", length(files))
--  for i=1 to length(cwidth) do
--      IupSetIntId(matrix, "RASTERWIDTH", i, cwidth[i])
--      IupSetAttribute(matrix, sprintf("ALIGNMENT%d",{i}), IupRawStringPtr(talign[i]))
--      IupSetAttributeId(matrix, "ALIGNMENT", i, IupRawStringPtr(talign[i]))
--          IupSetAttributeId(matrix, "ALIGNMENT", i, talign[i])
--  end for

    Ihandle buttons = IupHbox({IupFill(),IupButton("close",cb_exit)},"CMARGIN=13x3")
    maindlg = IupDialog(IupVbox({tabs,
                                 matrix,
                                 buttons}),
                        "TITLE=filedump, SHRINK=YES")

    IupSetAttribute(maindlg, "MINSIZE", "862x705")
    IupSetAttributeHandle(maindlg, "MENU", menu)

    IupSetAttribute(maindlg, "SHRINK", "YES")
    IupSetCallback(maindlg, "RESIZE_CB", cb_resize)
    IupSetCallback(maindlg, "K_ANY", cb_key)

    IupMap(maindlg)
    if platform()=WINDOWS then
--      load_file("C:\\Program Files (x86)\\Phix\\p.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\misc\\fdbg0011\\fdbg")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl32.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl.32.SK.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl.64.SK-X.dll") -- PE at #F8
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurl\\libcurl.64.SK.dll") -- PE at #E8
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl\\examples\\cygcurl-4.32.dll") -- HMMM
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\libcurl.32.vs.dll")

--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\vector\\sha512.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurlx\\vector\\Hash DLLs\\SHA512.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\e01.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\p46.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\p64.exe")
--      load_file("C:\\Downloads\\StartGamedev-170112-win\\game.apk.unzipped\\lib\\armeabi\\libgnustl_shared.so")
--      load_file("C:\\Downloads\\StartGamedev-170112-win\\game.apk.unzipped\\lib\\armeabi\\liblove.so")
--      load_file("C:\\Downloads\\StartGamedev-170112-win\\game.apk.unzipped\\lib\\armeabi\\libmpg123.so")
--      load_file("C:\\Downloads\\StartGamedev-170112-win\\game.apk.unzipped\\lib\\armeabi\\libopenal.so")
    --  load_file("C:\\Program Files (x86)\\Phix\\e02.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\e03") --**PERFECT**
--      load_file("C:\\Program Files (x86)\\Phix\\e06.dll")
--      load_file("C:\\Program Files (x86)\\Phix\\phix")
--      load_file("C:\\Program Files (x86)\\Phix\\p64")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\singen\\singen") -- hopeless
--      load_file("C:\\Program Files (x86)\\Phix\\pth")
        load_file("C:\\Program Files (x86)\\Phix\\demo\\libcurl\\coinsplus.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\pw.exe")
--      load_file("C:\\Program Files (x86)\\Phix\\m01")
--      load_file("C:\\Program Files (x86)\\Phix\\sfx\\test\\cat")
    --  load_file("C:\\Program Files (x86)\\Phix\\sfx\\lua_5.0.2_arm")
    --  load_file("C:\\Program Files (x86)\\Phix\\demo\\IDE\\IDE.exe")
    --  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\OPENGL\\Opengl\\wall.raw")
--      load_file("C:\\Program Files (x86)\\Phix\\asm\\win32app\\win32_small_apps\\sprites\\spriteDDT.exe")
--      load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\demo\\iup\\libiupgl.so")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\pIUP\\5\\cd-5.11_Linux32_64_lib.tar\\cd-5.11_Linux32_64_lib\\libcd.so")
--      load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share2\\data.edb")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\data.edb")
    --  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\OPENGL\\OPENGL.EXE")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\mfasm\\EXAMPLES\\ARM\\TEST.BIN")
--      load_file("C:\\Program Files (x86)\\Phix\\demo\\misc\\euchipmunkphy\\chipmunk.dll")
    else
        load_file("/usr/lib/libiup.so")
    end if
--DEV might want to be part of load_file:
    IupSetInt(tabs,"VALUEPOS",0)
    {} = tabchange_cb(tabs, NULL, NULL)

    IupShow(maindlg)

    IupSetFocus(matrix)
    IupMainLoop()
    IupClose()

end procedure

main()

--procedure main()
--sequence cl
--  cl = command_line()
--  load_file(cl[1])
-- pemit2: sections should be [.edata,].idata,.rsrc,.data,.text
--  load_file("C:\\Program Files (x86)\\Phix\\p.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\pw.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\ok.ico")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\DemoResources\\hand.bmp")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\arwendemo\\pgui\\Hopstarter-Sleek-Xp-Basic-Ok.ico")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\arwendemo\\pgui\\tick64.ico")
--  load_file("C:\\Program Files (x86)\\Phix\\ok2.ico")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t01typeX.exe")
-- add loadconfig to RVA blacklist... (not rqd)
--  load_file("C:\\Windows\\SYSWOW64\\kernel32.dll")                -- imports not recognised (who cares)
--  load_file("C:\\Windows\\system32\\kernel32.dll")                -- imports not recognised (who cares)
--  load_file("C:\\Windows\\System32\\accessibilitycpl.dll")        -- ugh. crashes on F9 (who cares)
--  load_file("C:\\Program Files (x86)\\EC Software\\HelpAndManual6\\HELPMAN.EXE")  -- bit too much (lots of unknown pairing, then very very very slow)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\of\\pedll.dll")
--  load_file("C:\\Program Files\\7-Zip\\7z.exe")                   -- seems fine (even with the import section being "backwards" and datasection virtualsize>rawdatasize...)
                                                                    -- "" oops, broken by "h8" handling...
--  load_file("C:\\Program Files\\7-Zip\\7z.dll")                   -- *** LOTS OF DISSASSEMBLY PROBLEMS! (neither OllyDbg nor x86asm.net fare any better)
--DEV RVA: basereloc#=0/debug#=0,IAT#=0 -> No Code Sections [?]
-- .text/.rdata/.data/.rsrc/.reloc -> No Code Sections [?]
--  load_file("C:\\Program Files (x86)\\Edita\\help\\xxhha.dll")    -- imports not recognised (who cares)       -- <some things that OllyDbg cannot decode either>
--  load_file("C:\\Program Files (x86)\\Phix98\\demo\\PE_Stuff\\elf\\test")     -- ARM (should really get F9 to work on this, and write a disassembler)
-- ("", see http://www2.onlinedisassembler.com/odaweb/vCs0Rd/0 )
--  https://www.onlinedisassembler.com/odaweb/2ZhZD4Yl
--  load_file("C:\\Program Files (x86)\\Phix98\\demo\\PE_Stuff\\elf\\minielf")  -- good [really good!]
--DEV stop disassembly if enrypoint!=start of code...
--  load_file("C:\\Users\\Pete\\Desktop\\atratus-v0.11\\bin\\robotfindskitten") -- (has interpreter section) [otherwise/hence good] [should not disassamble, really]
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\hello")               -- good [really good!]
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\hello64")             -- good [really good!] (nothing to test this on, though)
--proper symtab etc... (why not others?) [**Needs strtab doing**] (or just drop a marker in data section...?) [DONE]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\linux_dynamic\\main32") -- good (dlopen but seems over-complex) [*** by far the closest we've got ***]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\linux_dynamic\\main64") -- good
--{{description,start,size}}
--GraphR:{{"ELF Header (#0..#33)",0,52},
--      {"Program Headers (#34..#B3)",52,128},
--      {"Section Headers (#75EC..#77F3)",30188,520},
--      {"Dynamic Link Info (#7000..#708F)",28672,144},
--<     {"Symtab (#7090..#17F7)",28816,-22680},
-->     {"Symtab (#B4..#17F7)",180,5955},
--      {".dynstr (#E8..#FF)",232,24},
--      {".text (#1800..#68BF)",6144,20672},
--      {".shstrtab (#758C..#75EB)",30092,96},
--      {".symtab (#77F4..#78A3)",30708,176},
--      {".strtab (#78A4..#78AF)",30884,12}}
--DEV still wrong (not as below) 1/4/16:
--GraphR:{{"ELF Header (#0..#33)",0,52},
--        {"Program Headers (#34..#B3)",52,128},
--        {"Section Headers (#75EC..#77F3)",30188,520},
--        {"Dynamic Link Info (#7000..#708F)",28672,144},
--        {"Symtab (#B4..#17F7)",180,5955},
--        {".dynstr (#E8..#FF)",232,24},
--        {".text (#1800..#68BF)",6144,20672},
--        {".shstrtab (#758C..#75EB)",30092,96},
--        {".symtab (#77F4..#78A3)",30708,176},
--        {".strtab (#78A4..#78AF)",30884,12}}
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\linux_dynamic\\libmain.so")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\linux_dynamic\\libmain64.so")
--missing symtab...
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\elf\\dyn64.bin") -- (soso)
--not going well:
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\hello32.so") -- (soso)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\hellotest32")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\fdbg0025\\fdbg.exe")    -- got as far as fdbg
--  load_file("C:\\Program Files (x86)\\Phix\\test\\fdbg0025\\fasm.exe") -- (32 bit)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\PE64DEMO\\PE64DEMO.EXE") -- perfect!
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\hwc64.EXE") -- moving import above data triggers false positive
--these need "de-macroing":
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\MANDEL\\MANDEL.EXE") -- good (even the sse2 instructions...) [d/m started, bit too much...]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\OPENGL\\OPENGL.EXE") -- seems fine apart from some movd mm/xmm doubts
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\TEMPLATE\\TEMPLATE.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\TEMPLATE.EXE") -- perfect ("" de-macroed)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\templater.exe") -- "" (with resource section)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\templaterp.exe") -- ""         "" (de-macroed)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\divsd.exe") -- perfect
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\main.exe") -- perfect
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\libtest.dll") -- perfect (but no imports) [64 bit]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\cbeer.exe") -- perfect
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\WIN64\\USECOM\\USECOM.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasmu\\fasm\\fasm.o") -- unsupported file type (relocatable) [DEV??]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasmu\\fasm\\examples\\libcdemo\\libcdemo.o") -- unsupported file type (relocatable)
--32bitpe:
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\BEER\\BEER.EXE") -- confused by single ".flat" section (who cares)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\DDRAW\\DDRAW.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\DIALOG\\DIALOG.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\DLL\\ERRORMSG.DLL") -- good, could suffer a de-macro
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\errormsg.dll") -- damn, looks like we need a relocations section...
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\DLL\\LASTERR.EXE") -- good, could suffer a de-macro [DONE, see next]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\lasterr.exe") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\HELLO\\HELLO.EXE") -- good, could (definitely) suffer a de-macro
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\hello.exe") -- good (moving import section above data triggers false positive...)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\hello.exe") -- good (see?...)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\MINIPAD\\MINIPAD.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\OPENGL\\OPENGL.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\TEMPLATE\\TEMPLATE.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\USECOM\\USECOM.EXE") -- good
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\EXAMPLES\\PEDEMO\\PEDEMO.EXE") -- good, try getting rid of that relocations section? (done, see next)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\pedemo32.exe") -- perfect. HEY: changing "PE GUI" to "PE GUI 4.0" stopped the false positive!!
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\pedemo32.exe") -- false positive
--C:\Program Files (x86)\Phix\asm\fasm>fc pedemo32.exe test\pedemo32.exe
--Comparing files pedemo32.exe and TEST\PEDEMO32.EXE
--00000088: D6 FC   DateTimeStamp
--00000089: 8C 8D   
--000000C8: 04 03   MajorSubsystemVersion
--000000CA: 00 0A   MinorSubsystemVersion
--000000D8: 63 92   CheckSum
--000000D9: 33 34
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\test\\elf32.exe") --uh?
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\test\\elf64.exe") --uh?
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\misc\\bcx\\bc9Adp\\RadAsm\\Addins\\ProjectZip.dll") -- (no import section tab, who cares)
--  load_file("F:\\CFULL\\HDD (C)\\Program Files\\Phix\\euiup3.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Downloads\\PFx86\\Edita\\gdiplus.dll")
--DEV this seems a reasonable one to address the RVA/section overlap issue:
--  load_file("F:\\CFULL\\HDD (C)\\Downloads\\PFx86\\Phix\\demo\\file_lister\\euwingui\\EuWinGUI.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Downloads\\PFx86\\Phix\\dll\\testd.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Downloads\\PFx86\\Phix\\dll\\lb\\test.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Downloads\\PFx86\\Phix\\dll\\lb\\test_diag_and_mb.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Program Files\\7-Zip\\7-zip.dll")
--  load_file("F:\\CFULL\\HDD (C)\\Program Files\\7-Zip\\7z.dll")   -- good (spotted a (non-Phix!) jump table we accidentally dissassemble)
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\misc\\mandelbrot_opt\\iterate.dll")
--DEV get that file addr,virtual addr thing going for elf: [DONE, I think]
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\et\\elf32")  -- hello world 32bit
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\et\\elf64")  -- hello world 64bit
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\et\\pe32.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\et\\pe64.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\pe32.exe")   --(OLD?)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\pe64.exe")   --(OLD?)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\e01.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\e01.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\ok64.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\misc\\Speech\\Speech.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\e02.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\arwenpcomdemo\\fileopen.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\eicar.com")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\Win32Demo\\boxes.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\b\\boxes.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\b\\boxes.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\p6.exe")
--  load_file("C:\\Program Files (x86)\\Phix6\\p.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\rosetta\\AtomicUrpdates.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\FP\\t02.exe")
--  load_file("C:\\Edita14\\bitmap_write.ppm")
--  load_file("C:\\Edita14\\rayv3\\ex.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\p7.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\p64.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\EuGTK_4.3.2\\EuGTK_Win_Aug10\\eugtkdem\\gtk2\\LIBGLIB-2.0-0.DLL")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\EuGTK_4.3.2\\EuGTK_Win_Aug10\\eugtkdem\\gtk2\\libgio-2.0-0.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euphoria-4.1.0-ARMv6-hardfloat\\bin\\eui")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euphoria-4.1.0-ARMv6-hardfloat\\bin\\echoversion")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euphoria-4.1.0-ARMv6-hardfloat\\bin\\eutest")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\libcairo-2.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\libfontconfig-1.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\libfreetype-6.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\libpng15-15.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\zlib1.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\eucairo\\libxml2-2.dll")
--  load_file("C:\\Windows\\SysWOW64\\ws2_32.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\pIUP\\win14\\lnx32\\libiupcontrols.so")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\pIUP\\win14\\lnx32\\libiup.so")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\pIUP\\win14\\lnx32\\libiupcd.so")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\pIUP\\win14\\lnx32\\libcd.so")
--libcairo-2.dll libfontconfig-1.dll libfreetype-6.dll libpng12.dll zlib1.dll libxml2-2.dll
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euiup\\iup.dll")
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\phix\\sfx\\ledc")
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\phix\\sfx\\win32\\test.exe")

--  load_file("C:\\Program Files (x86)\\Phix\\e06.dll")
--  load_file("C:\\Program Files (x86)\\Phix\\e06.so")
--  load_file("C:\\Program Files (x86)\\Phix\\pth.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\e01.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\e03.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\e09.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t00.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t01type.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t02parms.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t04unary.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t18equal.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\test\\e01z.exe")
--  load_file("C:\\euphoria\\e01.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\e01")
--  load_file("C:\\Program Files (x86)\\Phix\\e07.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\eui-unpacked.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t60.exe")
--  load_file("C:\\Users\\Pete\\Downloads\\ollydbg\\p.udd")
--  load_file("C:\\Users\\Pete\\Downloads\\ollydbg110\\e01.udd")
--  load_file("C:\\Users\\Pete\\Downloads\\ollydbg110\\pw.udd")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\tee\\simple_notepad.exe")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\sudoku.exe")
--  load_file("C:\\Users\\Pete\\Documents\\a00.exe")    -- win64 exceptions
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\a00.exe")  -- win64 exceptions
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\l00")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\e00")  -- lnx exceptions
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\brainkrieg.exe")
--big holes in GraphR:
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\skeleton.bin")
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\fasm_amd64_linux64_samples\\include\\fdbg")
--DEV at least binary dump the missing bits!
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\elf\\elf32gtk.bin")
--this one actually works: (but dump is awful)
--  load_file("C:\\Program Files (x86)\\Phix\\asm\\elf\\gtk32.bin")

--  load_file("C:\\Program Files (x86)\\Phix\\asm\\fasm\\dynelfexe\\test")  -- ** PERFECT!! ** [now with 2 libs!!]
--  load_file("C:\\Program Files (x86)\\Phix\\e03") --**PERFECT**
--  load_file("C:\\Program Files (x86)\\Phix\\e01")
--  load_file("C:\\Program Files (x86)\\Phix\\pth")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t01type")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t38bltns")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t39rndio")
--  load_file("C:\\Program Files (x86)\\Phix\\test\\t40rtnid")
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\libdl-2.19.so")
--  load_file("C:\\Users\\Pete\\Downloads\\qman70\\Share\\libc-2.19.so")
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\SHA\\SHA.DLL")
--DEV much more work required: (any relocation to part of distro) [also need a 32 bit version]
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euglfw3_2\\EuGLFW3\\Bin\\libglfw.so.3.1")
--DEV much more work required: (any relocation to part of distro) [also need a 64 bit version]
--  load_file("C:\\Program Files (x86)\\Phix\\demo\\libxlsxwriter\\euglfw3_2\\EuGLFW3\\Bin\\glfw3.dll")
--  WinMain(Main,SW_NORMAL)
--end procedure
--main()

--/*
ARM disassembly:
$ arm-linux-objdump -d test.elf              
Disassembly of section .startup:
00010000 :
   10000:       e59fd004        ldr     sp, [pc, #4]    ; 1000c 
   10004:       eb00004c        bl      1013c 
   10008:       eafffffe        b       10008 
   1000c:       0001116c        .word   0x0001116c
   10010:       00002141        .word   0x00002141
   10014:       61656100        .word   0x61656100
   10018:       01006962        .word   0x01006962
   ...
Disassembly of section .text:
000100e8 :
   100e8:       e1a0c00d        mov     ip, sp
   ...
registers r0..r15, all 32 bits, 
plus cpsr:
    31 30 29 28
     N  Z  C  V
ala a1,a2,a3,a4,v1,v2,v3,v4,v5,v6,sb,sl,fp,sp,lr,pc
r13/sp is the stack pointer (more by convention in ARM, hardwired in Thumb)
r14/lr is link register (return address)
r15/pc is program counter

--          11..8 7..0
            rot4  imm8

Instructions in ARM mode are 32-bits wide, must be dword-aligned, ps in bits[31:2] and bits pc[1:0] are undefined
Instructions in Thumb mode are 61-bits wide, must be word-aligned, ps in bits[31:1] and bits 0 is undefined
<operation>{cond}{flags} Rd,Rn,Operand2
mov, mvn, add, adc, sub, sbc, rsb, rsc, and, eor, orr, bic, cmp, cmn, tst, teq, b, bl, mul, mla, umull, umlal, smull, smlal, ldr, str, ldm, stm
(mul, clz, qadd, pld, blx) [bx = mov pc,r14?]
(rrx encoded as ror #0)
Barrel shifts: lsl, lsr, asr, ror, rrx
Size: B, H, and (LDR only) SB, SH
modes IA, IB, DA, DB
    FD: stmfd/ldmfd = stmdb/ldmia
    ED: STMED/LDMED = STMDA/LDMIB
    FA: STMFA/LDMFA = STMIB/LDMDA
    EA: STMEA/LDMEA = STMIA/LDMDB

valid constants: #FF, #FF0, #FF000000, #F000000F
invalid constants: #1FE, #F000F0000, #55550000
tricks, eg mov r0,#FFFFFFFF -> mvn r0,#0
MOV r2, #0x55           ; R2 = 0x00000055
ORR r2, r2, r2, LSL #8  ; R2 = 0x00005555
ORR r2, r2, r2, LSL #16 ; R2 = 0x55555555
branches are pc-relative (+/132M range (24 bits * 4 bytes)

Code    Suffix  Description                             Flags
0000    EQ      Equal / equals zero                     Z
0001    NE      Not equal                               !Z
0010    CS / HS Carry set / unsigned higher or same     C
0011    CC / LO Carry clear / unsigned lower            !C
0100    MI      Minus / negative                        N
0101    PL      Plus / positive or zero                 !N
0110    VS      Overflow                                V
0111    VC      No overflow                             !V
1000    HI      Unsigned higher                         C and !Z
1001    LS      Unsigned lower or same                  !C or Z
1010    GE      Signed greater than or equal            N == V
1011    LT      Signed less than                        N != V
1100    GT      Signed greater than                     !Z and (N == V)
1101    LE      Signed less than or equal               Z or (N != V)
1110    AL      Always (default)                        any

$> readelf -a ./arm32_mov
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          148 (bytes into file)
  Flags:                             0x5000000, Version5 EABI
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         8
  Section header string table index: 5

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 00000c 00  AX  0   0  4
  [ 2] .data             PROGBITS        00000000 000040 000000 00  WA  0   0  1
  [ 3] .bss              NOBITS          00000000 000040 000000 00  WA  0   0  1
  [ 4] .ARM.attributes   ARM_ATTRIBUTES  00000000 000040 000016 00      0   0  1
  [ 5] .shstrtab         STRTAB          00000000 000056 00003c 00      0   0  1
  [ 6] .symtab           SYMTAB          00000000 0001d4 000070 10      7   7  4            <--***
  [ 7] .strtab           STRTAB          00000000 000244 000007 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.
There are no program headers in this file.
There are no relocations in this file.
There are no unwind sections in this file.

Symbol table '.symtab' contains 7 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 SECTION LOCAL  DEFAULT    1 
     2: 00000000     0 SECTION LOCAL  DEFAULT    2 
     3: 00000000     0 SECTION LOCAL  DEFAULT    3 
     4: 00000000     0 NOTYPE  LOCAL  DEFAULT    1 $a
     5: 00000008     0 NOTYPE  LOCAL  DEFAULT    1 $t
     6: 00000000     0 SECTION LOCAL  DEFAULT    4 

No version information found in this file.
Attribute Section: aeabi
File Attributes
  Tag_CPU_arch: v4T
  Tag_ARM_ISA_use: Yes
  Tag_THUMB_ISA_use: Thumb-1

http://www2.onlinedisassembler.com/odaweb/strcpy_arm

        .data:0x00000000        e1a0000d        mov     r0, sp   
        .data:0x00000004        e3a01000        mov     r1, #0   
        .data:0x00000008        e28f2004        add     r2, pc, #4       
        .data:0x0000000c        e28f3004        add     r3, pc, #4       
        .data:0x00000010        eafffff7        b      0xfffffffffffffff4        
        .data:0x00000014        ea000005        b      loc_00000030      
        .data:0x00000018        00009360        andeq   r9, r0, r0, ror #6       
        .data:0x0000001c        00009368        andeq   r9, r0, r8, ror #6       
        .data:0x00000020        00009370        andeq   r9, r0, r0, ror r3       
        .data:0x00000024        00009378        andeq   r9, r0, r8, ror r3       
        .data:0x00000028        e1a00000        nop                     ; (mov r0, r0)   
        .data:0x0000002c        e1a00000        nop                     ; (mov r0, r0)   
        .data:0x00000030                        
        .data:0x00000030                loc_00000030:   
        .data:0x00000030        e1a0c00d        mov     ip, sp   
        .data:0x00000034        e92dd800        push    {fp, ip, lr, pc}         
        .data:0x00000038        e59f000c        ldr     r0, [pc, #12]   ; 0x0000004c     
        .data:0x0000003c        e24cb004        sub     fp, ip, #4       
        .data:0x00000040        ebffffe8        bl     func_ffffffffffffffe8     
        .data:0x00000044        e3a00001        mov     r0, #1   
        .data:0x00000048        e89da800        ldm     sp, {fp, sp, pc}         
        .data:0x0000004c        00008340        andeq   r8, r0, r0, asr #6
--*/
