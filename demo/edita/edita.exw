--with profile_time

--
-- Edita.exw
-- =========
--
-- Programmers editor written in Phix(/Euphoria) using the arwen gui library.
-- Author Pete Lomax January 2005.
--
--DEV (temp)
global constant usegpp=1

--global constant eaversion = "0.0.9 (03/03/05)"
--global constant eaversion = "0.1.0 (15/04/05)"
--global constant eaversion = "0.1.1 (16/04/05)"
--global constant eaversion = "0.1.2 (26/04/05)"
--global constant eaversion = "0.1.3 (28/04/05)"
--global constant eaversion = "0.1.4 (28/04/05)"
--global constant eaversion = "0.1.5 (13/05/05)"
--global constant eaversion = "0.1.6 (18/05/05)"
--global constant eaversion = "0.1.7 (05/07/05)"
--global constant eaversion = "0.1.8 (19/08/05)"
--global constant eaversion = "0.1.9 (01/08/05)"
--global constant eaversion = "0.2.1 (20/08/05)"
--global constant eaversion = "0.2.2 (08/09/05)"
--global constant eaversion = "0.2.3 (15/09/05)"
--global constant eaversion = "0.2.4 (20/09/05)"
--global constant eaversion = "0.2.5 (06/11/05)"
--global constant eaversion = "0.2.6 (26/11/05)"
--global constant eaversion = "0.2.7 (23/12/05)"
--global constant eaversion = "0.2.8 (03/03/07)"
--global constant eaversion = "0.2.9 (06/05/07)"
--global constant eaversion = "0.3.0 (30/05/07)"
--global constant eaversion = "0.3.2 (12/03/10)"
--global constant eaversion = "0.3.3 (27/04/10)" --???
--global constant eaversion = "0.3.5 (20/04/11)"
global constant eaversion = "0.3.6 (02/08/15)"
--
-- If you want to redistribute a modified Edita, in either source or pre-built form,
--  please change above to eg eaversion = "n.n.n (as modified by Xxxx Xxxx dd/mm/yy)"
--

--/**/with gui 4.0
without trace
--with trace
--trace(3)

global sequence isWindowPos,        -- top left corner
                isWindowRect,       -- window size
                isFaceName          -- Font name

global atom isPointSize     -- stored as integer no of tenths.
                
global integer  isDebug,                -- see eanotes.txt
                isWindowMaximised,      -- whether Window is[was] maximised [at shutdown]
                isShowFullPath,         -- show full path or just filename in titlebar
                isToolBarVIS,           -- toolbar visible
                isTabBarVIS,            -- tabbar visible
                isSingleDir,            -- tabbar shows files from single dir
                isMultiLineTab,         -- tab bar has TCS_MULTILINE style
                isTabottom,             -- tab bar at bottom
                isTabsOwnerDrawn,       -- owner drawn tabs (recommended)
                isRaggedRight,          -- use ragged right tabs style
                isFilePanelVIS,         -- Directory/Project panel visible
                isFilePanelWidth,       -- file panel area width
                isMessageVIS,           -- message area visible
                isMessageHeight,        -- message box height
                isHScrollVIS,           -- horizontal scroll bar
                isVScrollVIS,           -- vertical scroll bar
                isMoveCursorOnScroll,   -- (cancels selection)
                isScrollPerm,           -- always show scrollbars (reduces flicker on tab switch)
                isFoldMarginPerm,       -- always show fold margin (so mouse click always possible)
                isStatusBar,            -- status bar
                isWordWrapON,           -- NEW wordwrap flag set/saved on a file-by-file basis.
                isFormatErr,            -- reformat ex.err
                isSingleInstance,       -- single instance handling
                isRestoreOnOpen,        -- open previous files
                isAutoSaveOnExit,       -- suppress any warnings, just save altered files
                isAutoSaveOnTabSwitch,  -- save files on tab switch
                isAutoSaveTimer,        -- save files every nnn seconds
                isAutoBackup,           -- create backups
                isLoadErrFileOnError,   -- now jumps to line with summary on statusbar
                isReplaceTabs,          -- save file with no \t
                isLegacyTabHandling,    -- Legacy Tab Character Handling
                isTabWidth,             -- Tab Width (1..8)
                isHomeFirstNonBlank,    -- Home jumps to first non-blank character
                isLineNumbers,          -- show line numbers?
                isMarginSpace,          -- space after margin?
                mouseWheelScroll,       -- wheelmouse multiplier
                isCaretBlinkTime,       -- Caret Blink Time in milliseconds
--              isLineLengthError,      -- set to 0 to inhibit error messages
                isAutoComplete,         -- 1 if autocompletion enabled
                isBackGround,           -- 1 if background processing enabled
                isCurrProject,          -- 0 if no project selected
                isClearOverStrike,      -- clear overstrike mode
                isUndoTime,             -- retain undo actions for nn seconds
                isRetainBackupsFor,     -- retain automatic backups for nn days
                isCloseLeft             -- close tabs to left?
                
global constant isShowBGprogress = 1    --DEV option?

global 
integer isFTP               -- 1 if opened via "Edit with Edita" else 0
        isFTP = 0

isWordWrapON = 0 --False

global object   isLegacyTcod        -- Legacy Tab Character Handling cut-off date

global sequence isToolSet

global sequence crashpath

global integer FileMenu
global integer WinMenu

global integer paintRqd     -- +ve=line [1..linesPerPage] next requiring display.
               paintRqd = 0 -- 0 when all lines have been properly displayed
global -- for easynclr.e
integer paintLast           -- if non-zero, last line to be painted
        paintLast = 0

global -- for easynclr.e (shade in selX,Y to CursorX,Y)
integer CursorX,    -- 0 for column 1 (ie insert before first character)
        CursorY,    -- 0 for line 1 (in range 0..length(filetext[currfile])-1)
        TopLine,    -- line no corresponding to top of screen (0-based)
        Column,     -- column (0-based)
        TopChunk    -- start point for wordwrap of TopLine

TopChunk = 0

global integer runBack      -- set to 1 to start background processing
               runBack = 1

-- bits of isClearOverStrike:
global constant cOVRup      =#01,
                cOVRdown    =#02,
                cOVRfile    =#04,   -- default
                cOVRpage    =#08,   -- default
                cOVRpaste   =#10,
                cOVRdupline =#20,
                cOVRhome    =#40

--
-- The following is the result of trying to keep Edita sources compatible with Phix,
--  RDS Eu 2.4, and OpenEuphoria, which all have subtly different include handling.
--  (Of course the handling in Phix is the best, by any measure!)
-- You should not normally have to jump through such hoops.
--

--Phix:
--DEV(newEmit)
--!/**/include builtins\pcmdln.e
--DEV (newEBP)
--!/**/include builtins\penv.e
--/**/include builtins\psqop.e
--/**/include builtins\misc.e
--/**/include builtins\pdate.e
--DEV (newEBP)
--!/**/include builtins\pcfunc.e
--!/!*!*!/!include builtins\platform.e
--/**/include builtins\pcurrdir.e
--!/**/include builtins\pprntf.e
--!/**/include builtins\psprint.e
--/**/include builtins\dll.e

--#include arwen\Arwen.ew

--RDS Eu 2.4 and OpenEuphoria 4.0.2:
--/*
include ..\Phix\builtins\dll.e
include ..\Phix\builtins\machine.e
include ..\Phix\builtins\misc.e
include ..\Phix\builtins\sort.e
include ..\Phix\builtins\file.e
include ..\Phix\builtins\get.e
include ..\Phix\builtins\database.e
include arwen\misc_arwen.e
include arwen\message_box.ew
include arwen\constants.ew
include arwen\structures.ew
include arwen\dll_links.ew
include arwen\Quick_Allocations.ew
include ..\Phix\builtins\pgetpath.e
include ..\Phix\builtins\ppp.e
include ..\Phix\builtins\get.e
include arwen\classes.ew
--*/

include ..\arwen\Arwen.ew
--include arwen\imagelists.ew   -- not needed
--include arwen\pCom.ew
--!/**/include ..\arwen\fileopenN.ew
--/**/include builtins\fileopenN.ew

-- XP compatibility:
--!/**/global constant newopendialog=01
--/**/global constant newopendialog=(xSHCreateItemFromParsingName!=-1)

include src\eamisc.e    -- UpperCase, LowerCase, Min, Max, curb, iff, despace
include src\eaxlate.e

--with trace

global constant
    Edita = xl("Edita"),
    untitled = xl("[untitled]"),
    Main = create(Window, Edita, 0, 0, 0, 0, 410, 300, 0),
    mainDC = getPrivateDC(Main),
    mainHwnd = getWindowHwnd(Main)
    setIcon(Main,loadIcon("95.ico"))

include src\easinst.ew  -- Single instance handling


global constant
    TB = create(ToolBar,"",0,Main,0,0,25,25,0)                                          -- ToolBar
global integer TC
--now done in eaini:
--  TC = create(TabControl, "" , 0, Main, 0,0,372,122,TCS_MULTILINE)                    -- Tab Control
global atom TChwnd
--now done in eaini:
--  TChwnd = getHwnd(TC)
global integer TChandler

global constant 
    TV = create(TabControl, "" , 0, Main, 0,10,370,298,{{TCS_MULTILINE,TCS_BOTTOM},0}), -- Treeview (aka File Panel)
    TVcls = create(PictureButton,"",
--                 c_func(xLoadBitmap,{NULL,OBM_CLOSE}), -- does not work ;-((
                   loadImage(initialcurrentdir&"bitmaps\\eaexit.bmp",IMAGE_BITMAP,0),
                   TV,200,4,20,20,0)
    setVisible(TB,False)

global integer rtnList  -- ComboDropDownList (created in eamenus)
               rtnList = 0

constant tvHwnd = getHwnd(TV),  tvclsHwnd = getHwnd(TVcls)

constant
    TVproj = create(TabItem,xlna("Project"),0,TV,0,0,0,0,TCS_FOCUSNEVER)
global constant
    TVprjl = create(TreeView,"",0,TVproj,10,10,312,244,{{TVS_EDITLABELS,TVS_SHOWSELALWAYS},0}),
    TVprjt = create(Label,"",0,TVproj,0,0,0,0,SS_SUNKEN)

global integer checkProj        -- repaint TVprjl when needed (if it is visible)
               checkProj = 0

constant
    TVdir = create(TabItem, xlna("Directory"), 0, TV, 0,0,0,0,TCS_FOCUSNEVER)
global constant
    TVdirl = create(TreeView, "", 0, TVdir,10, 10, 312, 244, {{TVS_EDITLABELS,TVS_SHOWSELALWAYS},0})

--DEV do not create if isAutoBackup is zero:
global constant
    TVrecov = create(TabItem, xlna("Recovery"), 0, TV, 0,0,0,0,TCS_FOCUSNEVER),
    TVrecl = create(TreeView, "", 0, TVrecov,10, 10, 312, 244, {{TVS_CHECKBOXES,TVS_SHOWSELALWAYS},0})
constant 
    PDRkeys = {xla("Project"),xla("Directory"),xla("Recovery")},
    PDRids = {TVproj,TVdir,TVrecov},
    ULIW = {xlalt("Upper\t(Alt U)"),
            xlalt("Lower\t(Alt L)"),
            xlalt("Invert\t(Alt I)"),
            xlalt("Wordwrap\t(Alt W)")}

--  ,
--  TVrecdel = create(Button, xlna("Delete"), 0, TVrecov, 0,0,50,25,0)

global constant
    MA = create(MultiEditText,"",0,Main,0,0,0,0,WS_SIZEBOX),                -- Message Area
    SB = create(StatusBar,  "", 0, Main, 0, 0, 0, 25, SBARS_SIZEGRIP )      -- Status Bar
constant 
    maHwnd = getHwnd(MA),
    HHH = create(HScroll,    "", 0, Main, 0,0,0,0, 0),
    VVV = create(VScroll,    "", 0, Main, 0,0,0,0, 0),
    SB0 = create(StatusField,"", 0, SB, 0, 0, 3, 0, 0 ), -- Win95 bug
    SB1 = create(StatusField,"", 0, SB, 0, 0, 200, 0, 0 ),
    SB2 = create(StatusField,"", 0, SB, 0, 0, 35, 0, 0 ),
    SB3 = create(StatusField,"", 0, SB, 0, 0, 45, 0, 0 ),
    SB4 = create(StatusField,"", 0, SB, 0, 0, 190, 0, 0 ),
    SB5 = create(StatusField,"", 0, SB, 0, 0, 60, 0, 0 )
global constant -- used by eamacro.ew and eamenus.ew
    SB6 = create(StatusField,"", 0, SB, 0, 0, 0, 0, 0 )

global integer clearSB6
               clearSB6 = 0

if SB0 then end if  -- suppress warning

global  -- for eaini.e
sequence filenames, filepaths, filetext, unicodefile, filelinelengths, 
         filecursel, bCfwds, filedt
         filenames = {}  filepaths = {}  filetext = {}  unicodefile = {}  
         filelinelengths = {}  filecursel = {}  bCfwds = {}  filedt = {}
--
--DEV being fixed (get_proper_path) as we speak (27/04/2010)
-- Probably a mistake, but names are currently held in lowercase and paths in uppercase,
-- to avoid opening /both/ C:\\edita\\EDITA.EXW /and/ c:\\EDITA\\edita.exw. It would be 
-- better, probably, to use Upper/LowerCase on-the-fly, but edita.edb is the problem...
--
-- filetext should be fairly obvious, but see unpacked below.
-- for filelinelengths, see linelengths/readFile() below.
-- for filecursel, see save/restcursel() below.
-- for bCfwds, see easynclr.e.

global -- for eacomp  DEV: possibly needed for eafif/eacca/eaxutil...
sequence unpacked       -- 0=just loaded, -1=fully unpacked, +ve=unpacked to line nnn
         unpacked = {}

global -- for eamenus.ew
sequence wrapped        -- 0=just loaded or isWordWrapON (aka filecursel[c][11])=0,
         wrapped = {}    -- -1=fully unpacked, +ve=unpacked to line nnn

integer wrappedWidth        -- charsWide at last update of wrapped.
        wrappedWidth = -1   -- if this is not=charsWide, then set wrapped @= 0

global -- for eaedb, saveFolds/loadFolds, also checked by eaopts.ew.
sequence bookmarks      -- {{{type,start,end}}} sets. Also holds folds and wordwraps.
         bookmarks = {}

global constant MARK = #01, FOLD = #02, WRAP = #04

global constant bfType = 1,     -- bit #01 indicates a bookmark, 
                                -- bit #02 a fold,
                                -- bit #04 a wordwrap.
                                -- #03 (=MARK+FOLD), #05 (=MARK+WRAP) valid, but #06, #07 not.
                bfStart = 2,    -- start line (0-based)
                bfEnd = 3       -- end line (0-based) if #02 set,
                                -- {col} (0-based) if #04 set,
                                -- unused on mark-only lines.
--
-- Note that (as of 0.3.0) length(bookmarks[c])=length(filetext[c]), though it is saved
--  in edita.edb in a more "packed" form (see eaedb.e).

-- used (read-only) by easynclr.e, toggled by eaopts.ew, and/or setMarginRqd():
global integer marginRqd

global constant rtnNAMES = 1,  rtnSTART = 2,  rtnEND = 3
global sequence routines
                routines = {}
--
-- routines[c] is eg {{"me","my","x","y",},{2,10,30,34},{8,18,32,36}}, 
-- where file number c (matching filenames, filetext etc) 
-- has: "me" defined as a routine on lines 2 to 8 inclusive, 
--      "my" as lines 10 to 18 inclusive,
--      "x" as lines 30..32, and
--      "y" as lines 34..36.
-- NB: unlike may others in Edita, line nos herein are 1-based.
--  (totally daft, but left asis on "don't fix what ain't broken" basis)
-- To recap, note that length(routines[c]) should always be 3, and that
--  length(routines[c][1])=length(routines[c][2])=length(routines[c][3])
--


global object bCfwd -- bracket carry-forward info (see easynclr.e)

global  -- see eaundo.ew
sequence actions,   -- {sequence}   -- (as above)
         actionptr, -- {integer}    -- undo/redo point
         actionsave -- value of actionptr at last save, or -1.
    actions = {}
    actionptr = {}
    actionsave = {}

--with trace
--integer catchSelChg
--      catchSelChg = 0
--integer lO
--type sOt(integer sO)
--  if catchSelChg and sO!=lO then trace(1) end if
--  lO = sO
--  return 1
--end type
--global sOt selON  -- 1 if selection is active, 2 if column mode, else 0
--global integer
global integer selON, -- 1 if selection is active, 2 if column mode, else 0
               selX,    -- selection anchor, if any (0-based)
               selY -- (in range 0..length(filetext[currfile])-1)
    selON = 0

integer maxlen
        maxlen = 0

global -- for eamenus.ew and eafext.ew
sequence tabs       -- children of TC
         tabs = {}

global integer rRebuildTabBar       -- routine rebuildTabBar() in eamenus.ew
               rRebuildTabBar = 0   -- zero for eaini.e stage

global -- for eaini.e
integer currfile
        currfile = 0
integer tabfile         -- tab if right clicked
        tabfile = 0     -- (overrides currfile, reset on use)

--global -- for eaopts.ew --?? removed 27/3/10
integer linesPerPage
        linesPerPage = 0
global -- used by eaerr.e
integer charsWide
        charsWide = 0

global procedure paintall()
-- Just set a flag and let idleHander do the work.
    if not paintRqd then startIdle(250) end if
    paintRqd = 1
    paintLast = 0
end procedure

global procedure setMarginRqd()
-- sets marginRqd to 1 or 0.
-- Note that IdleHandler resets marginRqd = 1 to 
--  length(sprintf("%d",length(filetext[currfile])))
integer mr
sequence BookMarkSet
object bi
    mr = isLineNumbers or isFoldMarginPerm
    if not mr then
        BookMarkSet = bookmarks[currfile]
        for i=1 to length(BookMarkSet) do
            bi = BookMarkSet[i]
            if sequence(bi)
            and bi[bfType]!=WRAP then   -- not WRAP-only then
                mr = 1
                exit
            end if
        end for
    end if
    if (mr=0)!=(marginRqd=0) then
        marginRqd = mr
        paintall()
    end if
end procedure

integer landingChunk    -- for showCaret() ONLY; iff CursorY,CursorX *is* on-screen
integer endChunk

--with trace
-- used by eamenus.ew:
without trace
global function distanceFromTopLine(integer cY, integer cX)
--
-- calculate the distance of cY,cX from TopLine,TopChunk in terms of screen lines,
-- accounting for any folds or wordwrapped lines betwixt (inclusive).
-- Returns a value in the range 0..linesPerPage-1 if cY,cX is on-screen.
-- As used by forceCursorOnscreen, if the result is -1, scroll up one line,
-- if the result is linesPerPage, scroll down one line.
-- The setting of landingChunk is quite specialised and should be used with caution.
-- (it is 0 or the wrap entry colno that cY,Cx lies on).
--
integer d,  -- result var
    wY, wX, -- working position
    tY, tX, -- target position
    sign,   -- direction flag/increment
    getNiL, bmistart, nextImportantLine,
    FW  -- FOLD+WRAP, or just FOLD if isWordWrapON=0
sequence BookMarkSet
object SetEntry
integer prevWW,thisWW

    BookMarkSet = bookmarks[currfile]
    if cX<0 then  cX = 0  end if
    if cY<TopLine 
    or (isWordWrapON and cY=TopLine and cX<TopChunk) then
        tY=  TopLine   tX = TopChunk   wY = cY   wX = cX   d = -1   sign = -1
    else
        wY = TopLine   wX = TopChunk   tY = cY   tX = cX   d = 0   sign = 1 
    end if
    landingChunk = TopChunk
    endChunk = 0
    if isWordWrapON then
        FW = FOLD+WRAP
    else
        FW = FOLD
    end if
    getNiL = True
    bmistart = 0
    if wY<tY
    or (isWordWrapON and wY=tY and wX<tX) then
        while 1 do
            if getNiL then
                getNiL = False
                nextImportantLine = -1
                for i=bmistart+1 to length(BookMarkSet) do
                    SetEntry = BookMarkSet[i]
                    if sequence(SetEntry) then
                        if SetEntry[bfStart]>=wY 
                        and and_bits(SetEntry[bfType],FW) then
                            nextImportantLine = SetEntry[bfStart]
                            bmistart = i
                            exit
                        end if
                    end if
                end for
            end if
            landingChunk = 0
            if wY=nextImportantLine then
                if and_bits(BookMarkSet[bmistart][bfType],FOLD) then
                    wY += BookMarkSet[bmistart][bfEnd]-nextImportantLine+1
                    getNiL = True
                else    -- a wrap
                    prevWW = 0
                    for i=1 to length(BookMarkSet[bmistart][bfEnd]) do
                        thisWW = BookMarkSet[bmistart][bfEnd][i]
                        if wX<thisWW then
                            wX += thisWW-prevWW
                            landingChunk = prevWW
                            endChunk = thisWW
                            prevWW = -1
                            exit
                        end if
                        prevWW = thisWW
                    end for
                    if prevWW!=-1 then  -- hit end w/o nudge
                        wY += 1
                        wX -= thisWW
                        landingChunk = thisWW
                        endChunk = 0
                        getNiL = True
                    end if
                end if
            else
                wY += 1
            end if
            if wY>tY then exit end if
            if isWordWrapON and wY=tY and wX>tX then exit end if
            d += sign
        end while
    end if
    return d
end function
--with trace


integer nacX    -- new adjusted cX, the 3rd param of adjustLine()
        -- note: nacX may be past EOL, callee should use
        --      pref. checkCursorX() after to fixup.

--with trace
function adjustLine(integer lineno, integer adjust, integer cX)
-- 
-- lineno is 0-based, as per bookmarks, CursorY, and TopLine.
-- In fact the usual value passed as lineno is either CursorY or TopLine.
-- adjust is usually +1, -1, linesPerPage, or -linesPerPage.
-- cX is usually CursorX when lineno is CursorY, and TopChunk with TopLine.
--
-- Returns an integer in the range 0..length(filetext[currfile]) [NB over by 1] **DEV-1.
--
integer nextImportantLine, foldIdx, lenfiletxtcurrfile
integer getNIL
sequence BookMarkSet
object SetEntry
object BiE
integer FW
    BookMarkSet = bookmarks[currfile]
    lenfiletxtcurrfile = length(filetext[currfile]) ---1
    nacX = cX
    if isWordWrapON then
        FW = FOLD+WRAP
    else
        FW = FOLD
    end if
    if adjust>0 then
        while adjust>0 and lineno<lenfiletxtcurrfile do
            SetEntry = BookMarkSet[lineno+1]
            if sequence(SetEntry) then
                if and_bits(SetEntry[bfType],WRAP) and isWordWrapON then
                    BiE = SetEntry[bfEnd]
                    if selON!=2 then
                        if nacX<BiE[length(BiE)] then
                            for j=1 to length(BiE) do
                                if nacX<BiE[j] then
                                    nacX += BiE[j]
                                    if j>1 then
                                        nacX -= BiE[j-1]
                                    end if
                                    if j<length(BiE) 
                                    and nacX>=BiE[j+1] then
                                        -- cursor down onto shorter line:
                                        nacX = BiE[j+1]-1
                                    end if
                                    exit
                                end if
                            end for
                        else
                            nacX -= BiE[length(BiE)]
                            lineno += 1
                        end if
                    else
                        adjust -= length(SetEntry[bfEnd])
                        lineno += 1
                    end if
                elsif and_bits(SetEntry[bfType],FOLD) then
                    lineno += SetEntry[bfEnd]-SetEntry[bfStart]+1
                else
                    lineno += 1
                end if
            else
                lineno += 1
            end if
            adjust -= 1
        end while

    elsif adjust<0 then
        -- since the array is sorted by start, and therefore not by end,
        -- when going back the full array must be scanned on each pass.
        getNIL = True
        while adjust<0 do
            if getNIL then
                nextImportantLine = -1
                for i = lineno+1 to 1 by -1 do
                    SetEntry = BookMarkSet[i]
                    if sequence(SetEntry) then
                        BiE = SetEntry[bfEnd]
                        if sequence(BiE) then
                            BiE = SetEntry[bfStart]
                        end if
                        if BiE<=lineno --+1
                        and BiE+1>nextImportantLine then
                            if and_bits(SetEntry[bfType],FOLD) then
                                nextImportantLine = BiE+1
                                foldIdx = i
                            elsif isWordWrapON and and_bits(SetEntry[bfType],WRAP) then
                                nextImportantLine = BiE
                                foldIdx = i
                            end if
                        end if
                    end if
                end for
                getNIL = False
            end if
            if lineno=nextImportantLine then
                SetEntry = BookMarkSet[foldIdx]
                if and_bits(SetEntry[bfType],WRAP) then
                    if isWordWrapON then
                        BiE = SetEntry[bfEnd]
                        if selON!=2 then
                            if nacX>=BiE[1] then
                                for j=length(BiE) to 1 by -1 do
                                    if nacX>=BiE[j] then
                                        nacX -= BiE[j]
                                        if j>1 then
                                            nacX += BiE[j-1]
                                        end if
                                        if nacX>=BiE[j] then
                                            -- cursor up onto shorter line:
                                            nacX = BiE[j]-1
                                        end if
                                        exit
                                    end if
                                end for
                            else
                                if lineno=0 then exit end if
                                lineno -= 1
                                -- so force jump to lastChunk of prev line below:
                                nextImportantLine = -1
                            end if
                        else
--DEV this may need some more testing:
                            adjust += length(SetEntry[bfEnd])
                            if lineno=0 then exit end if
                            lineno -= 1
                        end if
                    else
                    -- skip any FOLD entries lying around:
                    -- (I think we normally get rid asap, but that may change)
                        if lineno=0 then exit end if
                        lineno -= 1
                    end if
                else
                        -- we're on the line immediately after a fold then:
                    lineno -= SetEntry[bfEnd]-SetEntry[bfStart]+1
                end if
                getNIL = True
--DEV not too sure about this "selON=2" here, but it seems to work so I am leaving it alone for now 
                if selON=2 or nextImportantLine=-1 then
                    nextImportantLine = -1
                    for i=lineno+1 to 1 by -1 do
                        SetEntry = BookMarkSet[i]
                        if sequence(SetEntry) then
                            BiE = SetEntry[bfEnd]
                            if sequence(BiE) then
                                BiE = SetEntry[bfStart]
                            end if
                            if BiE<=lineno
                            and BiE+1>nextImportantLine then
                                if and_bits(SetEntry[bfType],FOLD) then
                                    nextImportantLine = BiE+1
                                    foldIdx = i
                                elsif isWordWrapON and and_bits(SetEntry[bfType],WRAP) then
                                    nextImportantLine = BiE
                                    foldIdx = i
                                end if
                            end if
                        end if
                    end for
                    if selON!=2 and lineno=nextImportantLine
                    and and_bits(BookMarkSet[foldIdx][bfType],WRAP) then
                        SetEntry = BookMarkSet[foldIdx][bfEnd]
                        nacX += SetEntry[length(SetEntry)]
                    end if
                end if
            else
                if lineno=0 then exit end if
                lineno -= 1
                if selON!=2 and lineno=nextImportantLine
                and and_bits(BookMarkSet[foldIdx][bfType],WRAP) then
                    SetEntry = BookMarkSet[foldIdx][bfEnd]
                    nacX += SetEntry[length(SetEntry)]
                end if
            end if
            adjust += 1
        end while
    end if

    return lineno
end function

without trace
global procedure ensureVisible(integer eY, bool unfoldTop)
-- if eY is part of a fold, expand the fold, unless it
--  it is the first line and unfoldTop is False.
--  -- unfoldTop should be False for all use except fold
--     creation, which must avoid fold overlap.
sequence BookMarkSet
object SetEntry
integer bmI
    BookMarkSet = bookmarks[currfile]
    bookmarks[currfile] = 0 -- reduce ref count
    bmI = 1
    while bmI <= length(BookMarkSet) do
        SetEntry = BookMarkSet[bmI]
        if sequence(SetEntry) then
            if SetEntry[bfStart] > eY then exit end if
            if and_bits(SetEntry[bfType],FOLD)
            and SetEntry[bfEnd] >= eY
            and (unfoldTop or SetEntry[bfStart] != eY) then
                if and_bits(SetEntry[bfType],MARK) then
                    BookMarkSet[bmI][bfType] = MARK -- leave the bookmark in place
                else                                -- else remove entry
                    BookMarkSet[bmI] = 0
                end if
                paintall()
            end if
        end if
        bmI += 1
    end while
    bookmarks[currfile] = BookMarkSet
    setMarginRqd()
end procedure
--with trace

global procedure paintCursorY()
integer line
    line = distanceFromTopLine(CursorY,CursorX)+1
    if line>0 and line<=linesPerPage then
        if isWordWrapON and landingChunk then
            line = distanceFromTopLine(CursorY,0)+1
            if line<=0 then line = 1 end if
        end if
        if paintRqd then
            if paintRqd>line then
                paintRqd = line
            elsif paintLast!=0 and paintLast<line then
                paintLast = line
            end if
        else
            paintRqd = line
            paintLast = line
            startIdle(250)
        end if
    end if
end procedure


global procedure paintLines(integer linefrom, integer lineto)
--
-- Paint all lines between linefrom and lineto inclusive.
-- Handles linefrom > lineto properly (ie backward selections).
-- Allows block ops for large selections, partly or even completely off-screen.
--
    linefrom = curb(0,distanceFromTopLine(linefrom,0),linesPerPage)+1
    lineto = curb(0,distanceFromTopLine(lineto,0),linesPerPage)+1
    if paintRqd then
        paintRqd = Min(paintRqd,Min(linefrom,lineto))
        if paintLast then
            paintLast = Max(paintLast,Max(linefrom,lineto))
        end if
    else
        paintRqd = Min(linefrom,lineto)
        paintLast = Max(linefrom,lineto)
        startIdle(250)
    end if
end procedure

integer F11mode, 
        changeToF11Rqd  -- 1 if exit fullscreen mode needs a changeTo() call.
        F11mode = 0

-- used by eaopts.ew and changeTo()
global procedure setMainText()
sequence name
    name = filenames[currfile]
    if match(untitled,name)=1 then
        -- the "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
        -- but always just show it as "[untitled]" on-screen.
        name = untitled
    end if
    if isShowFullPath then
        name = filepaths[currfile]&name
    end if
    setText(Main, Edita & " - " & name)
end procedure

--with trace
-- used by eaundo.ew and eafind.ew:
global procedure forceCursorOnscreen()
integer d
    if not isWordWrapON then
--(26/3/10)
        if CursorX<Column then
--??    if CursorX<Column-marginRqd then
            Column = CursorX
            paintall()
        elsif CursorX>Column+charsWide-marginRqd then
            Column = CursorX-charsWide+marginRqd
            paintall()
        end if
    else
        if Column!=0 then
            Column = 0
            paintall()
        end if
    end if

    ensureVisible(CursorY,False)
    d = distanceFromTopLine(CursorY,CursorX)
    if d<0 or d>=linesPerPage then
        if d=linesPerPage then
            TopLine = adjustLine(TopLine,1,TopChunk)
            TopChunk = nacX
        elsif d=-1 then
-- BUGFIX: if on "while 1 do"; "a=1"; "end while" and TopLine=="end while", pressing
--     <Ctrl -> would create the Fold but leave TopLine=="a=1", & mangled display.
--      TopLine = adjustLine(TopLine,-1,TopChunk)
--      TopChunk = nacX
            TopLine = CursorY
            TopChunk = landingChunk
        else
            TopLine = 0   TopChunk = 0
            d = distanceFromTopLine(CursorY,CursorX)-floor(linesPerPage/4)
            TopLine = adjustLine(0,d,0)
            TopChunk = nacX
        end if
        paintall()
    end if
    if selON then paintCursorY() end if
end procedure

global procedure jumpTo(integer newX, integer newY)
    paintCursorY()              -- remove old currentline highlight
    CursorX = newX
    CursorY = newY
--  ensureVisible(CursorY,      -- remove folds if required,
--                False)        -- but don't unfold top line.
    forceCursorOnscreen()
    paintCursorY()              -- set new currentline highlight.
end procedure

integer CaretVisible
        CaretVisible = False
integer caretBelongsToMain  -- flag to control use of SetCaretPos 
--      caretBelongsToMain = 1
global integer CaretPosX,   -- for context menus
               CaretPosY    -- ""

sequence ClipRect
atom ClipRgn
     ClipRgn = 0

global integer CharHeight, CharWidth

--forward global function ExpandTabs(sequence text)

global procedure hideCaret()
    if CaretVisible then
        CaretVisible = False
        void = c_func(xHideCaret,{mainHwnd})
    end if
end procedure


sequence focusSet
         focusSet = {}

global procedure addFocus(integer id)
    if not find(id,focusSet) then
        focusSet = append(focusSet,id)
    end if
end procedure

--with trace

global procedure removeFocus(integer id)
    id = find(id,focusSet)
    if id then
        focusSet = focusSet[1..id-1]&focusSet[id+1..length(focusSet)]
    end if
end procedure

global procedure currFocus(integer id)
-- This is only rarely needed (eg when both the colour and font
-- dialogs are open at the same time)
integer idx
    idx = find(id,focusSet)
    if idx<length(focusSet) then
        for i=idx to length(focusSet)-1 do
            focusSet[i] = focusSet[i+1]
        end for
        focusSet[length(focusSet)] = id
    end if
end procedure

global procedure softSetFocus(integer id)
-- Usually passed Main.
integer currFocus
    currFocus = getFocus()
--04/08/2013:
--  if currFocus=0 then  id = Main  end if
    if currFocus!=0 then
        if length(focusSet) then  id = focusSet[length(focusSet)]  end if
        if id=Main or id!=getParentWindow(currFocus) then
            setFocus(id)
        end if
    end if
end procedure


include src\eaerror.ew

r_Proemh = routine_id("proemh")


global integer  insertMode      -- insert/overstrike mode
                insertMode = 1

include src\eauto.e     -- autocomplete handling
include src\easynld.e   -- init code, and reBrush


global integer isEu -- must be set before calls to ExpandTabs/PackTabs.
--             isEu = 0

--with trace
procedure setIsEu(sequence pathandname)
integer syntax  --DEV newSyntax??
    isEu = 0
--  if Xtrans then
    syntax = find(getFileExtension(pathandname),Extensions)
    if syntax and equal(SynNames[ExtensionNos[syntax]],"Euphoria") then     -- (===Phix)
        isEu = 1
    end if
--  end if
    if rtnList then
--DEV this empties the list on initial load...
--  if not isEu then
----trace(1)
--      deleteItem(rtnList,0)   -- empty list
--  end if
        setEnable(rtnList,isEu)
    end if
end procedure

--DEV: (still used via pp)
function isEuFile(sequence name)
integer syntax  --DEV newSyntax??
integer res
    res = 0
    syntax = find(getFileExtension(name),Extensions)
    if syntax and equal(SynNames[ExtensionNos[syntax]],"Euphoria") then     -- (===Phix)
        res = 1
    end if
--  if rtnList then --DEV we don't need this for current use of isEuFile
--  setEnable(rtnList,res)
--  end if
    return res
end function

include src\easynclr.e as synclr    -- syntaxColour()

include src\eadadj.e    -- simple date adjust routine.

without trace
include src\eaedb.e

include src\eatabs.e    -- ExpandTabs, ExpLength, MapToByte, CursorLeft, CursorRight, 
                        -- PackTabs, initT
                        -- DEV: ConvertTabs

integer unicodeflag -- 0 = ansi (8-bit chars)
                    -- 1 = UTF16LE
                    -- 2 = UTF16BE
                    -- 3 = UTF8
constant ANSI    = 0,
--       UTF8    = 3,   -- DEV 1
--       UTF16LE = 1,   -- DEV 2
--       UTF16BE = 2    -- DEV 3
         UTF8    = 1,
         UTF16LE = 2,
         UTF16BE = 3

--with trace
without trace
--integer ssbc  -- set scroll bar count (see how many times it is called)
--        ssbc = 0
procedure setScrollBars()
integer visHHH, visVVV
integer line,col,len
sequence txt
sequence BookMarkSet
object SetEntry
integer eTop, eTopAdj, foldEnd, foldAdj
atom ptr

    if currfile then
        maxlen = 0
        for i=length(filelinelengths[currfile]) to 1 by -1 do
            if filelinelengths[currfile][i] then
                maxlen = i
                exit
            end if
        end for
        if Column and maxlen-1-Column<charsWide-marginRqd then
            Column = maxlen-1+marginRqd-charsWide
            if Column<0 then  Column = 0  end if
            paintall()
        end if
        visHHH = False
        if maxlen>charsWide or isScrollPerm then
            visHHH = isHScrollVIS
            if not F11mode then -- 14/3/10
                if isWordWrapON then
                    setScrollInfo(HHH,{1,charsWide,charsWide,1},1)
                else
                    setScrollInfo(HHH,{1,maxlen+marginRqd-1,charsWide,Column+1},1)
                end if
            end if
        end if
        if not F11mode then -- 14/3/10
            if visHHH!=isVisible(HHH) then setVisible(HHH,visHHH) end if
        end if
        visVVV = False
        len = length(filetext[currfile])
        eTop = TopLine + 1
        eTopAdj = 0
        BookMarkSet = bookmarks[currfile]
        for i=1 to length(BookMarkSet) do
            SetEntry = BookMarkSet[i]
            if sequence(SetEntry) then
                if and_bits(SetEntry[bfType],FOLD+WRAP) then
                    if and_bits(SetEntry[bfType],WRAP) then
                        if isWordWrapON then
                            len += length(SetEntry[bfEnd])
                            foldAdj = -length(SetEntry[bfEnd])--+1
                            foldEnd = SetEntry[bfStart]-foldAdj
--DEV: (better, but not right) [04/06/07 moving the len update above this seems to do the trick  - FIXED]
-- if foldEnd=eTop then
                            if SetEntry[bfStart]=TopLine then
                                eTopAdj -= find(TopChunk,SetEntry[bfEnd])
                            end if
                        else
                            foldAdj = 0
                            foldEnd = 0
                        end if
                    else
                        foldEnd = SetEntry[bfEnd]
                        foldAdj = foldEnd-SetEntry[bfStart]
                        len -= foldAdj
                    end if
--                  len -= foldAdj
                    if foldEnd<eTop then
--                      eTop -= foldAdj
                        eTopAdj += foldAdj
                    end if
                end if
            end if
        end for
        eTop -= eTopAdj
        if not F11mode then -- 14/3/10
            if len >= linesPerPage or isScrollPerm then
                visVVV = isVScrollVIS
                setScrollInfo(VVV,{1,len,linesPerPage,eTop},1)
--setText(Main,"Edita: "&sprint({1,len,linesPerPage,eTop,length(filetext[currfile])}))
            end if
            if visVVV!=isVisible(VVV) then setVisible(VVV,visVVV) end if        
        end if

        if isVisible(SB) then
            line = CursorY+1
            len = length(filetext[currfile])
            setText(SB1,sprintf(xl("Line %d of %d Column %d"),{line,len,CursorX+1}))
            if insertMode then
                setText(SB2, xl("INS") )
            else
                setText(SB2, xl("OVR") )
            end if
            if line>len then        -- past eof
                col = 0
            else
                txt = filetext[currfile][line]
                col = MapToByte(txt, CursorX)   -- returns 0 if past eol
            end if
            if col then
                if unicodefile[currfile]!=ANSI then
                    setText(SB3,sprintf("#%04x",txt[col]))
                else
                    setText(SB3,sprintf("#%02x",txt[col]))
                end if
            else
                setText(SB3,"")
            end if
            --          LOCALE_USER_DEFAULT,DATE_LONGDATE
            len = c_func(xGetDateFormat,{#400,2,NULL,NULL,NULL,0})
            ptr = allocate_TextSpace(len)
            if c_func(xGetDateFormat,{#400,2,NULL,NULL,ptr,len}) then
                txt = peek_string(ptr)
            else
                txt = "#error#"
            end if
            setText(SB4,txt)
--ssbc += 1
--setText(SB4,ssbc)
            --          LOCALE_USER_DEFAULT, TIME_NOSECONDS
            len = c_func(xGetTimeFormat,{#400,2,NULL,NULL,NULL,0})
            ptr = allocate_TextSpace(len)
            if c_func(xGetTimeFormat,{#400,2,NULL,NULL,ptr,len}) then
                txt = peek_string(ptr)
            else
                txt = "#error#"
            end if
            setText(SB5,txt)
        end if
    else    -- no file, no scroll bars
        setVisible({HHH,VVV},False)
    end if
end procedure
--with trace

global integer prevRtnIdx
               prevRtnIdx = 0

procedure setRtnIndex()
integer k
sequence r
    if currfile and sequence(routines[currfile]) then
        r = routines[currfile]
        k = 0
        for i=1 to length(r[rtnNAMES]) do
            if r[rtnSTART][i]>CursorY+1 then exit end if
            if r[rtnEND][i]>CursorY then  k = i  exit end if
        end for
        if prevRtnIdx!=k then
            prevRtnIdx = k
            if rtnList and not F11mode then
                if isEnabled(rtnList) then
                    setIndex(rtnList,k)
                end if
            end if
        end if
    end if
end procedure

global procedure setRtnList()
-- load the ComboDropDownList, rtnList and set the index
    if rtnList then
        deleteItem(rtnList,0)   -- empty list
        if currfile and sequence(routines[currfile]) then
            void = insertItem(rtnList,routines[currfile][rtnNAMES],0)
            prevRtnIdx = 0
        end if
    end if
    setRtnIndex()
end procedure

global integer lastFold, lastFoldEnd
    lastFold = 0

global procedure savecursel()   -- also used by eaini.e
    if currfile then
        filecursel[currfile] = {CursorX,CursorY,TopLine,Column,selON,selX,selY,
                                lastFold,lastFoldEnd,TopChunk,isWordWrapON,isFTP}
        bCfwds[currfile] = bCfwd
    end if
end procedure

global procedure restcursel()   -- also used by eaini.e
sequence cursel
    if currfile then
        cursel      = filecursel[currfile]
        CursorX     = cursel[1]
        CursorY     = cursel[2]
        TopLine     = cursel[3]
        Column      = cursel[4]
        selON       = cursel[5]
        selX        = cursel[6]
        selY        = cursel[7]
        lastFold    = cursel[8]
        lastFoldEnd = cursel[9]
        -- Note that cursel may have come from a pre-0.2.9 edita.ini:
        if length(cursel)>=11 then
            TopChunk = cursel[10]
            isWordWrapON = cursel[11]
        else
            TopChunk = 0
            isWordWrapON = False
        end if
        if length(cursel)>=12 then
            isFTP = cursel[12]
        else
            isFTP = 0
        end if
        bCfwd = bCfwds[currfile]
    end if
    colourTabs[newSyntax] = ColourTab
    styleTabs[newSyntax] = StyleTab
--  charMaps[newSyntax] = charMap -- removed 17/7/(05?)
end procedure


global integer r_enableMenuToolBar      -- set by eamenus
               r_enableMenuToolBar = 0

constant isCurrWhite = 0    --DEV (scrambles display when opening a new tab, sometimes)

global procedure setSaveIcon(integer c, integer doMenu, integer doEvents0) -- also used by eaundo.ew
integer colour
    if isTabBarVIS and tabs[c] then
        if actionsave[c]!=actionptr[c] then
            colour = #0000FF        -- red
--      elsif find(getFileExtension(filenames[c]),
--              {"ex","exw","exwc","htm","html","bat"}) then
        elsif c = currfile and isCurrWhite then
            colour = #FFFFFF        -- white
        else
            colour = #000000        -- black
        end if
        if getTextColour(tabs[c])!=colour then
            --DEV 30/12/09:
            --if 0 then
            --29/1/10:
            if isTabsOwnerDrawn then
                setTextColour(tabs[c], colour)
            end if
            --          if not doMenu then      -- no help
            if not doEvents0 then       -- 10/1/08
                doEvents(0) --DEV not really sure why this is needed...
            end if
        end if
    end if
    if doMenu then
        call_proc(r_enableMenuToolBar,{})
    end if
end procedure

--Purpose: to force reload of *.err if it has been externally changed.
sequence opensize   -- save of dir() info (F12 only)
         opensize = {} -- also updated by saveFile


integer iniHandModded   -- prevent autosave if edita.ini is amended manually
        iniHandModded = 0

constant monthABC = "123456789ABC"

global integer updateRecoveryTree
               updateRecoveryTree = 0

global integer r_FTPupload,     -- routine in eamenus.ew
               r_toggleMenus    -- ""

integer dbcount
        dbcount = 0

global constant AutoSaveTimer = createTimer()

procedure put_unicode_string(integer fn, sequence s)
integer l
--integer lastch
integer lowch, highch
integer nLen
atom pInBuff, pOutBuff
    l = length(s)
    if unicodeflag=UTF8 then
        pInBuff = allocate(l*2)
        poke2(pInBuff,s)
        nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,NULL,0,NULL,NULL})
        pOutBuff = allocate(nLen)
        nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,pOutBuff,nLen,NULL,NULL})
        puts(fn,peek({pOutBuff,nLen}))
        free(pOutBuff)
        free(pInBuff)
        puts(fn,"\r\n")
    elsif unicodeflag=UTF16LE then
--DEV poke2(addr,s)/peek({addr,l*2}) might be faster...
        for i=1 to l do
            highch = s[i]
            lowch = and_bits(highch,#FF)
            highch = floor(highch/#100)
            puts(fn,lowch)
            puts(fn,highch)
        end for
--/**/  puts(fn,"\r\0\n\0")
--/*
        puts(fn,{'\r',0,'\n',0})
--*/
    elsif unicodeflag=UTF16BE then
        for i=1 to l do
            highch = s[i]
            lowch = and_bits(highch,#FF)
            highch = floor(highch/#100)
            puts(fn,highch)
            puts(fn,lowch)
        end for
--/**/  puts(fn,"\0\r\0\n")
--/*
        puts(fn,{0,'\r',0,'\n'})
--*/
    else
        ?9/0
    end if
end procedure

-- used by eaxutil.ew:
--with trace
global function saveFile(integer warnBackup)
-- the parameter should be 1, unless there is some special reason
-- why a backup might not be possible (eg save as, new file)
object d
integer dt2
sequence dt, bakname, backdir
integer fn, k
sequence name
integer c
sequence ftxt
integer f
--integer wasTabWidth
--sequence oneline
    if currfile then
        if tabfile then
            c = tabfile
            tabfile = 0
        else
            c = currfile
        end if
        if match(untitled,filenames[c])!=1 then
            if isAutoBackup and not find(filenames[c],{"ex.err","p.err"}) then
                backdir = initialcurrentdir&"backup\\"
                d = dir(backdir)
                if atom(d) then
                    if not createDirectory(backdir) then
                        void = messageBox(xl("Unable to create backup directory"),backdir,0)
                        return 0
                    end if
                    d = {}
                else
                    for i = 1 to length(d) do
                        d[i] = d[i][1]  -- just keep filename
                    end for
                end if
                dt = date()
                dt[1] = remainder(dt[1],10) -- year as single digit
                dt2 = dt[2]         -- save month
                dt[2] = monthABC[dt2]   -- encode month
                dt[6] = getFileExtension(filenames[currfile])
            
                while 1 do
                    bakname = sprintf("%d%s%02d%02d%02d.%s",dt[1..6])
--if isDebug then printf(1,"trying backup %s\n",{bakname}) end if
                    --DEV with a huge backup dir, it will probably be quicker to try and open it.
                    if not find(bakname,d) then
                        if copyFile(filepaths[c]&filenames[c],
                                    backdir&bakname,
                                    1) -- prohibit overwrite
                        then
                            -- calculate the unique id,
                            --  between 001010000 and 912319999, where the 
                            --  first five digits are remainder(year,10),
                            --  month, and day; therefore there will be no
                            --  duplicates for 10 years. The last four digits
                            --  hold the hour:minute, though if you save more
                            --  than once/min, it clocks on (and saves made
                            --  in the next minute clock on even further).
                            --  However, by using 'hours' 24..99 and 'minutes'
                            --  60..99, this allows 10,000 saves per day (or 
                            --  7640 if you start at 23:59:00 !!)
                            --  The result is small enough for an integer.
                            dt2 += dt[1]*100        -- 001..912
                            for i = 3 to 8 do       -- avoiding encoded months
                                dt2 = dt2*10 + bakname[i]-'0'
                            end for
                            logBackup(dt2,filepaths[c],filenames[c])
                            dbcount = 0
                            exit
                        end if
                        dt[4..5] = {99,99}  -- trigger error below
                    else
                        dbcount += 1
                        if dbcount>10 then
                            setText(Main,"Edita: Warning: duplicate backup:"&bakname)
                        end if
                    end if
                    if dt[5] < 99 then
                        dt[5] = dt[5] + 1       -- artificially increase minute
                    else
                        dt[5] = 0
                        if dt[4] = 99 then -- at least 7640 backups per day before this triggers!
                            if warnBackup then
                                void = messageBox(xl("Error"),xl("Unable to create backup"),0)
                            end if
                            exit
                        end if
                        dt[4] = dt[4] + 1       -- artificially increase hour
                    end if
                end while   
            end if
            --
            -- now save the file...
            --
            name = filepaths[c]&filenames[c]
            setIsEu(name)

            ftxt = filetext[c]
--DEV (untested, more cases to consider...)
--      for i=1 to length(ftxt) do
--          ftxt[i] = UnPackTabs(ftxt[i])
--      end for
--      els
--24/1/07: Ding! if isTabWidth!=8 then always store as spaces!
--      if (isEu and (isReplaceTabs or Xtrans)) or isTabWidth!=8 then

--      if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
            if isReplaceTabs then
                for i=1 to length(ftxt) do
                    ftxt[i] = ConvertTabs(ftxt[i],isTabWidth,0)
                end for
            elsif isTabWidth!=8 or (isEu and Xtrans) then
                for i=1 to length(ftxt) do
--                  ftxt[i] = UnPackTabs(ftxt[i])
                    ftxt[i] = ConvertTabs(ftxt[i],isTabWidth,8)
                end for
            end if

            unicodeflag = unicodefile[c]
            if unicodeflag=ANSI then
                fn = open(name,"w")
            else
                fn = open(name,"wb")
            end if
            if fn=-1 then
                void = messageBox(xl("Error"),xl("Unable to save ")&name,0)
                return 0
            end if

            if unicodeflag=ANSI then
                for i=1 to length(ftxt) do
                    puts(fn,ftxt[i])
                    puts(fn,'\n')
                end for
            else
                -- write a BOM (Byte Order Mark)
                if unicodeflag=UTF8 then
                    puts(fn,{#EF,#BB,#BF})
                elsif unicodeflag=UTF16LE then
                    puts(fn,{#FF,#FE})
                elsif unicodeflag=UTF16BE then
                    puts(fn,{#FE,#FF})
                else
-- 3/6/14
--                  ?9/0
-- 7/6/14
                    close(fn)
                    void = messageBox(sprintf("unicode flag is %d - reset to ANSI, file not saved",unicodeflag),"oops",0)
                    unicodeflag = ANSI
                    return 0
                end if
--trace(1)
                for i=1 to length(ftxt) do
                    put_unicode_string(fn,ftxt[i])
                end for
            end if

            close(fn)
            updateRecoveryTree = 1

            if c>length(opensize) then
                opensize &= repeat(0,c-length(opensize))
            end if
            opensize[c] = dir(name)
            --DEV:
            filedt[c] = dir(name)

            runBack = 1
            f = logFile(filepaths[c],filenames[c],0)
            actionsave[c] = actionptr[c]
            if needsFTPing(f) then  -- check edita.edb flags [as set by markAsFTP() below]
                call_proc(r_FTPupload,{filepaths[c]&filenames[c]})
            end if
            setSaveIcon(c,1,1)
            if equal(filenames[c],"edita.ini") then
                iniHandModded = 1
            else
                -- if we save a .syn file, reload them all.
                k = length(filenames[c])
                if k>4 then
                    k = find(filenames[c][k-3..k],{".syn",".txt"})
                    if k=1 then
                        setText(SB6,"Reloading Syntax Files")
                        initSyn()
                        setText(SB6,"")
--DEV usegpp (kill LowerCase, not that using it here should matter)
--DEV Bugfix 3/6/7: There may be many similar cases...
--                  elsif k=2 and equal(filepaths[c],initialcurrentdir&"help\\") then
                    elsif k=2 and equal(LowerCase(filepaths[c]),
                                        LowerCase(initialcurrentdir&"help\\")) then
                        setText(SB6,"Reloading Help Control Files")
                        initHlp()
                        call_proc(r_toggleMenus,{})
                        call_proc(r_toggleMenus,{})
                        setText(SB6,"")
                    end if
                end if
            end if
        end if
    end if
    if isAutoSaveTimer then
        stopTimer(AutoSaveTimer)
        startTimer(AutoSaveTimer,Main,isAutoSaveTimer*1000)
    end if

    return 1
end function


--integer doLLtest
--    doLLtest = 0

integer isCurrLineColoured  -- set to (ColourTab[HighLine]!=ColourTab[Background]) on Tab switch.
global integer rCompareTarget
               rCompareTarget = 0

--without trace
--with trace
global procedure changeTo(integer i)
-- switch to the specified file
sequence fileExt
integer lenExt
integer prevfile
    if and_bits(isClearOverStrike,cOVRfile) then
        insertMode = 1
    end if
    changeToF11Rqd = 1

    if rCompareTarget then
        -- if compare open, set target and quit.
        if call_func(rCompareTarget,{i}) then return end if
    end if
    if isAutoSaveOnTabSwitch and currfile -- and currfile!=i ??
    and actionsave[currfile] != actionptr[currfile] then
        void = saveFile(1)
    end if
    savecursel()
    if r_enableMenuToolBar and isCurrWhite then
        prevfile = currfile
        currfile = i
        if prevfile then
            setSaveIcon(prevfile,0,0)
        end if
        setSaveIcon(currfile,0,1)
    else
        currfile = i
    end if
    restcursel()
    newSyntax = 1 -- default
--DEV common code:
    fileExt = filenames[currfile] 
    lenExt = length(fileExt)
    for l = lenExt to 1 by -1 do
        if fileExt[l]='.' then
            newSyntax = find(LowerCase(fileExt[l+1..lenExt]),Extensions)
            if newSyntax then
                newSyntax = ExtensionNos[newSyntax]
            else
                newSyntax = 1
            end if
            exit
        end if
    end for 
    setIsEu(filepaths[currfile]&filenames[currfile])
    ColourTab = colourTabs[newSyntax]
    isCurrLineColoured = (ColourTab[HighLine]!=ColourTab[Background])
    sampleBrushClr = reBrush(sampleBrushClr,ColourTab)
    StyleTab = styleTabs[newSyntax]
    charMap = charMaps[newSyntax]   -- fixed hang 17/7
    comment = LineComments[newSyntax]       -- moved here 19/7
    blockComment = BlockComments[newSyntax]
    autoComplete = AutoCompletes[newSyntax]

    setMarginRqd()
    forceCursorOnscreen()   --DEV??
    paintall()

    setMainText()
    if isTabBarVIS then
        if rRebuildTabBar and isSingleDir then
            call_proc(rRebuildTabBar,{})
        end if
        setFocus(tabs[currfile])
    end if

--  setFocus(Main)  -- automatic (via handleTABCONTROL())
--  doLLtest = 1
    checkProj = 1
    if sequence(routines[currfile]) then
        setRtnList()
    end if
end procedure


global -- for eadir
integer shuffleLoop -- special flag for F12()
        shuffleLoop = 0

-- used by eacons.ew
global procedure shuffleTabs(integer d)
-- reorder the tabs (Ctrl Shift PageUp/Down handling)
-- d is +/-1 (or more, if isSingleDir is True)
object tmp, tmp2
atom hwnd
integer cold
    if and_bits(isClearOverStrike,cOVRfile) then
        insertMode = 1
    end if
    cold = currfile
    currfile += d
--#without reformat
    tmp = filepaths[currfile]
          filepaths[currfile] = filepaths[cold]
          filepaths[cold] = tmp
    tmp = filetext[currfile]
          filetext[currfile] = filetext[cold]
          filetext[cold] = tmp
    tmp = unicodefile[currfile]
          unicodefile[currfile] = unicodefile[cold]
          unicodefile[cold] = tmp
    tmp = filelinelengths[currfile]
          filelinelengths[currfile] = filelinelengths[cold]
          filelinelengths[cold] = tmp
    tmp = filecursel[currfile]
          filecursel[currfile] = filecursel[cold]
          filecursel[cold] = tmp
    tmp = bCfwds[currfile]
          bCfwds[currfile] = bCfwds[cold]
          bCfwds[cold] = tmp
    tmp = unpacked[currfile]
          unpacked[currfile] = unpacked[cold]
          unpacked[cold] = tmp
    tmp = wrapped[currfile]
          wrapped[currfile] = wrapped[cold]
          wrapped[cold] = tmp
    tmp = bookmarks[currfile]
          bookmarks[currfile] = bookmarks[cold]
          bookmarks[cold] = tmp
    tmp = routines[currfile]
          routines[currfile] = routines[cold]
          routines[cold] = tmp
    tmp = actions[currfile]
          actions[currfile] = actions[cold]
          actions[cold] = tmp
    tmp = actionptr[currfile]
          actionptr[currfile] = actionptr[cold]
          actionptr[cold] = tmp
    tmp = actionsave[currfile]
          actionsave[currfile] = actionsave[cold]
          actionsave[cold] = tmp
-- 5/7/2013:
--if isTabBarVIS then
if isTabBarVIS and isTabsOwnerDrawn then
    tmp = getBackColour(tabs[currfile])
          setBackColour(tabs[currfile],getBackColour(tabs[cold]))
          setBackColour(tabs[cold],tmp)
end if
    tmp = filenames[currfile]
    tmp2 = filenames[cold]
           filenames[currfile] = tmp2
           filenames[cold] = tmp
--#with reformat
    if isTabBarVIS then
        hwnd = getHwnd(TC)
        -- an "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
        -- but always just show it as "[untitled]" on-screen.
        if match(untitled,tmp2)=1 then
            tmp2 = untitled
        end if
        if match(untitled,tmp)=1 then
--          tmp = 1
            tmp = untitled  -- 11/6/07
        end if
        setText(tabs[currfile], tmp2)
        setText(tabs[cold], tmp)
        if not shuffleLoop then -- reduce drawing overhead when looping (see F12())
            setSaveIcon(cold,0,0)
            setSaveIcon(currfile,1,1)
            setFocus(tabs[currfile])
        end if
    end if
    paintall()
end procedure

-- used by eacomp.ew and eamenus.ew/Restore:
global procedure closeTab()
-- closes the currfile tab. Does not check for or attempt file save.
integer l, c, cm1, cp1
atom tabHwnd
    if currfile then
        hideCaret()
        if tabfile then
            c = tabfile
            tabfile = 0
        else
            c = currfile
        end if
        cm1 = c-1
        cp1 = c+1
        l = length(filenames)
        filenames = filenames[1..cm1]&filenames[cp1..l]
        filepaths = filepaths[1..cm1]&filepaths[cp1..l]
        filetext = filetext[1..cm1]&filetext[cp1..l]
        unicodefile = unicodefile[1..cm1]&unicodefile[cp1..l]
        filelinelengths = filelinelengths[1..cm1]&filelinelengths[cp1..l]
        filecursel = filecursel[1..cm1]&filecursel[cp1..l]
        filedt = filedt[1..cm1]&filedt[cp1..l]
        bCfwds = bCfwds[1..cm1]&bCfwds[cp1..l]
        unpacked = unpacked[1..cm1]&unpacked[cp1..l]
        wrapped = wrapped[1..cm1]&wrapped[cp1..l]
        bookmarks = bookmarks[1..cm1]&bookmarks[cp1..l]
        routines = routines[1..cm1]&routines[cp1..l]
        actions = actions[1..cm1]&actions[cp1..l]
        actionptr = actionptr[1..cm1]&actionptr[cp1..l]
        actionsave = actionsave[1..cm1]&actionsave[cp1..l]
        if isTabBarVIS then
            tabHwnd = tabs[c]
            tabs = tabs[1..cm1]&tabs[cp1..l]
        end if
        if currfile>c then
            l = currfile-1
        elsif currfile=l then
            l -= 1
        else
            if isCloseLeft then
                if currfile>1 then
                    l = currfile-1
                else
                    l = currfile
                end if
            else
                l = currfile
            end if
        end if
        currfile = 0
        if l then 
            if isSingleDir and isTabBarVIS and tabs[l]=0 then
                for i=l+1 to length(tabs) do
                    if tabs[i] then  l = i  exit end if
                end for
                if tabs[l]=0 then
                    for i=l-1 to 1 by -1 do
                        if tabs[i] then  l = i  exit end if
                    end for
                end if
            end if
            changeTo(l)
        end if
        if isTabBarVIS then
            void = destroy(tabHwnd) -- must be after setFocus()
            if rRebuildTabBar and isSingleDir then
                call_proc(rRebuildTabBar,{})
            end if
        end if
        call_proc(r_enableMenuToolBar,{})
    end if
end procedure

function buildFileFilter()
-- Build a file filter from the extension info loaded from the syntax files
-- Give priority to the current syntax/extension set by placing in slot 2
sequence res
integer k
sequence stardot
    res = {xl("All Files"), "*.*"}
    if newSyntax then
        res &= {SynNames[newSyntax]&xl(" files"),""}
    end if
    for i=2 to length(SynNames) do
        if i!=newSyntax then
            res &= {SynNames[i]&xl(" files"),""}
            k = length(res)
        else
            k = 4
        end if
        stardot = "*."
        for j=1 to length(Extensions) do
            if ExtensionNos[j]=i then
                res[k] = res[k] & stardot & Extensions[j]
                stardot = ";*."
            end if
        end for
        res[k-1] = res[k-1] & " (" & res[k] & ")"
    end for
    return res
end function

function buildFileFilter2()
-- Build a file filter from the extension info loaded from the syntax files
-- Give priority to the current syntax/extension set by placing in slot 2
sequence res
integer k
sequence stardot
    res = {{xl("All Files"), "*.*"}}
    if newSyntax then
        res = append(res,{SynNames[newSyntax]&xl(" files"),""})
    end if
    for i=2 to length(SynNames) do
        if i!=newSyntax then
            res = append(res,{SynNames[i]&xl(" files"),""})
            k = length(res)
        else
            k = 2
        end if
        stardot = "*."
        for j=1 to length(Extensions) do
            if ExtensionNos[j]=i then
                res[k][2] &= stardot & Extensions[j]
                stardot = ";*."
            end if
        end for
        res[k][1] &= " (" & res[k][2] & ")"
    end for
    return res
end function

global integer  MacroLearn      -- see eamacro.ew
                MacroLearn = 0
global integer  MacroPlaying        -- ""
                MacroPlaying = 0
global sequence MacroRtns           -- ""
                MacroRtns = {0,0,0} -- charInput, virtualKey, setFindDefaults

global procedure stopMacroLearn(integer showMsg)
    if MacroLearn then
        MacroLearn = 0
        if showMsg then
            void = proemh(xl("Note"),xl("Macro recording stopped"),0)
        end if
        setText(SB6,"")
    end if
end procedure

include src\eafext.ew

global integer r_openFile

function saveFileAs()
object name
sequence path
integer res
--/**/integer encoding

    stopMacroLearn(1)
    if currfile then
        if tabfile then
            path = filepaths[tabfile]
            tabfile = 0
        else
            path = filepaths[currfile]
        end if
--/**/  if newopendialog then
--/**/      encoding = unicodefile[currfile]+1
--/**/      name = newGetSaveFileName(getHwnd(Main),buildFileFilter2(),{2,getFileExtension(filenames[currfile])},{path},encoding)
--/**/      -- newGetOpenFileName
--/**/  else
            name = getSaveFileName(Main,path&"*.*",buildFileFilter(),OFN_HIDEREADONLY+OFN_OVERWRITEPROMPT,NULL)
--/**/  end if
        void = chdir(initialcurrentdir)
        if sequence(name) then
--/**/      if newopendialog then
--/**/          encoding = unicodefile[currfile]
--/**/          -- 4/6/14:
--/**/          if length(name)!=2
--/**/          or not sequence(name[2]) then
--/**/              ?9/0
--/**/          end if
--/**/          -- 17/6/14:
--/**/  --      unicodefile[currfile] = name[1]-1
--/**/          encoding = name[1]
--/**/          if encoding>0 then
--/**/              encoding -= 1
--/**/          end if
--/**/          unicodefile[currfile] = encoding
--/**/          name = name[2]
--/**/      else
                name = name[1]  -- we asked for single file
--/**/      end if
            -- check against the files already open for editing:
            for i = 1 to length(filepaths) do
                if i!=currfile
                and equal(filepaths[i]&filenames[i],name) then
                    --
                    -- Unusual case: Save as filename already exists
                    -- (already warned in the Save As dialog), *AND*
                    -- that target file is currently open for edit.
                    --
                    if messageBox(xl("File Already Open For Edit"),
                                  xl("Discard edit session?"),
                                  MB_OKCANCEL)=IDOK then
--!!                    filenames[i] = filenames[currfile]
--!!                    filepaths[i] = filepaths[currfile]
                        filetext[i] = filetext[currfile]
                        unicodefile[i] = unicodefile[currfile]
                        filelinelengths[i] = filelinelengths[currfile]
                        filecursel[i] = filecursel[currfile]
                        filedt[i] = filedt[currfile]
                        bCfwds[i] = bCfwds[currfile]
                        unpacked[i] = unpacked[currfile]
                        wrapped[i] = wrapped[currfile]
                        bookmarks[i] = bookmarks[currfile]
                        routines[i] = routines[currfile]
                        actions[i] = actions[currfile]
                        actionptr[i] = actionptr[currfile]
                        actionsave[i] = actionsave[currfile]
                        if i>currfile then  --NB: make this test /before/ closeTab()!
                            closeTab()
                            changeTo(i-1)
                        else
                            closeTab()
                            changeTo(i)
                        end if
                        if saveFile(1) then
--/**/                      if newopendialog then
--/**/                          if (encoding=ANSI)!=(unicodefile[currfile]=ANSI) then
--/**/                              -- reload
--/**/                              void = call_func(r_openFile,{-1,1,0})
--/**/                          end if
--/**/                      end if
                            return 1
                        end if
                    end if
                    return 0
                end if
            end for
if sequence(name) then -- added 3/6/14
            for i=length(name) to 1 by -1 do
                if name[i]='\\' then
                    filepaths[currfile] = name[1..i]
                    name = name[i+1..length(name)]
                    filenames[currfile] = name
                    if isTabBarVIS then
                        setText(tabs[currfile],name)
                        setTabColour(tabs[currfile],name)
                        if rRebuildTabBar and isSingleDir then
                            call_proc(rRebuildTabBar,{})
                        end if
                    end if
                    res = saveFile(0)       -- no backup warning
                    changeTo(currfile)      -- reset syntax
--/**/              if newopendialog then
--/**/                  if res and (encoding=ANSI)!=(unicodefile[currfile]=ANSI) then
--/**/                      -- reload
--/**/                      void = call_func(r_openFile,{-1,1,0})
--/**/                  end if
--/**/              end if
                    return res
                end if
            end for
end if
        end if
    end if
    return 0
end function
global constant r_saveFileAs=routine_id("saveFileAs")

--with trace
-- used by eacomp.ew, etc
--5/10/13: (undone 26/10/13)
global procedure newFile(sequence name, sequence text, sequence linelengths, integer unicodeflag)
--global procedure newFile(string name, sequence text, sequence linelengths, integer unicodeflag)
--5/10/13:
sequence path
--string path
integer l, cp1
integer ti, thisbc, nextbc
--trace(1)
    stopMacroLearn(1)
    hideCaret()
    if length(name) and name[1]!='.' then
        path = ""
        for i=length(name) to 1 by -1 do
            if name[i]='\\' then
                path = name[1..i]
                name = name[i+1..length(name)]
                exit
            end if
        end for
--  if not length(path) then
--trace(1)
--      path = initialcurrentdir
--  end if
        void = logFile(path,name,0)
    else
        if tabfile and tabfile <= length(filepaths) then
            path = filepaths[tabfile]
            tabfile = 0
        elsif currfile then
            path = filepaths[currfile]
        else
            path = ""
        end if
        name = untitled&name
    end if
    l = length(filenames)
    if currfile<l then
        cp1 = currfile+1
        filenames = filenames[1..currfile] & 0 & filenames[cp1..l]
        filenames[cp1] = name
        filepaths = filepaths[1..currfile] & 0 & filepaths[cp1..l]
        filepaths[cp1] = path
        filetext = filetext[1..currfile] & 0 & filetext[cp1..l]
        filetext[cp1] = text
        unicodefile = unicodefile[1..currfile] & 0 & unicodefile[cp1..l]
        unicodefile[cp1] = unicodeflag
        filelinelengths = filelinelengths[1..currfile] & 0 & filelinelengths[cp1..l]
        filelinelengths[cp1] = linelengths
        filecursel = filecursel[1..currfile] & 0 & filecursel[cp1..l]
        filecursel[cp1] = {0,0,0,0,0,0,0,0,0,0}
        filedt = filedt[1..currfile] & 0 & filedt[cp1..l]
        filedt[cp1] = dir(path&name)
        bCfwds = bCfwds[1..currfile] & 0 & bCfwds[cp1..l]
        unpacked = unpacked[1..currfile] & 0 & unpacked[cp1..l]
        wrapped = wrapped[1..currfile] & 0 & wrapped[cp1..l]
        bookmarks = bookmarks[1..currfile] & 0 & bookmarks[cp1..l]
        bookmarks[cp1] = repeat(0,length(text))
        routines = routines[1..currfile] & 0 & routines[cp1..l]
        actions = actions[1..currfile] & 0 & actions[cp1..l]
        actions[cp1] = {}
        actionptr = actionptr[1..currfile] & 0 & actionptr[cp1..l]
        actionsave = actionsave[1..currfile] & 0 & actionsave[cp1..l]
        if isTabBarVIS then
            tabs = append(tabs,create(TabItem, "", 0, TC, 0,0,0,0,0))
--          setBackColour(tabs[cp1],getBackColour(tabs[l+1]))   -- grey if needed
--          for i=cp1 to l+1 do
--              setTabColour(tabs[i],name)
--              if match(untitled,name)=1 then
--                  -- the "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
--                  -- but always just show it as "[untitled]" on-screen.
--                  name = untitled
--              end if
--              setText(tabs[i],name)
--              setSaveIcon(i,0,0)
--              if i>l then exit end if
--              name = filenames[i+1]
--          end for
            thisbc = getBackColour(tabs[l+1])
--          for i=l+1 to cp1 by -1 do
            for i=cp1 to l+1 do
                ti = tabs[i]
if ti!=0 then -- test added 22/3/2014
                nextbc = getBackColour(ti)
                if isTabsOwnerDrawn then            -- test added 5/7/2013
                    setBackColour(ti,thisbc)
                end if
                thisbc = nextbc
                name = filenames[i]
                setTabColour(ti,name)
                if match(untitled,name)=1 then
                    -- the "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
                    -- but always just show it as "[untitled]" on-screen.
                    name = untitled
                end if
                setText(ti,name)
                setSaveIcon(i,0,0)
end if
            end for
--  if isTabBarVIS then
--      if not shuffleLoop then -- reduce drawing overhead when looping (see F12())
--          setSaveIcon(cold,0,0)
--          setSaveIcon(currfile,1,0)
--          setFocus(tabs[currfile])
--      end if
--  end if
--...
            if rRebuildTabBar and isSingleDir then
                call_proc(rRebuildTabBar,{})
            end if
        end if
        changeTo(cp1)
    else
        filenames = append(filenames,name)
        filepaths = append(filepaths,path)
        filetext = append(filetext,text)
        unicodefile = append(unicodefile,unicodeflag)
        filelinelengths = append(filelinelengths,linelengths)
        filecursel = append(filecursel,{0,0,0,0,0,0,0,0,0,0})
        filedt = append(filedt,dir(path&name))
        bCfwds = append(bCfwds,0)
        unpacked = append(unpacked,0)
        wrapped = append(wrapped,0)
        bookmarks = append(bookmarks,repeat(0,length(text)))
        routines = append(routines,0)
        actions = append(actions,{})
        actionptr = append(actionptr,0)
        actionsave = append(actionsave,0)
        if isTabBarVIS then
            if match(untitled,name)=1 then
                -- the "actual" name may be eg "[untitled].exw" for syntax colouring reasons,
                -- but always just show it as "[untitled]" on-screen.
                name = untitled
            end if
            tabs = append(tabs,create(TabItem, name, 0, TC, 0,0,0,0,0))
            setTabColour(tabs[length(tabs)],name)
            if rRebuildTabBar and isSingleDir then
                call_proc(rRebuildTabBar,{})
            end if
        end if
        changeTo(length(filetext))
    end if
--#with reformat
end procedure
global constant r_newFile = routine_id("newFile")

global -- for eaexerr.e (and eacca.e, eaxutil.e, I think)
sequence linelengths

include src\eaerr.e

function get_unicode_char(integer fn)
integer ch, ch2
    ch = getc(fn)
    if ch!=-1 then
        ch2 = getc(fn)
-- PL 10/09/2013 (spotted in passing: we cannot avoid the *#100 in UTF16BE!)
--      if ch2 then
--          if unicodeflag=UTF16LE then
--              ch = ch+ch2*#100
--          else
--              ch = ch2+ch*#100
--          end if
--      end if
        if unicodeflag=UTF16LE then
            if ch2 then
                ch += ch2*#100
            end if
        else
            ch = ch2+ch*#100
        end if
    end if
    return ch
end function

function get_unicode_line(integer fn)
integer ch
object res
integer nLen
atom pBuff
    if unicodeflag=UTF8 then
        res = gets(fn)
        if not atom(res) then
            nLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,res,length(res),NULL,0})
            pBuff = allocate(nLen*2)
            nLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,res,length(res),pBuff,nLen})
            res = peek2u({pBuff,nLen})
            free(pBuff)
        end if
    else                            -- UTF16 (LE|BE)
        ch = get_unicode_char(fn)
        if ch = -1 then
            res = -1
        else
            res = {}
            while ch!=-1 do
                if ch!='\r' then
                    res &= ch
                    if ch='\n' then exit end if
                end if
                ch = get_unicode_char(fn)
            end while
        end if
    end if
    return res
end function

--with trace
integer ltch    -- if set after readFile, legacy tab handling was applied,
        -- so set unpacked[currfile] to -1.
global integer ltchcount    -- for ReOpen pop-up
               ltchcount = 0

function readFile(sequence name, integer prompt, integer plth)
-- open and read contents of specified file.
-- if prompt!=0 then display messageBox on error (else keep schtum)
-- if plth then allow legacy tab character handling, if -1 force it.
-- returns: 0 on failure, {line[1..n]}, or {{}} for empty file.
--  (ie The latter case is that a completely empty file is 
--   represented by one line of length 0, not 0 lines,
--   which is also the general case for open new;
--   {{"fred"}} represents a text file of four bytes,
--   {{"fred"},{}} represents four bytes "plus \n",
--   likewise {{},{}} represents a single line break.
--   Note that that \r\n conversion is inherent; if Edita opens
--   a file with Linux-style linebreaks, it will automatically
--   save it with Windows-style linebreaks, as determined by the
--   puts(fn,'\n') statement in saveFile().
-- Also sets unicodeflag (except on failure)
sequence file
integer fn
--, filelen
--integer lineno
object line
integer linelength
object d
--atom t
integer ch
integer uniskip

    fn = open(name,"r")
    if fn=-1 then
        if prompt then
            void = messageBox(xl("Edita: Error opening file"),name,0)
        end if
        return 0
    end if
--  ltch = 0
    ltch = plth
--  if isLegacyTabHandling then
    if ltch = 1 then
        d = dir(name)
        if not sequence(d)
        or length(d)!=1 
        or not sequence(isLegacyTcod) 
        or compare(d[1][4..9],isLegacyTcod)!=-1
        or not isLegacyTabHandling then
--          plth? = -1
--          ltch = 1
--      else
            ltch = 0
        end if
    end if
    if ltch then
        ltchcount += 1
    end if
    --  file = repeat(0,200)
    file = {}
    linelengths = repeat(0,80)
--  filelen = 200
--  lineno = 0
    setIsEu(name)

--t = time()+0.25
    unicodeflag = 0
    line = gets(fn)
    if not atom(line)
    and length(line)>=2 then
        if equal(line[1..2],{#FF,#FE}) then
            unicodeflag = UTF16LE
            uniskip = 2
        elsif equal(line[1..2],{#FE,#FF}) then
            unicodeflag = UTF16BE
            uniskip = 2
        elsif length(line)>=3
          and equal(line[1..3],{#EF,#BB,#BF}) then
            unicodeflag = UTF8
            uniskip = 3
--DEV still completely undecided over this (untested)
--      elsif length(line)>=5
--        and equal(line[1..5],{#2B,#2F,#76,#38,#2D}) then
--          --                   +   /   v   8   -
--          void = messageBox(xl("Warning"),"UTF-7 BOM will NOT be saved if you modify this file",0)
--          line = line[6..$]
----            return 0
        end if
    end if
    if unicodeflag then
        -- gets() returns L"Hello" as "H\0e\0l\0l\0o\o" and makes a complete mess 
        -- of \r\0\n\0 handling, iyswim. So read it a (wide)char at a time.
        -- likewise getc() will not process "\r\0\n\0" as one might like, so close
        -- and re-open the file in binary mode.
        close(fn)
        fn = open(name,"rb")
        if seek(fn,uniskip) then
            puts(1,"error seeking in readFile")
        end if
        line = get_unicode_line(fn)
    end if
    while not atom(line) do
--now done in IdleHandler:
--      if isEu then
--          if isReplaceTabs or Xtrans or isTabWidth!=8 then
--          line = PackTabs(line,0)
--          end if
--      end if
        linelength = length(line)
        if linelength!=0 then   -- added 8/6/2013
            ch = line[linelength]
            while ch='\n' 
               or ch='\r' do
                linelength -= 1
                line = line[1..linelength]
                if linelength=0 then exit end if
                ch = line[linelength]
            end while
        end if
--      if prompt=-1 then       -- legacy handling
        if ltch then            -- legacy tab handling
            line = ConvertTabs(line,isTabWidth,isTabWidth)  --DEV wtf??!!
            linelength = ExpLength(line)
        else
            linelength = ExpLength8(line)
        end if
        --  file[lineno] = line
        file = append(file,line)
        if linelength>=length(linelengths) then
            linelengths &= repeat(0,linelength-length(linelengths)+1)
        end if
        linelengths[linelength+1] = linelengths[linelength+1] + 1
--if t<time() then
--  t = time()+0.25
----    setText(SB6,sprintf("loading, line:%d",lineno))
--  setText(SB6,sprintf("loading, line:%d",length(file)))
--end if
        if unicodeflag then
            line = get_unicode_line(fn)
        else
            line = gets(fn)
        end if
    end while

    close(fn)
    if length(file) then
        if usegpp then
            if isFormatErr and match("ex.err",name)=length(name)-5 then
                return preprocessErr(file)
            end if
        else
            --      if isFormatErr and match(".err",LowerCase(name))=length(name)-3 then
            if isFormatErr and match("ex.err",LowerCase(name))=length(name)-5 then
                return preprocessErr(file)
            end if
        end if
        return file
    end if
    linelengths[1] = 1
    return {{}}
end function

function toString(sequence name)--, integer errcode)
-- Explicitly convert a dword-sequence to an 8-bit string
string res
integer nlen
object ch
    nlen = length(name)
    res = repeat(' ',nlen)
    for i=1 to nlen do
        ch = name[i]
        if atom(ch) then
            ch = and_bits(ch,#FF)
            res[i] = ch
        else
--          fatal(errcode)
            ?9/0
        end if
    end for
    return res
end function

-- used by eaini.ew
global function openFile(object name, integer prompt, integer plth)
--
-- if name is -1, perform a reopen function.
-- if name is 0, open a file via the standard windows dialogue.
--  (otherwise, duh, open the filename as passed!)
-- prompt is passed to readFile to control display of errors.
--  the value of -1 is also used to loop when opening ex.err.
-- plth is 'permit legacy tab handling'.
--  a value of 0 disables it.
--  a value of 1 checks isLegacyTabHandling and the date/time against isLegacyTcod.
--   (you can pass 1 or isLegacyTabHandling, no real difference)
--  a value of -1 forces it (from ReOpen as tab 4).
--
-- returns 1 on success, 0 on failure.
--
object file
--5/10/2013: (put back 31/1/16...)
--sequence path
string path
integer c
--/**/integer encoding
--  stopMacroLearn(1)
    if atom(name) then
        if name = -1 then   -- re-open function
            if tabfile then
                c = tabfile
                tabfile = 0
            else
                c = currfile
            end if
            if match(untitled,filenames[c])!=1 then
                file = readFile(filepaths[c]&filenames[c],prompt,plth)
                if not sequence(file) then return 0 end if
--      if prompt=-1 then   -- ReLoad as Tab 8 (where '8' is isTabWidth):
                if ltch then
--DEV:
--          fileTabLength = isTabWidth
--          for i=1 to length(file) do
----                file[i] = PackTabs(file[i],0)
--          file[i] = ConvertTabs(file[i],isTabWidth,isTabWidth)
--          end for
--          fileTabLength=8
                    unpacked[c] = -1
                else
                    unpacked[c] = 0
                end if
                wrapped[c] = 0
                filetext[c] = file
                unicodefile[c] = unicodeflag
                filelinelengths[c] = linelengths
                filecursel[c] = {0,0,0,0,0,0,0,0,0,0}
                filedt[c] = dir(filepaths[c]&filenames[c])
                bCfwds[c] = 0
                bookmarks[c] = repeat(0,length(file))
                routines[c] = 0
                restcursel()
                actions[c] = {}
                actionptr[c] = 0
                actionsave[c] = 0
                setSaveIcon(c,1,1)
                paintall()
            end if
            return 1
        end if
        stopMacroLearn(1)
        if tabfile and tabfile <= length(filepaths) then
            path = filepaths[tabfile]
            tabfile = 0
        elsif currfile then
--18/9/16:
--          path = filepaths[currfile]
            path = toString(filepaths[currfile])
        else
            path = ""
        end if
--/**/  if newopendialog then
--/**/  --  name = newGetOpenFileName(getHwnd(Main),buildFileFilter2(),{2,NULL},path)
--/**/      name = newGetOpenFileName(getHwnd(Main),buildFileFilter2(),NULL,{path})
--/**/      -- newGetSaveFileName
--/**/      void = chdir(initialcurrentdir)
--/**/      if atom(name) then return 0 end if
--/**/      -- 17/6/14
--/**/  --  encoding = name[1]-1    -- (becomes 0..3)
--/**/      encoding = name[1]
--/**/      if encoding>0 then
--/**/          encoding -= 1
--/**/      end if
--/**/      name = name[2]
--/**/  else
            name = getOpenFileName(Main,path&"*.*",buildFileFilter(),OFN_HIDEREADONLY,NULL)
            void = chdir(initialcurrentdir)
            if atom(name) then return 0 end if
            name = name[1]
--/**/  end if
    else
--/**/  if newopendialog then
--/**/      encoding = -1
--/**/  end if
    end if
--  if usegpp then
    if 0 then
        name = get_proper_path(name,"")
        -- check against existing files, if found just switch to tab.
        while 1 do
            for i = 1 to length(filepaths) do
                if equal(filepaths[i]&filenames[i],name) then
                    if i!=currfile then changeTo(i) end if
                    return 3    -- let eacons.ew know it is a "switch".
                end if
            end for
            file = readFile(name,prompt,plth)
            if sequence(file) then exit end if
            if prompt!=-1 then return 0 end if
            if length(name)>1 and name[2]=':' then return 0 end if
            prompt = 1
            name = filepaths[currfile]&name
        end while
    else -- not usegpp
        name = cleanUpPath(name) -- we asked for single file
        -- check against existing files, if found just switch to tab.
        while 1 do
            for i = 1 to length(filepaths) do
                if equal(LowerCase(filepaths[i]&filenames[i]),LowerCase(name)) then
                    if i!=currfile then changeTo(i) end if
                    return 3    -- let eacons.ew know it is a "switch".
                end if
            end for
            file = readFile(name,prompt,plth)
            if sequence(file) then exit end if
            if prompt!=-1 then return 0 end if
            if length(name)>1 and name[2]=':' then return 0 end if
            prompt = 1
            name = filepaths[currfile]&name
        end while
    end if
    newFile(name,file,linelengths,unicodeflag)
    if ltch then    -- legacy tab character handling was applied
        unpacked[currfile] = -1
    end if
    loadFolds(currfile)
    setMarginRqd()
--/**/  if newopendialog then
--/**/      if encoding!=-1 and encoding!=unicodefile[currfile] then
--/**/          -- User has invoked open, selected a file, then changed the encoding drop-down.
--/**/      --  void = messageBox(xl("Error"),"Please use \"Save As\" to change the encoding of an existing file.",0)
--/**/          unicodefile[currfile] = encoding
--/**/          void = saveFile(1)
--/**/          void = openFile(-1,1,0)
--/**/      end if
--/**/  end if
    return 1
end function
--global constant r_openFile = routine_id("openFile")
r_openFile = routine_id("openFile")

include eaini.e     -- init code and saveINI

--include src\eaedb.e
--initEditaEdb()

global function saveCurr()
integer c
    if tabfile then
        c = tabfile
        -- no reset of tabfile here
    else
        c = currfile
    end if
    if match(untitled,filenames[c])=1 then
        --2/6/10:
        changeTo(c)
        return saveFileAs()
    end if
    if actionsave[c]!=actionptr[c] then
        --2/6/10:
        changeTo(c)
        return saveFile(1)
    end if
    return 1
end function
global constant r_saveCurr=routine_id("saveCurr")

function savePrompt(integer c)
integer mbRes
    if c and actionsave[c]!=actionptr[c] 
    and not match(".err",LowerCase(filenames[c])) then
        -- 2/6/10:
        changeTo(c)
        mbRes = proemh(filepaths[c]&filenames[c],
                       xl("Save file before closing?"),
                       MB_YESNOCANCEL)
        if mbRes = IDCANCEL then return 0 end if
        if mbRes = IDYES then
            tabfile = c
            return saveCurr()
        end if
    end if
    return 1
end function

-- used by eaxutil.ew, etc
global procedure closeFile()
integer c
    stopMacroLearn(1)
    if tabfile then
        c = tabfile
        tabfile = 0
    else
        c = currfile
    end if
    if savePrompt(c) then
        tabfile = c
        closeTab()
    end if
end procedure
global constant r_closeFile = routine_id("closeFile")

constant WhiteSpace = {' ', -- space ;-)
                       #B7, -- space when ctrl-shift-H
                       #B6, --  cr    ""   ""   ""   ""
                       #BB} --  tab   ""   ""   ""   ""

--with trace
function calcnWrap(sequence oneline)
--
-- creates a wrap table for the line (already tab-expanded and checked 
-- for >charsWide-marginRqd, but without the marginRqd chars at start).
--
-- A return of {} would mean the line should be displayed in one chunk
--  (though this should not normally be called with length<charsWide),
-- a return of eg {124,241} means that the line should be displayed in 
-- three(sic) chunks: [1..124], [125..241], and [242..length(line)], 
-- with each part prefixed with appropriate marginRqd chars.
--
integer charsLeft
sequence nWrap
integer offset, chunklen, class, pclass
integer ch
    nWrap = {}
    charsLeft = length(oneline)
    offset = 0
    while 1 do
        chunklen = charsWide-marginRqd
-- 18/4/2010:
        if chunklen<=0 then
            chunklen = 1
        end if
        if charsLeft<=chunklen then exit end if
        ch = oneline[offset+chunklen+1]
        if ch>128 then
            pclass = TokenChar
        else
            pclass = charMap[ch+1]
        end if
        if pclass<=TokenLast then pclass = TokenChar end if
        for j=chunklen+1 to 2 by -1 do
            ch = oneline[offset+j]
            if ch>128 then
                class = TokenChar
            else
                class = charMap[ch+1]
            end if
            if class<=TokenLast then class = TokenChar end if
            if find(oneline[offset+j],WhiteSpace)
            or class!=pclass then
                chunklen = j
                exit
            end if
            pclass = class
        end for
        offset += chunklen
        charsLeft -= chunklen
        nWrap = append(nWrap,offset)
    end while
    return nWrap
end function


global integer r_toggleWordWrap

--integer m2000
--      m2000 = 2000

global procedure rebuildWraps(integer c, integer full)
--
-- Rebuild the word wrap table (partially) for file c.
-- Should not be called unless isWordWrapON is true 
--  (for currfile, else cursel[11]).
-- If full is zero, just do TopLine..TopLine+linesPerPage,
-- otherwise (from background processing) do max 2000 lines.
-- To force full rebuild, set wrapped[c] to 0 before calling.
--
integer wline, wmax, wfinal, BwiT
--,nextImportantLine, wrapIdx
sequence BookMarkSet, oneline
sequence nWrap
--integer mbRes
object SetEntry
    wline = wrapped[c]
    wmax = length(filetext[c])
    if not full then
        if c!=currfile then ?89/(1-isDebug) end if
        wline = TopLine
        if TopLine+linesPerPage<wmax then
            wmax = TopLine+linesPerPage
        end if
    else
        if wmax>wline+2000 then
            wmax = wline+2000
            wfinal = wmax
        else
            wfinal = -1
        end if
    end if
    BookMarkSet = bookmarks[c]
    if length(BookMarkSet)!=length(filetext[c]) then ?91/(1-isDebug) end if
    for i=wline+1 to wmax do
        SetEntry = BookMarkSet[i]
        if sequence(SetEntry) then
            -- there is an existing BookMarkSet entry for wline
            BwiT = SetEntry[bfType]
            if not and_bits(BwiT,FOLD) then
                oneline = filetext[c][i]
                if ExpLength(oneline)+marginRqd>charsWide then
                    -- update entry
                    nWrap = calcnWrap(ExpandTabs(oneline))
                    BookMarkSet[i] = 0  -- reduce ref count
                    SetEntry[bfType] = or_bits(BwiT,WRAP)
                    SetEntry[bfEnd] = nWrap
                    BookMarkSet[i] = SetEntry
                else
                    -- remove entry if rqd
                    if and_bits(BwiT,WRAP) then
                        if BwiT=WRAP then
                            -- delete entry
                            BookMarkSet[i] = 0
                        else
                            SetEntry = {} -- reduce ref count
                            BookMarkSet[i][bfType] = BwiT-WRAP  -- should be MARK
                            BookMarkSet[i][bfEnd] = 0
                        end if
                    end if
                end if
            end if
        else
            -- there is no BookMarkSet entry for wline
            oneline = filetext[c][i]
            if ExpLength(oneline)+marginRqd>charsWide then
                -- insert wrap entry
                nWrap = calcnWrap(ExpandTabs(oneline))
                BookMarkSet[i] = {WRAP,i-1,nWrap}
            end if
        end if
    end for
    if full then
        wrapped[c] = wfinal
    end if
    bookmarks[c] = BookMarkSet
end procedure

global object hFont
global integer lastFont

include src\eacolor.ew  -- SetSyntaxColours()
include src\eafonts.ew  -- PickFont()

--integer LLerrNotYetShown
----        LLerrNotYetShown = isLineLengthError

----DEV 
--procedure TestLL()
--integer linelength
--sequence linelengths
--sequence dbg
--  if isDebug and currfile then
--  linelengths = repeat(0,80)
--  for lineno = 1 to length(filetext[currfile]) do
----DEV this crashes on me & I don't really need it... (isDebug must be set anyway)
----        if c_func(xGetQueueStatus, {QS_ALLINPUT}) > #FFFF then return end if
--      linelength = ExpLength(filetext[currfile][lineno])
--      if linelength>=length(linelengths) then
--          linelengths &= repeat(0,linelength-length(linelengths)+1)
--      end if
--      linelengths[linelength+1] = linelengths[linelength+1] + 1
--  end for
--  while 1 do
--      linelength = length(linelengths)
--      if linelength = 0 then exit end if
--      if linelengths[linelength] != 0 then exit end if
--      linelengths = linelengths[1..linelength-1]
--  end while
--  while 1 do
--      linelength = length(filelinelengths[currfile])
--      if linelength = 0 then exit end if
--      if filelinelengths[currfile][linelength] != 0 then exit end if
--      filelinelengths[currfile] = filelinelengths[currfile][1..linelength-1]
--  end while
--  if not equal(linelengths,filelinelengths[currfile]) then
--      dbg = filelinelengths[currfile]
--      filelinelengths[currfile] = linelengths -- auto-correct the error.
--      if LLerrNotYetShown then
--      -- not to be translated:
--      void = messageBox("Line Lengths in Error",
--                "This is a relatively minor error,\n"&
--                "(it is automatically corrected)\n\n"&
--                "Please do NOT report \"as-is\"; instead:\n"&
--                "1) write down recent keystrokes.\n"&
--                "2) recall what text (if any) was selected.\n"&
--                "3) re-run edita with only one short (10-line)\n"&
--                "   file open, if you reproduce this, *then* get\n"&
--                "   a *.err dump (via the Tools menu), thanks.",0)
--      LLerrNotYetShown = 0
--      end if
--  end if
--  end if
--end procedure

integer mouseDown
        mouseDown = 0

global procedure clearSelection()
--
-- Clear the highlit text
--
    if selON then
        if selY>TopLine     -- selection starts on screen
        and selY<=CursorY then  -- and a forward selection, therefore not off end of screen
            paintLines(selY,CursorY)
        else
            -- just repaint the lot if it might be running off 
            -- either the top or the bottom of the screen.
            paintall()
        end if
        selON = 0
    end if
end procedure

function Ctrl() return getKeyState(VK_CONTROL) end function
function Shift() return getKeyState(VK_SHIFT) end function
function Menu() return getKeyState(VK_MENU) end function

procedure startSelection(integer shift, integer menu)
integer newSelON
    if shift or mouseDown then
        --
        -- Set anchor at current cursor position
        --
--DEV23
--      newSelON = 1 + Menu()   -- [=getKeyState(VK_MENU)]
        newSelON = 1 + menu     -- [=getKeyState(VK_MENU)]
        if not selON then
            selON = newSelON
            selY = CursorY
            selX = CursorX
        end if               
        if selON != newSelON then
            paintLines(selY,CursorY)
            selON = newSelON
        end if
    elsif selON then
        clearSelection()
    end if
end procedure

procedure checkCursorX()
-- called whenever CursorY changes.
    if selON!=2 then
        CursorX = CursorLeft(filetext[currfile][CursorY+1],CursorX+1)
    end if
    forceCursorOnscreen()
end procedure

procedure reCalcMaxLen()
    maxlen = 0
    for i=length(filelinelengths[currfile]) to 1 by -1 do
        if filelinelengths[currfile][i] then
            maxlen = i
            exit
        end if
    end for
end procedure

--with trace
--integer rlle
--  rlle = 0
procedure replaceLine(integer idx, sequence newline)
-- maintain the linelengths array as lines are modified.
-- note that idx is 1-based (unlike CursorY etc)
integer len, c
    len = ExpLength(filetext[currfile][idx]) + 1
--DEV temp hack (load files as tab8?)
--  if len>length(filelinelengths[currfile]) then
--  if not rlle then
--      void = messageBox("replaceLine Error",
--              sprintf("replacing length %d, table length %d"&
--                  "\n\n(let me know if/when this happens)",
--                  {len,length(filelinelengths[currfile])}),
--              0)
--      if isDebug then ?9/0 end if
--      rlle = 1
--  end if
--  return
--  end if

--21/9/2016 [DEV]
--  c = filelinelengths[currfile][len] - 1
    if len<=length(filelinelengths[currfile]) then
        c = filelinelengths[currfile][len] - 1
        filelinelengths[currfile][len] = c
    else
        ?"oops: filelinelengths error in replaceLine()"
        c = 0
    end if
    len = ExpLength(newline) + 1
    if len>length(filelinelengths[currfile]) then
        filelinelengths[currfile] = filelinelengths[currfile] &
                                    repeat(0,len-length(filelinelengths[currfile])+1)
    end if
    filelinelengths[currfile][len] = filelinelengths[currfile][len] + 1
    if len > maxlen or c = 0 then
        reCalcMaxLen()
    end if
    filetext[currfile][idx] = newline
end procedure

procedure removeLineLength(integer idx)
-- remove a single line length
-- note that idx is 1-based (unlike CursorY etc)
integer len, c
sequence fci
    fci = filetext[currfile][idx]
    len = ExpLength(fci) + 1
--DEV temp hack (load files as tab8?)
--  if len>length(filelinelengths[currfile]) then
--  void = messageBox("removeLineLength Error",
--          sprintf("removing length %d, table length %d"&
--              "\n\n(let me know if/when this happens)",
--              {len,length(filelinelengths[currfile])}),
--          0)
--  return
--  end if
    c = filelinelengths[currfile][len] - 1
    filelinelengths[currfile][len] = c              
--  for i = length(bookmarks[currfile]) to 1 by -1 do
--  if bookmarks[currfile][i][bfStart]=idx-1 then
--      bookmarks[currfile] = bookmarks[currfile][1..i-1]&
--              bookmarks[currfile][i+1..length(bookmarks[currfile])]
--      exit
--  end if
--  end for
    if c = 0 then reCalcMaxLen() end if
end procedure

procedure removeLineLengths(integer ixFrom, integer ixTo)
-- remove line lengths for a block deletion
-- note that ixFrom and ixTo are 1-based (unlike CursorY etc)
integer len, c, recalc
sequence fci
    recalc = 0
    for idx = Min(ixFrom,ixTo) to Max(ixFrom,ixTo) do
        fci = filetext[currfile][idx]
        len = ExpLength(fci) + 1
--DEV temp hack (load files as tab8?)
-- 5/5/08 put back in. Compared d.asm with p.asm, deleted first 100 or so lines...
--22/6/13 put back in..
    if len>length(filelinelengths[currfile]) then
        void = messageBox("removeLineLengths Error",
                sprintf("removing length %d, table length %d",
                    {len,length(filelinelengths[currfile])}),
                0)
        return
    end if
        c = filelinelengths[currfile][len] - 1
        filelinelengths[currfile][len] = c          
--  for i = length(bookmarks[currfile]) to 1 by -1 do
--      if bookmarks[currfile][i][bfStart]=idx-1 then
--      bookmarks[currfile] = bookmarks[currfile][1..i-1]&
--                  bookmarks[currfile][i+1..length(bookmarks[currfile])]
--      exit
--      end if
--  end for
        if c = 0 then recalc = 1 end if
    end for
    if recalc then reCalcMaxLen() end if
end procedure

procedure addLineLengths(sequence lines)
integer len, recalc
    recalc = 0
    for i = 1 to length(lines) do
        len = ExpLength(lines[i]) + 1
        if len>length(filelinelengths[currfile]) then
            filelinelengths[currfile] = filelinelengths[currfile] &
                                        repeat(0,len-length(filelinelengths[currfile])+1)
        end if
        filelinelengths[currfile][len] = filelinelengths[currfile][len] + 1
        if len > maxlen then recalc = 1 end if
    end for
    if recalc then reCalcMaxLen() end if
end procedure

--with trace
procedure updateQJ(integer cY, integer adjust)--, integer fromwhere)
sequence BookMarkSet
object SetEntry
integer rStart, rEnd, thisStart, L
object thisEnd
integer BiT
    if sequence(routines[currfile]) then
        L = length(routines[currfile][rtnNAMES])
        for i=1 to L do
            rStart = routines[currfile][rtnSTART][i]
            if rStart>=cY then
                for j = length(routines[currfile][rtnNAMES]) to i by -1 do
                    rStart = routines[currfile][rtnSTART][j]
                    if adjust<0 and rStart < cY-adjust then
                        routines[currfile][rtnNAMES] = routines[currfile][rtnNAMES][1..j-1]&
                                                       routines[currfile][rtnNAMES][j+1..L]
                        routines[currfile][rtnSTART] = routines[currfile][rtnSTART][1..j-1]&
                                                       routines[currfile][rtnSTART][j+1..L]
                        routines[currfile][rtnEND  ] = routines[currfile][rtnEND  ][1..j-1]&
                                                       routines[currfile][rtnEND  ][j+1..L]
                        L -= 1
                        setRtnList()
                    else
                        routines[currfile][rtnSTART][j] = rStart+adjust
--DEV should not need this (length check), surely!
                        if length(routines[currfile][rtnEND]) then
                            rEnd = routines[currfile][rtnEND][j]
                            routines[currfile][rtnEND][j] = rEnd+adjust
                        end if
                    end if
                end for
                exit
--          elsif length(routines[currfile][rtnEND]) then   --DEV surely always?
            else
                rEnd = routines[currfile][rtnEND][i]
                if rEnd>cY then
                    routines[currfile][rtnEND][i] = rEnd+adjust
                end if
            end if
        end for
    end if

    if sequence(bCfwd) then
        L = length(bCfwd)
        for i=1 to L do
            rStart = bCfwd[i][1] -- bCfwd[i][1] is the line number
            if rStart>cY then
                --1: discard entries in [deleted] range
                while adjust<0 and rStart<cY-adjust do
                    bCfwd = bCfwd[1..i-1]&bCfwd[i+1..L]
                    L -= 1
                    if L<i then exit end if -- we trimmed rest of set
                    rStart = bCfwd[i][1]
                end while
                --2: apply adjust to remainder of set
                for j=i to L do
                    bCfwd[j][1] = bCfwd[j][1] + adjust
                end for
                exit
            end if
        end for
    end if
    BookMarkSet = bookmarks[currfile]
    bookmarks[currfile] = 0 -- reduce ref count
    --
    -- first, discard any bookmarks and folds lying within a deleted range
    --
    if adjust<0 then
        rStart = cY-1
        rEnd = rStart-adjust
        BookMarkSet = BookMarkSet[1..rStart+1]&BookMarkSet[rEnd+2..length(BookMarkSet)]
        --
        -- and the lastFold details if in range
        --
        if lastFold then
            if (lastFold>=rStart and lastFold<=rEnd)
            or (lastFoldEnd>=rStart and lastFoldEnd<=rEnd) then
                lastFold = 0
                call_proc(r_enableMenuToolBar,{})
            end if
        end if
    else -- adjust>0
        --  rStart = cY-1
        --  rEnd = rStart-adjust
        BookMarkSet = BookMarkSet[1..cY-1]&repeat(0,adjust)&BookMarkSet[cY..length(BookMarkSet)]
    end if
    for i=cY+1 to length(BookMarkSet) do
        SetEntry = BookMarkSet[i]
        if sequence(SetEntry) then
            thisStart = SetEntry[bfStart]
            thisEnd = SetEntry[bfEnd]
            BiT = SetEntry[bfType]
            SetEntry = {}
            BookMarkSet[i][bfStart] = thisStart+adjust
            if and_bits(BiT,FOLD) then
                BookMarkSet[i][bfEnd] = thisEnd+adjust
            end if
        end if
    end for
    bookmarks[currfile] = BookMarkSet
    setMarginRqd()
    --
    -- lastly, adjust the lastFold details, if any
    --
    if lastFold then
        if lastFold >= cY then
            lastFold += adjust
            lastFoldEnd += adjust
        elsif lastFoldEnd >= cY then    --DEV see "if rEnd>cY then" above...
            lastFoldEnd += adjust
        end if
    end if
end procedure
--without trace

integer cX -- for Clip()

global -- for eaundo.ew
constant SEL_COPY = 0,  SEL_DELETE = 1

--with trace
global function getSelection(integer delete)
--
-- Returns the current selection, and deletes it if rqd.
-- returns 0 if no selection
-- Note: most calls to getSelection(SEL_DELETE) should be via
-- deleteSelection() which performs the required addAction.
-- This is used by UndoRedo() and thus cannot addAction() itself.
--
integer filelen, x1, x2
sequence oneline, twoline
sequence sel
object selend
--integer cX, cY, sX, sY
integer cY, sX, sY
    if not selON or (selX=CursorX and selY=CursorY) then return 0 end if
    filelen = length(filetext[currfile])
--#without reformat
    --
    -- First make cX/Y top left & sX/Y lower right
    --
    if selON=2 then -- column mode
        if selX<CursorX then cX=selX sX=CursorX else cX=CursorX sX=selX end if
        if selY<CursorY then cY=selY sY=CursorY else cY=CursorY sY=selY end if
    elsif selY<CursorY or (selY=CursorY and selX<CursorX) then          --flip
                             cX=selX sX=CursorX
                             cY=selY sY=CursorY
    else                                                                --asis
                                                     cX=CursorX sX=selX
                                                     cY=CursorY sY=selY
    end if
--#with reformat

    oneline = filetext[currfile][cY+1]
    x1 = MapToByte(oneline,cX)
    if sY=cY or selON=2 then        -- single line/column Mode
        x2 = MapToByte(oneline,sX)
        if x1 then
            if x2 then
                sel = {oneline[x1..x2-1]}
                if delete then
                    oneline = oneline[1..x1-1]&oneline[x2..length(oneline)]
                end if
            else
                sel = {oneline[x1..length(oneline)]}
                if delete then
                    oneline = oneline[1..x1-1]
                end if
            end if
        else
            if x2 then
                sel = {oneline[1..x2-1]}
                if delete then
                    oneline = oneline[x2..length(oneline)]
                end if
            else
                sel = {{}}
            end if
        end if
    else                    -- multi line
        twoline = filetext[currfile][sY+1]
        x2 = MapToByte(twoline,sX)
        selend = {}
        if x1 then
            sel = {oneline[x1..length(oneline)]}
            if x2 then
                if delete then
                    oneline = oneline[1..x1-1]&twoline[x2..length(twoline)]
                end if
                selend = twoline[1..x2-1]
            else
                if delete then
                    oneline = oneline[1..x1-1]
                end if
                selend = twoline
            end if
        else
            sel = {{}}
            if x2 then
                selend = twoline[1..x2-1]
                if delete then
                    oneline &= twoline[x2..length(twoline)]
                end if
            else
                selend = twoline
            end if
        end if
        for i=cY+2 to sY do
            sel = append(sel,filetext[currfile][i])
        end for
        if delete then
            removeLineLengths(cY+2,sY+1)
            updateQJ(cY+1,cY-sY)--,1)
            filetext[currfile] = filetext[currfile][1..cY+1]&
                                 filetext[currfile][sY+2..filelen]
            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?92/(1-isDebug) end if
        end if
        if not atom(selend) then
            sel = append(sel,selend)
        end if
    end if
    --
    -- if deleting, move cursor to cX,cY (top left), and remove
    -- the selection and any highlighting.
    -- 
    if delete then
        replaceLine(cY+1,oneline)
    end if
    if selON=2 then
        for i=cY+1 to sY do -- any remaining lines in column mode
            oneline = filetext[currfile][i+1]
            x1 = MapToByte(oneline,cX)
            x2 = MapToByte(oneline,sX)
            if x1 then
                if x2 then
                    selend = oneline[x1..x2-1]
                    if delete then
                        oneline = oneline[1..x1-1]&oneline[x2..length(oneline)]
                    end if
                else
                    selend = oneline[x1..length(oneline)]
                    if delete then
                        oneline = oneline[1..x1-1]
                    end if
                end if
            else
                if x2 then
                    selend = oneline[1..x2-1]
                    if delete then
                        oneline = oneline[x2..length(oneline)]
                    end if
                else
                    selend = {}
                end if
            end if
            sel = append(sel,selend)
            if delete then
                replaceLine(i+1,oneline)
            end if
        end for
    end if
    if delete then
        CursorX = cX
        CursorY = cY
        selON = 0
        forceCursorOnscreen()
        if cY=sY then
            paintCursorY()
        else
            paintall()
        end if
    end if
    return sel
end function


procedure InsertChar(integer ch, integer InsertMode)
-- Note: all calls to InsertChar (except the inner ones in indentWith/unindent) 
-- should addAction. This is used by UndoRedo() (or at least indirectly by
-- indentWith/unindent) so cannot addAction() itself.
-- InsertMode is either insertMode (toggled via Ins), or 0 for indentWith/unindent)
sequence oneline
integer k
    selON = 0
    oneline = filetext[currfile][CursorY+1]
    k = MapToByte(oneline,CursorX)
    if k then
        if InsertMode then
            oneline = oneline[1..k-1] & ch & oneline[k..length(oneline)]
        else
            oneline[k] = ch
        end if
    else    -- at end of line
        oneline = append(oneline,ch)
    end if
    CursorX = CursorRight(oneline,CursorX)
    replaceLine(CursorY+1,oneline)
    paintCursorY()
end procedure


global procedure InsertBlock(sequence lines)
-- Note: all calls to InsertBlock should addAction.
-- This is used by UndoRedo() so cannot addAction() itself.
-- (this should only be called by Paste and UndoRedo)
integer k, lengthlines
sequence oneline, twoline

    lengthlines = length(lines)
    if lengthlines then
        oneline = filetext[currfile][CursorY+1]
        k = MapToByte(oneline,CursorX)
        if lengthlines=1 then           -- no crlf insertion
            if k then
                oneline = oneline[1..k-1] & lines[1] & oneline[k..length(oneline)]
                CursorX = ExpLength(oneline[1..k-1+length(lines[1])])
            else    -- at end of line
                oneline &= lines[1]
                CursorX = ExpLength(oneline)
            end if
            replaceLine(CursorY+1,oneline)
--void = syntaxColour(oneline,CursorY+1,0,0)
            paintCursorY()  
        else                            -- multi lines
            if k then
                twoline = oneline[k..length(oneline)]
                oneline = oneline[1..k-1] & lines[1]
            else
                twoline = {}
                oneline = oneline & lines[1]
            end if
            replaceLine(CursorY+1,oneline)
            addLineLengths(lines[2..lengthlines])
            updateQJ(CursorY+1,lengthlines-1)--,2)
            filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                 lines[2..lengthlines]&
                                 filetext[currfile][CursorY+2..length(filetext[currfile])]
            for i=CursorY+1 to CursorY+lengthlines do
                void = syntaxColour(filetext[currfile][i],i,0,0)
                void = {}
            end for
            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?93/(1-isDebug) end if

            oneline = lines[lengthlines]
            CursorX = ExpLength(oneline)
            CursorY += lengthlines-1
            replaceLine(CursorY+1,oneline&twoline)
            paintall()
        end if
        forceCursorOnscreen()
    end if
end procedure

-- used by eaundo
global function indentoneline(object what)
sequence thisline
    if and_bits(isClearOverStrike,cOVRpaste) then
        insertMode = 1
    end if
    CursorX = 0
    forceCursorOnscreen()
    if atom(what) then      -- VK_TAB
        thisline = filetext[currfile][CursorY+1]
        if length(thisline) = 0 then
            return 0
        elsif match("--/**/",thisline)=1 then
            CursorX = 6
        end if
        InsertChar(what,1)
    else                    -- comment
        for j=1 to length(what) do
            InsertChar(what[j],1)
        end for
    end if
    return 1
end function

global function indentWith(object what)
-- insert tab or comment seq at start of line
-- result is an array of 1's, indicating it was 
-- possible to indent each line (which it always is).
-- This is needed to keep undo/redo symetrical, since
-- it is not always possible to unindent.
integer k
sequence res
    if selON then
        if selY<CursorY then
            k = selY
            selY = CursorY
            CursorY = k
        end if
        selON = 0
        k = CursorY --save
        res = repeat(1,selY-CursorY+1)
        for i=CursorY to selY do
            CursorY = i
            res[i-k+1] = indentoneline(what)
        end for
        selON = 1
        selY = k
        selX = 0
        CursorX = ExpLength(filetext[currfile][CursorY+1])
--      paintall() -- done via charInput
--      return res
    else
        res = {indentoneline(what)}
    end if
    return {what,res}
end function

--used by eaundo
global function unindentoneline(object what)
sequence oneline
integer lw, leadcomment
    if and_bits(isClearOverStrike,cOVRpaste) then
        insertMode = 1
    end if
    CursorX = 0
    oneline = filetext[currfile][CursorY+1]
    lw = 0
    leadcomment = 0
    if atom(what) then      -- a tab (or other char)
        if length(oneline) and oneline[1]=what then
            lw = 1
        elsif match("--/**/",oneline) and oneline[7]=what then
            leadcomment = 1
            lw = 7
        end if
    else                -- comment seq
        if match(what,oneline)=1 then
            lw = length(what)
        end if
    end if
    if lw then
        if leadcomment then
            replaceLine(CursorY+1,oneline[1..6]&oneline[lw+1..length(oneline)])
        else
            replaceLine(CursorY+1,oneline[lw+1..length(oneline)])
        end if
        paintCursorY()
        forceCursorOnscreen()
    end if
    return lw
end function

--with trace
--global object uWith
global function unindent(object what)
-- remove tab or comment seq from start of line
-- result is set of flags indicating which lines could be done.
integer k
sequence res
    if selON then
        if selY<CursorY then
            k = selY   selY = CursorY   CursorY = k
        end if
    end if
    if equal(what,"--") 
    and length(filetext[currfile][CursorY+1])
    and find(filetext[currfile][CursorY+1][1],"<>") then
        what = filetext[currfile][CursorY+1][1..1]
    end if
--  uWith = what
    if selON then
        selON = 0
        k = CursorY --save
        res = repeat(0,selY-CursorY+1)
        for i=1 to length(res) do
            CursorY = k+i-1
            res[i] = unindentoneline(what)
        end for
        selON = 1
        selY = k
        selX = 0
        CursorX = ExpLength(filetext[currfile][CursorY+1])
    else
        res = {unindentoneline(what)}
    end if
    return {what,res}
end function

include src\eaundo.ew   -- addAction, UndoRedo

-- used by eafind.ew (replace) and earein.ew (reindent)
--with trace
global function deleteSelection()
object d
sequence pos
    pos = DeleteBlockPos()  -- save co-ords
    d = getSelection(SEL_DELETE)
    if sequence(d) and not equal(d,{{}}) then
        addAction(pos,d)
--      selON = 0 -- cleared by getSelection(SEL_DELETE)
        return 1
    end if
    return 0
end function

--with trace
include src\eaclip.ew   -- copyTextToClipboard & getTextFromClipboard


--with trace
constant COPY = 1,   CUT = 2
procedure Clip(integer mode, integer appnd)
object clipText
sequence pos, c1
integer wasSelON, outTabWidth, p1End, p2Start, p2End
integer fmt
--trace(1)
    wasSelON = selON
    if mode = COPY then
        clipText = getSelection(SEL_COPY)
    else -- mode = CUT
        pos = DeleteBlockPos()
        clipText = getSelection(SEL_DELETE)
    end if
    if sequence(clipText) then
        if mode = CUT then
            addAction(pos,clipText)
        end if
--DEV
--  if (isEu and (isReplaceTabs or Xtrans)) or isTabWidth!=8 then
--  if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
        if isReplaceTabs
        or isTabWidth!=8 or (isEu and Xtrans) then
            p2Start = 1
            p2End = length(clipText)
            if isReplaceTabs then
                outTabWidth = 0
            else
                outTabWidth = 8
            end if
--          cX = remainder(cX,isTabWidth)
            cX = remainder(cX,8)    --??
            if cX then
                if wasSelON=2 then
                    p1End = p2End
                    p2End = 0               -- do it all here (in the top loop)
                else
                    p1End = 1               -- Only the first line gets special treatment
                    p2Start = 2
                end if
                for i=1 to p1End do
                    c1 = ConvertTabs(repeat(' ',cX)&clipText[i],isTabWidth,0)   -- all spaces
                    c1 = c1[cX+1..length(c1)]
                    if outTabWidth then
                        clipText[i] = ConvertTabs(c1,isTabWidth,outTabWidth)
                    else
                        clipText[i] = c1
                    end if
                end for
            end if
            for i=p2Start to p2End do
                clipText[i] = ConvertTabs(clipText[i],isTabWidth,outTabWidth)
            end for
        end if

        if unicodefile[currfile]=0 then
            fmt = CF_TEXT
        else
            fmt = CF_UNICODETEXT
        end if
        if appnd=-1 then
            clipText = clipText&getTextFromClipboard(fmt)
        elsif appnd then
            clipText = getTextFromClipboard(fmt)&clipText
        end if
        void = copyTextToClipboard(clipText,fmt)
    end if
end procedure

--with trace
global procedure Paste()
object clipText, padding
integer cX, cY, sX, absY, rCx
integer newCursorY, newcX
sequence ci
integer fmt
--trace(1)
    if currfile then
        if and_bits(isClearOverStrike,cOVRpaste) then
            insertMode = 1
        end if
        if unicodefile[currfile]=0 then
            fmt = CF_TEXT
        else
            fmt = CF_UNICODETEXT
        end if
        clipText = getTextFromClipboard(fmt)
--      if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
--          -- This also performs translation:
--          for i=1 to length(clipText) do
--              clipText[i] = ConvertTabs(clipText[i],8,isTabWidth)
--          end for
--      end if
        if length(clipText) then
            if selON=2 then     -- column mode
                absY = Abs(CursorY-selY)+1
                if equal(clipText,repeat(clipText[1],length(clipText))) then
                    clipText = repeat(clipText[1],absY)
                else
                    if length(clipText)!=absY then
                        if length(clipText)=absY+1
                        and equal(clipText[length(clipText)],{}) then
                            clipText = clipText[1..absY] -- drop trailing {}
                        else
--                          void = messageBox(xl("Error"),
--                                          xl("incorrect length for non-uniform column paste"),
--                                          0)
--                          return
                            newCursorY = Min(selY,CursorY)
                            newcX = Min(selX,CursorX)
                            padding = xl("incorrect length for non-uniform column paste")
                            if newcX=ExpLength(filetext[currfile][newCursorY+1]) then
                                for i=2 to length(clipText) do
                                    if newcX<ExpLength(filetext[currfile][newCursorY+i]) then
                                        padding &= '\n'&xl("(NB some lines are longer than current)")
                                        exit
                                    end if
                                end for
                            end if
                            if messageBox(xl("Warning"),padding,
                                          MB_OKCANCEL+MB_DEFBUTTON2)=IDCANCEL then
                                return
                            end if
                            CursorY = newCursorY
                            cX = newcX
                            selY = CursorY+length(clipText)
                        end if
                    end if
                end if
                cY = Min(selY,CursorY)
                cX = Min(selX,CursorX)
                sX = Max(selX,CursorX)
                for i=1 to length(clipText) do
                    CursorY = cY
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                    ci = clipText[i]
                    if CursorX<cX then      -- line too short - pad
                        if length(ci) then
                            padding = {repeat(' ',cX-CursorX)}
                            selON = 0
                            addAction(INSERTBLOCK,padding)
                            InsertBlock(padding)
                        end if
                    elsif CursorX>cX and sX>cX then
                        if CursorX>sX then
                            CursorX = sX
                        end if
                        selX = CursorX
                        CursorX = cX
                        selY = cY -- one line at a time
                        selON = 1
                        if not deleteSelection() then
                            ?1
                        end if
                    end if
                    if length(ci) then
                        CursorX = cX
                        selON = 0
                        rCx = remainder(cX,8)
                        if rCx or isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
--                          ci = ConvertTabs(repeat(' ',rCx)&ci,8,0)        -- 10/1/08
                            ci = ConvertTabs(ci,8,0)
                            ci = ConvertTabs(repeat('X',rCx)&ci,8,isTabWidth)
                            ci = ci[rCx+1..length(ci)]
--                          ci = ConvertTabs(ci,0,isTabWidth)
                        end if
                        addAction(INSERTBLOCK,{ci})
                        InsertBlock({ci})
                    end if
                    cY += 1
                end for
            else
                if deleteSelection() then end if
                rCx = remainder(CursorX,8)
                if rCx or isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                    ci = ConvertTabs(clipText[1],8,0)
                    ci = ConvertTabs(repeat('X',rCx)&ci,8,isTabWidth)
                    ci = ci[rCx+1..length(ci)]
                    clipText[1] = ci
                    for i=2 to length(clipText) do
                        clipText[i] = ConvertTabs(clipText[i],8,isTabWidth)
                    end for
                end if
                addAction(INSERTBLOCK,clipText)
                InsertBlock(clipText)
            end if
            forceCursorOnscreen()
        end if
    end if
end procedure


global procedure selectAll()
    if currfile then
        selON = 1   selX = 0   selY = 0
        CursorY = length(filetext[currfile])-1
        CursorX = ExpLength(filetext[currfile][CursorY+1])
        paintall()
    end if
end procedure

--with trace
global procedure selectWord(integer SelectWord)
-- select the word under the cursor, if any.
sequence oneline
integer ch, dotfound, isnumber, validhex, lch
    if currfile then
--29/01/2011
        if selON or isCurrLineColoured then
            -- remove old currentline highlight
            clearSelection()
        end if
        dotfound = 0
        isnumber = 1
        validhex = 1
        oneline = ExpandTabs(filetext[currfile][CursorY+1])
        lch = 0
        while CursorX>0 do
--bugfix 25/6/15:
            if CursorX>length(oneline) then exit end if
            ch = oneline[CursorX]
            if ch<=128 and wordChar[ch+1]!=TokenChar then
                lch = ch
                exit
            end if
            if ch='.' then
                if CursorX>1 and oneline[CursorX-1]='.' then exit end if
                if not isnumber then exit end if
                dotfound = 1
                if CursorX<length(oneline) then
                    ch = oneline[CursorX+1]
--                  if ch = '.' then exit end if
                    if ch <'0' or ch>'9' then exit end if
                end if
            elsif ch<'0' or ch>'9' then
                if isnumber=1 and (ch='e' or ch='E') then
                    isnumber = 2
                else
                    isnumber = 0
                end if
                if ch<'A'
                or (ch>'F' and ch<'a')
                or (ch>'f') then
                    validhex = 0
                end if
            end if
            CursorX -= 1
        end while
        forceCursorOnscreen()
        selX = CursorX
        while CursorX<length(oneline) do
            ch = oneline[CursorX+1]
            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
            if ch='.' then
                if CursorX<length(oneline)-1 and oneline[CursorX+2]='.' then exit end if
                if not isnumber then exit end if
                dotfound = 1
                if CursorX>0 then
                    ch = oneline[CursorX]
--                  if ch = '.' then exit end if
                    if ch <'0' or ch>'9' then exit end if
                end if
            elsif ch<'0' or ch>'9' then
                if isnumber=1 and (ch='e' or ch='E') then
                    isnumber = 2
                else
                    isnumber = 0
                end if
                if ch<'A'
                or (ch>'F' and ch<'a')
                or (ch>'f') then
                    validhex = 0
                end if
            end if
            CursorX += 1
        end while
        selON = (selX!=CursorX) and SelectWord
        if selON and dotfound=0 and validhex=1 and lch='#' then
            selX -= 1
        end if
--catchSelChg = 1
        selY = CursorY
        paintCursorY()
        forceCursorOnscreen()
    end if
end procedure

include src\eafind.ew

global function jumpToErrorInFile(sequence oneline, integer prompt)
-- prompt can take three values. 1: yes, 0: no, -1: return {file,line} if you can
integer k,l,cY
    if match("... called from ",oneline)=1 then
        oneline = oneline[17..length(oneline)]
    end if
    if match("Warning: ",oneline)=1 then
        if length(oneline)>=11 
        and oneline[11]=':' then
            oneline = oneline[10..length(oneline)]
        else
            oneline = filepaths[currfile]&oneline[10..length(oneline)]
        end if
    elsif usegpp then
--  els
        if equal(filenames[currfile],"ctrace.out")
        and match(filepaths[currfile],oneline)!=1 then
            oneline = filepaths[currfile]&oneline
        end if
    elsif equal(LowerCase(filenames[currfile]),"ctrace.out")
      and match(LowerCase(filepaths[currfile]),LowerCase(oneline))!=1 then
        oneline = filepaths[currfile]&oneline
    end if
    while length(oneline) and oneline[1]=' ' do
        oneline = oneline[2..length(oneline)]
    end while
    if length(oneline)>2 and oneline[2]=':' then
        k = 3
    else
        k = 1
    end if
    while k<length(oneline) do
        if oneline[k]=':' then
            if k>=4 and equal(LowerCase(oneline[k-3..k-1]),"exe") then
                if prompt=1 then
                    void = messageBox(xl("Error occurred in executable"),
                                      xl("To jump to the error line, the program being executed\n"&
                                         " must be source code, not bound/compiled."),0)
                end if
                return 0
            end if
            cY = 0
            l = k
            while l<length(oneline) and find(oneline[l+1],"0123456789") do
                l += 1
                cY = cY*10+oneline[l]-'0'
            end while
            if cY then
                if prompt=-1 then
                    return {oneline[1..k-1],cY}
                end if
                if openFile(oneline[1..k-1],-1,isLegacyTabHandling) then
                    if selON or isCurrLineColoured then
                        -- remove old currentline highlight
--28/12/2010
                        paintCursorY()
                        clearSelection()
                    end if
                    if cY>length(filetext[currfile]) then
                        if prompt<=0 then return 0 end if
                        void = messageBox(xl("Warning"),xl("Error line past end of file"),0)
                        CursorY = 0
                    else
                        CursorY = cY-1
                    end if
                    CursorX = 0
                    selON = 0
                    forceCursorOnscreen()
--06/03/2010 (and above paintCursorY, which had been /replaced/ with clearSelection, resurrected)
                    if isCurrLineColoured then
                        paintCursorY()
                    end if
                    return 1
                end if
            end if
            exit
        end if
        k += 1
    end while
    if k=length(oneline) and oneline[k]=':' and prompt!=-1 then
        if openFile(oneline[1..k-1],-1,isLegacyTabHandling) then
            return 0
        end if
    end if
    if prompt=1 then
        void = messageBox(xl("Couldn't capture error vectors"),
                          xl("Move cursor to cursor to correct line \n and then double click or press F12"),0)
    end if
    return 0
end function


global function openAndShuffleErr(integer quick, sequence ename)
-- parameter quick is 1 if we don't want a new file tab when
-- isLoadErrFileOnError=0 and jumpToErrorInFile() manages to
-- decipher line[1] properly. IE from eacons, not F12 et al.
integer oldcurrfile, cold, res
sequence cperr, dirinfo
integer fn
object line1,line2
    oldcurrfile = currfile
--  if crashpath[length(crashpath)]!='\\' then
--?1    -- I don't think we need this any more.
--  crashpath&='\\'
--  end if
    cperr = crashpath&ename
    if quick and not isLoadErrFileOnError then
        fn = open(cperr,"r")
        if fn!=-1 then
            line1 = gets(fn)
            line2 = gets(fn)
            if match("p.err",ename) then
                line2 = gets(fn)
                if sequence(line2) then
                    cold = find('^',line2)
                    if cold then
                        line2 = line2[cold+1..length(line2)]
                        while length(line2) and line2[1]=' ' do
                            line2 = line2[2..length(line2)]
                        end while
                    end if
                end if
            end if
            close(fn)
            if not atom(line1) and not atom(line2)
            -- But avoid Edita's Crash() routine
            and (not match("eamenus.ew",line1) or
                 not match("in procedure Crash()",line1)) then
                if jumpToErrorInFile(line1,0) then
                    setText(SB6,line2)
                    clearSB6 = 1
                    return 0
                end if
            end if
        end if
    end if
    res = openFile(cperr,1,0)
    if res = 3 then -- if switch (ie already open) then
        dirinfo = dir(cperr)
        if currfile>length(opensize) then
            opensize &= repeat(0,currfile-length(opensize))
        end if
        if not equal(dirinfo,opensize[currfile]) then
            void = openFile(-1,1,0)       -- reopen
        end if
        opensize[currfile] = dirinfo
    end if


--  if currfile<oldcurrfile then    -- so *.err was already open
--  shuffleTabs(oldcurrfile-currfile)
--  els
--10/1/08:
--  if not isSingleDir then
--      if currfile>oldcurrfile+2 then
--          cold = currfile
--          shuffleLoop = 1 -- reduces drawing overhead
--          while currfile>oldcurrfile+2 do
--              shuffleTabs(-1)
--          end while
--          shuffleLoop = 0
--          setSaveIcon(cold,0,1)
--          setSaveIcon(currfile,1,1)
--      end if
--      if currfile>oldcurrfile+1 then
--          shuffleTabs(-1)
--      end if
--  end if
    return res
end function

include src\eacons.ew   -- Run(), console capture.

function saveAll(integer prompt)
    stopMacroLearn(1)
    for c = 1 to length(filenames) do
--      if isAutoSaveOnExit or prompt=0 then
        if (isAutoSaveOnExit and not isDebug) or prompt=0 then
            tabfile = c
            if not saveCurr() then return 1 end if      -- cancel?
        else
            if not savePrompt(c) then return 1 end if       -- cancel?
        end if
        saveFolds(c)
    end for
    DBclose()
    return 0
end function
global constant r_saveAll=routine_id("saveAll")

include src\eabind.ew   -- bind/shroud processing.

include src\eaplan9.e

include src\eacomp.ew   -- compare (and DoEvents [DEV])

include src\eadir.ew    -- directory list

include src\eaqj.ew     -- quick jump

include src\eaxutil.ew  -- translate utility

include src\eafif.ew    -- find in files

include src\earein.ew   -- re-indent file

include src\eacca.e     -- common code analysis


--with trace
procedure F2(integer control, integer shift)
sequence BookMarkSet
integer startLine
integer done
integer BiT
object bi

    BookMarkSet = bookmarks[currfile]
    startLine = CursorY
    if control then
        if shift then   -- remove all
            for i=1 to length(BookMarkSet) do
                bi = BookMarkSet[i]
                if sequence(bi) then
                    BiT = bi[bfType]
                    if and_bits(BiT,MARK) then
                        if and_bits(BiT,FOLD+WRAP) then
                            bi = 0 -- reduce ref count
                            BookMarkSet[i][bfType] = BiT-MARK  -- leave the fold/wrap in place
                        else                     -- remove entry
                            BookMarkSet[i] = 0
                        end if
                    end if
                end if
            end for
            bookmarks[currfile] = BookMarkSet
            paintall()
        else            -- toggle bookmark
            bi = BookMarkSet[CursorY+1]
            if sequence(bi) then
                BiT = bi[bfType]
                if and_bits(BiT,FOLD+WRAP) then
                    bi = 0
--DEV xor?
                    if and_bits(BiT,MARK) then
                        BookMarkSet[CursorY+1][bfType] = BiT-MARK  -- leave the fold/wrap in place
                    else
                        BookMarkSet[CursorY+1][bfType] = BiT+MARK -- mark entry as both bookmark and fold/wrap
                    end if
                else                                     -- remove entry
                    BookMarkSet[CursorY+1] = 0
                end if
            else
                BookMarkSet[CursorY+1] = {MARK,startLine,0}
            end if
--          else
--              done = 0
--              for i=1 to length(BookMarkSet) do
--                  if BookMarkSet[i][bfStart]=startLine then
--                      BiT = BookMarkSet[i][bfType]
--                      if and_bits(BiT,FOLD+WRAP) then
--                          if and_bits(BiT,MARK) then
--                              BookMarkSet[i][bfType] = BiT-MARK  -- leave the fold/wrap in place
--                          else
--                              BookMarkSet[i][bfType] = BiT+MARK -- mark entry as both bookmark and fold/wrap
--                          end if
--                      else                                     -- remove entry
--                          BookMarkSet = BookMarkSet[1..i-1]&BookMarkSet[i+1..length(BookMarkSet)]
--                      end if
--                      done = 1
--                      exit
--                  elsif BookMarkSet[i][bfStart]>startLine then -- insert entry
--                      BookMarkSet = BookMarkSet[1..i-1]&{{MARK,startLine,0}}&BookMarkSet[i..length(BookMarkSet)]
--                      done = 1
--                      exit
--                  end if
--              end for
--              if not done then
--              -- we got to the end w/o hitting >startline check above, so:
--                  BookMarkSet = append(BookMarkSet,{MARK,startLine,0})
--              end if
--          end if
            bookmarks[currfile] = BookMarkSet
        end if
        setMarginRqd()

        paintCursorY()
    else
        done = 0
        if shift then                   -- previous bookmark
            for i=CursorY to 1 by -1 do
                bi = BookMarkSet[i]
                if sequence(bi) and and_bits(bi[bfType],MARK) then
                    done = 1    --DEV better name?
                    exit
                end if
            end for
        else                        -- next bookmark
            for i=CursorY+2 to length(BookMarkSet) do
                bi = BookMarkSet[i]
                if sequence(bi) and and_bits(bi[bfType],MARK) then
                    done = 1    --DEV better name?
                    exit
                end if
            end for
        end if
        if done then
            clearSelection()
            paintCursorY()
            CursorY = bi[bfStart]
            checkCursorX()
            forceCursorOnscreen()
            paintCursorY()
        end if
    end if
end procedure

include src\eacflow.e   -- Ctrl [ and Ctrl ] matching

--global integer r_showMessageArea
--with trace


--with trace
function validFoldSelection()
-- If True returned, line range is in CursorY, cbY
integer tmp
    if selON then
        if selY != CursorY or isWordWrapON then
            if selY < CursorY then
                tmp = selY
                selY = CursorY
                CursorY = tmp
                tmp = selX
                selX = CursorX
                CursorX = tmp
            end if
            if selX = 0 then
                tmp = adjustLine(selY,-1,CursorX)   --DEV
                if length(filetext[currfile][tmp+1]) then
                    selY = tmp
                end if
            end if
            if CursorX = 0 and length(filetext[currfile][CursorY+1])=0 then
                tmp = adjustLine(CursorY,+1,CursorX)    --DEV
                if length(filetext[currfile][tmp+1]) then
                    CursorY = tmp
                end if
            end if
            if selY > CursorY or isWordWrapON then
                cbY = selY
                -- prohibit overlapping folds
                ensureVisible(CursorY,True)
                ensureVisible(cbY,True)
                return True
            end if
        end if
    end if
    ctrlBracket(0)
    if cbY = CursorY
    and CursorX then
        CursorX = 0
        ctrlBracket(0)
    end if
    if cbY<CursorY then
        tmp = cbY
        cbY = CursorY
        CursorY = tmp
        paintCursorY()
    end if
    if cbY != CursorY or isWordWrapON then
        -- prohibit overlapping folds
        ensureVisible(CursorY,True)
        ensureVisible(cbY,True)
        return True
    end if
    return False
end function

-- used by eamenus.ew
--with trace
procedure Fold(integer keycode, integer shift)
sequence BookMarkSet
object BcY  -- BookMarkSet[CursorY+1]
integer BiT
--integer BiS
    if keycode = '-' then
--trace(1)
        if shift then   -- re-fold
            if lastFold then
                CursorY = lastFold
                cbY = lastFoldEnd
                lastFold = 0
                call_proc(r_enableMenuToolBar,{})
            else
                keycode = 0
            end if
        elsif not validFoldSelection() then
            keycode = 0
        end if
    elsif keycode != '+' then
        keycode = 0
    end if
    if keycode then
        BookMarkSet = bookmarks[currfile]
        BcY = BookMarkSet[CursorY+1]
        if sequence(BcY) then
            BiT = BcY[bfType]
            if and_bits(BiT,MARK) then
                if and_bits(BiT,FOLD) then
                    BookMarkSet[CursorY+1][bfType] = MARK -- leave the bookmark in place
                    if keycode = '+' then
                        lastFold = CursorY
                        lastFoldEnd = BcY[bfEnd]
                        call_proc(r_enableMenuToolBar,{})
                    end if
                elsif keycode = '-' then
                    BookMarkSet[CursorY+1][bfType] = MARK+FOLD      -- mark entry as both bookmark and fold
                    BookMarkSet[CursorY+1][bfEnd] = cbY
                end if
            else -- remove entry
                if keycode = '+' then
                    if and_bits(BiT,FOLD) then
                        BookMarkSet[CursorY+1] = 0
                        lastFold = CursorY
                        lastFoldEnd = BcY[bfEnd]
                        call_proc(r_enableMenuToolBar,{})   --DEV better after next? if lastFold was = 0?
                    end if
                else
                    BookMarkSet[CursorY+1][bfType] = FOLD
                    BookMarkSet[CursorY+1][bfEnd] = cbY
                end if
            end if
        else
            if keycode = '-' then
                BookMarkSet[CursorY+1] = {FOLD,CursorY,cbY}
            end if
        end if
        bookmarks[currfile] = BookMarkSet
        setMarginRqd()

        CursorX = 0
        selON = 0
        forceCursorOnscreen()
        paintall()
    end if
end procedure
global constant r_Fold=routine_id("Fold")

--with trace
function keepable(sequence SetEntry, integer pm)
-- for alt - handling, keep any existing folds either
-- entirely within or entirely outside routines, ie
-- delete (return 0 for) any that might/will overlap.
-- (for alt +, just return 0 to expand all)
integer foldstart,foldend,rtnstart,rtnend
sequence rcs,rce
    if pm='+' then return 0 end if
    if sequence(routines[currfile]) then
        foldstart = SetEntry[bfStart]+1 -- routines is kept 1-based, bookmarks is kept 0-based
        foldend = SetEntry[bfEnd]+1
        rcs = routines[currfile][rtnSTART]
        rce = routines[currfile][rtnEND]
        for i=1 to length(rcs) do
            rtnstart = rcs[i]
            if foldstart<=rtnstart then
                if foldstart=rtnstart or foldend>=rtnstart then return 0 end if
            else
                rtnend = rce[i]
                if foldstart<=rtnend then
                    if foldstart=rtnend or foldend>=rtnend then return 0 end if
                end if
            end if
        end for
    end if
    return 1
end function

procedure setFolds(integer pm)
--
-- change bookmarks[currfile] for Alt - and Alt + handling.
-- pm is '+' or '-'
--
integer screenY, thisStart, thisEnd
sequence BookMarkSet
object bi

    lastFold = 0
    selON = 0   -- added 15/04/07
    screenY = distanceFromTopLine(CursorY,CursorX)  -- to reset position at end.
    --NB: landingChunk is used later

    -- first, remove all existing folds ('+' handling)
    BookMarkSet = bookmarks[currfile]
    for i=1 to length(BookMarkSet) do
        bi = BookMarkSet[i]
        if sequence(bi)
        and and_bits(bi[bfType],FOLD) then
            if not keepable(bi,pm) then     -- 03/06/07: preserve any existing folds we can
                BookMarkSet[i] = 0
                if and_bits(bi[bfType],MARK) then
                    bi[bfType] = MARK
                    bi[bfEnd] = 0
                    BookMarkSet[i] = bi
                end if
            end if
        end if
    end for
    bookmarks[currfile] = BookMarkSet
    setMarginRqd()

    if pm = '-' then
        if sequence(routines[currfile]) then
            for i=1 to length(routines[currfile][rtnNAMES]) do
                thisStart = routines[currfile][rtnSTART][i]-1
                thisEnd = routines[currfile][rtnEND][i]-1
                if thisEnd>thisStart then
                    BookMarkSet[thisStart+1] = {FOLD,thisStart,thisEnd}
                end if
                if thisStart<CursorY and thisEnd>=CursorY then
                    CursorY = thisStart
                    CursorX = 0
                end if
            end for
--      else
--          BookMarkSet = {}
        end if
        bookmarks[currfile] = BookMarkSet
        setMarginRqd()
    end if
    TopLine = adjustLine(CursorY,-screenY,landingChunk)
    TopChunk = nacX
    forceCursorOnscreen()
    paintall()
end procedure
global constant r_setFolds=routine_id("setFolds")

include eamacro.ew

include eamenus.ew  -- menus, and ini handling.

    buildFontSet()
--  LLerrNotYetShown = isLineLengthError

integer wasTB, wasTC, wasMenus, wasFP, wasMA, wasSB, wasMaximised

--with trace
procedure F11(integer shift)
atom w, taskbar, winPlace

    if shift then
        if not F11mode then toggleMenus() end if
        return
    end if

--  void = c_func(xSendMessage, {mainHwnd,WM_SETREDRAW,0,0})

    F11mode = not F11mode
    w = c_func(xGetWindowLong,{mainHwnd,GWL_STYLE})
    
    if F11mode then
        -- remove titlebar to stop mouse invoking system menu, close, etc.
        w -= and_bits(w,WS_CAPTION)

        wasMaximised = not isWindowMaximized(Main)
        if wasMaximised then
            winPlace = allocate(sizeofstruct(WINDOWPLACEMENT))
            poke4(winPlace + WINDOWPLACEMENT_length, sizeofstruct(WINDOWPLACEMENT))
            void = c_func(xGetWindowPlacement,{mainHwnd,winPlace})
            poke4(winPlace + WINDOWPLACEMENT_showCmd, SW_MAXIMIZE)
            void = c_func(xSetWindowPlacement,{mainHwnd,winPlace})
            free(winPlace)
        end if
--      if isVisible(HHH) then setVisible(HHH,False) end if
--      if isVisible(VVV) then setVisible(VVV,False) end if
        wasTB = isVisible(TB)
        if wasTB then setVisible(TB,False) end if
        wasTC = isVisible(TC)
        if wasTC then setVisible(TC,False) end if
        wasSB = isVisible(SB)
        if wasSB then setVisible(SB,False) end if

        --DEV attempts to do this any earlier cause problems, no idea why:
--      void = c_func(xSendMessage, {mainHwnd,WM_SETREDRAW,0,0})

        wasFP = isFilePanelVIS
        if wasFP then toggleTreeView(wasFP) end if  -- NB must occur before removing the menus
        wasMA = isMessageVIS
        if wasMA then toggleMsgArea() end if        -- NB must occur before removing the menus
        wasMenus = menusExist   -- I think this will always be true...
        if wasMenus then toggleMenus() end if
        changeToF11Rqd = 0

        ClipRect = getWindowRect(Main)
--      ClipRect[3..4] += ClipRect[1..2]
        ClipRect[3] = ClipRect[3]+ClipRect[1]
        ClipRect[4] = ClipRect[4]+ClipRect[2]
        ClipRect[1..2] = 0

    else
        -- replace titlebar
        w = or_bits(w,WS_CAPTION)

--      void = c_func(xSendMessage, {mainHwnd,WM_SETREDRAW,0,0})

        if wasMaximised then
            winPlace = allocate(sizeofstruct(WINDOWPLACEMENT))
            poke4(winPlace + WINDOWPLACEMENT_showCmd, SW_RESTORE)
            void = c_func(xSetWindowPlacement,{mainHwnd,winPlace})
            free(winPlace)
        end if
        if wasTB then setVisible(TB,True) end if
        if wasSB then setVisible(SB,True) end if
        if wasTC then setVisible(TC,True) end if
--      void = c_func(xSendMessage, {mainHwnd,WM_SETREDRAW,0,0})
        if wasMenus then toggleMenus() end if
        if wasFP then toggleTreeView(wasFP) end if  -- NB must occur after menus recreated
        if wasMA then toggleMsgArea() end if        -- NB must occur after menus recreated
        if changeToF11Rqd then
            changeTo(currfile)      -- incase tab switch in F11mode
        end if
    end if
    -- apply style mod and force full rebuild/redisplay:
    void = c_func(xSetWindowLong,{mainHwnd,GWL_STYLE,w})
--  void = c_func(xSendMessage, {mainHwnd,WM_SETREDRAW,1,0})
    void = c_func(xSetWindowPos, {mainHwnd, 0, 0, 0, 0, 0, SWP_UPDATECACHE})

    -- rebuild the windows taskbar as it will most likely have been mangled:
    taskbar = c_func(xFindWindow, {allocate_StringZ("Shell_TrayWnd"), NULL})
    void = c_func(xSetWindowPos, {taskbar, 0, 0, 0, 0, 0, SWP_UPDATECACHE+SWP_NOACTIVATE})

end procedure

global procedure F12(integer isAlt, integer isCtrl)
integer treeIdx
sequence oneline, cleanline
sequence cPi, cPi2
integer max,len
atom buffer
atom pInBuff, pOutBuff
integer l, nLen

--trace(1)
    if isAlt then
        if not isMessageVIS then
--          call_proc(r_showMessageArea,{})
            showMessageArea()
        end if
        while 1 do
            -- delete existing selection (from the last time we were here)
            void = c_func(xSendMessage,{maHwnd,EM_REPLACESEL,True,allocate_StringZ("")})
            void = c_func(xSendMessage,{maHwnd,EM_SETSEL,-1,0})
            void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,0})
            max = 64
            while 1 do
                buffer = allocate_TextSpace(max)
                poke4(buffer,max)   -- actually only a word
                len = c_func(xSendMessage,{maHwnd,EM_GETLINE,0,buffer})
                if len<max then exit end if
                max *= 2
            end while
            if len then
                oneline = peek({buffer,len})
--setText(Main,ppf(oneline))
                void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,len+2})
                if jumpToErrorInFile(oneline,0) then exit end if
            elsif c_func(xSendMessage,{maHwnd,EM_GETLINECOUNT,0,0})>1 then
                -- skip a blank line
                void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,2})
            else
--              void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,-1}) -- select all
--              void = c_func(xSendMessage,{maHwnd,EM_REPLACESEL,True,allocate_StringZ("")})
                setText(SB6,"Message Area is empty")
                clearSB6 = 1
                if isMessageVIS=2 then  --True, set via showMessageArea()
                    toggleMsgArea()
                end if
                exit
            end if
        end while
    elsif isCtrl then
        void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,-1})
        void = c_func(xSendMessage,{maHwnd,EM_REPLACESEL,True,allocate_StringZ("")})
        if isMessageVIS=2 then  --True, set via showMessageArea()
            toggleMsgArea()
        end if
--DEV usegpp can drop Lowercase, not that it hurts any here
-- 4/12/10:
--  elsif currfile and find(LowerCase(filenames[currfile]),{"ex.err","p.err","ctrace.out"}) then
    elsif currfile and find(getFileExtension(filenames[currfile]),{"err","out"}) then
        crashpath = filepaths[currfile]     -- added 18/01/2008
        void = jumpToErrorInFile(filetext[currfile][CursorY+1],1)
    else
        treeIdx = 0
        if currfile then
            oneline = filetext[currfile][CursorY+1]
            if length(oneline)>=6 and equal(oneline[1..6],"--/**/") then
                oneline = oneline[7..length(oneline)]
            end if
--01/08/2013:
            unicodeflag = unicodefile[currfile]
            if unicodeflag then
                -- convert widechar to UTF8 (else open/MakeString crashes with e57ifn)
                l = length(oneline)
                pInBuff = allocate(l*2)
                poke2(pInBuff,oneline)
                nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,NULL,0,NULL,NULL})
                pOutBuff = allocate(nLen)
                nLen = c_func(xWideCharToMultiByte,{CP_UTF8,0,pInBuff,l,pOutBuff,nLen,NULL,NULL})
                oneline = peek({pOutBuff,nLen})
                free(pOutBuff)
                free(pInBuff)
            end if
            treeIdx = match("include",oneline)
            if treeIdx>=4 and match("--#",oneline)=treeIdx-3 then
                oneline = oneline[1..treeIdx-4]&oneline[treeIdx..length(oneline)]
                treeIdx -= 3
            end if
            if treeIdx then
                if treeIdx+7>=length(oneline)
                or not find(oneline[treeIdx+7]," \t") then
                    treeIdx = 0
                else
                    for i=1 to treeIdx-1 do
                        if not find(oneline[i]," \t") then
                            treeIdx = 0
                            exit
                        end if
                    end for
                end if
            end if
            if treeIdx then
                oneline = oneline[treeIdx+8..length(oneline)]
                treeIdx = match("--",oneline)
                if treeIdx then
                    oneline = oneline[1..treeIdx-1]
                end if
--04/01/14:
                while length(oneline) and find(oneline[1]," \t") do oneline = oneline[2..length(oneline)] end while
                while length(oneline) and find(oneline[length(oneline)]," \t") do oneline = oneline[1..length(oneline)-1] end while
                if length(oneline)>1 and oneline[1]='\"' and oneline[length(oneline)]='\"' then oneline = oneline[2..length(oneline)-1] end if
                cleanline = lower(oneline)
                while find('\\',cleanline) do cleanline = cleanline[find('\\',cleanline)+1..length(cleanline)] end while
                while find('/',cleanline) do cleanline = cleanline[find('/',cleanline)+1..length(cleanline)] end while
                treeIdx = 0
                rebuildProjectSet = 1
                void = resetProject(0)
--trace(1)
                for i=1 to length(currProjFileSet) do
--DEV 15/5/09 fudge, currProjFileSet should not contain such garbage...
--                  if not equal(currProjFileSet[i],{0, "..", "", 1,1}) then
----                        if match(currProjFileSet[i][2],oneline) then
--                      if match(currProjFileSet[i][2],oneline)=1 then
                    cPi = currProjFileSet[i]
                    cPi2 = cPi[2]
--                  if match(cPi2,oneline)=length(oneline)-length(cPi2)+1 then
                    -- above would be good, except it matched "win32lib.ew" against "..\win32lib\win32lib.ew"
                    --  and then put us right back on the current file!! Perhaps we want something like
                    --  and equal(cleanUpPath(filepaths[currfile]&oneline),cPi[3]&cPi2) ??
--                  if equal(cPi2,oneline) then
--04/01/14:
                    if equal(lower(cPi2),cleanline) then
                        treeIdx = i
                        exit
                    end if
--                  end if
                end for
                if treeIdx then
--?treeIdx
--?currProjFileSet[treeIdx][3]&currProjFileSet[treeIdx][2]
--?cPi[3]&cPi2
--(openFile does a cleanUpPath, btw)
--                  if openFile(currProjFileSet[treeIdx][3]&currProjFileSet[treeIdx][2],1,1) then
                    if openFile(cPi[3]&cPi2,1,1) then
                        return
                    end if
--?999
                end if
                if length(oneline)>2 and oneline[2]!=':' then
                    oneline = filepaths[currfile]&oneline
                end if
--trace(1)
                if usegpp then
                    oneline = get_proper_path(oneline,"")
                else
                    oneline = cleanUpPath(oneline)
                end if
--4/1/14:
                -- c_func(xGetLongPathName,{rubbish}) returns rubbish!
                if not match(cleanline,lower(oneline)) then oneline = "" end if
            end if
        end if
--30/12/13:
        while length(oneline) and find(oneline[1]," \t") do oneline = oneline[2..length(oneline)] end while
        while length(oneline) and find(oneline[length(oneline)]," \t") do oneline = oneline[1..length(oneline)-1] end while
        if currfile and length(oneline) then
            if not openFile(oneline,0,isLegacyTabHandling) then
                void = openAndShuffleErr(0,"ex.err")
            end if
        else
            void = openAndShuffleErr(0,"ex.err")
        end if
    end if
end procedure

--DEV: use a casemap (see pcase2.e) which includes umlauts etc.

constant LOWER = 1, UPPER = 2, CAPITALISE = 3, SENTENCE = 4, INVERT = 5

function convertCase(sequence strings, integer method)
--
-- strings is a collection of text, eg
--      {"this is some text, which might be several"
--       "lines long. Matches getSelection/Paste, etc."}
--
-- method may be LOWER, UPPER, CAPITALISE, SENTENCE, or INVERT.
--
integer c,   -- a character
    pc, -- previous character
    eos,    -- end of sentence flag
    inQuote -- within double quotes flag

    pc = ' '
    eos = True
    inQuote = False
    for i=1 to length(strings) do
        for j=1 to length(strings[i]) do
            c = strings[i][j]
            if method = LOWER then
                if c>='A' and c<='Z' then
                    strings[i][j] = c+32
                end if
            elsif method = UPPER then
                if c>='a' and c<='z' then
                    strings[i][j] = c-32
                end if
            elsif method = INVERT then
                if c>='A' and c<='Z' then
                    strings[i][j] = c+32
                elsif c>='a' and c<='z' then
                    strings[i][j] = c-32
                end if
            elsif method = CAPITALISE then
                if find(pc," \"/") then
                    if c>='a' and c<='z' then
                        strings[i][j] = c-32
                    end if
                else
                    if c>='A' and c<='Z' then
                        strings[i][j] = c+32
                    end if
                end if  
            elsif method = SENTENCE then
                if pc = ' ' then
                    if eos then
                        if c>='a' and c<='z' then
                            strings[i][j] = c-32
                        end if
                        eos = False
                    else
                        if c>='A' and c<='Z' then
                            strings[i][j] = c+32
                        end if
                    end if
                else
                    if c>='A' and c<='Z' then
                        strings[i][j] = c+32
                    end if
                end if
                if find(c,".!?") then
                    eos = True
                elsif c!=' ' then
                    eos = False
                end if
                if c = '\"' then
                    c = ' '
                    inQuote = not inQuote
                    eos = inQuote
                end if
            end if
            pc = c
        end for
        if eos then
            pc = ' '
        end if
    end for
    return strings
end function

procedure caseOp(integer mode)
sequence pos
object c,d
integer fmt
    if mode<0 then
        mode = 0-mode
        pos = DeleteBlockPos()  -- save co-ords
        d = getSelection(SEL_COPY)
        if sequence(d) and not equal(d,{{}}) then   -- something to play with
            c = convertCase(d,mode)
            if not equal(c,d) then
--DEV do we really need to use the clipboard here?? [instead split Paste() in half]
--      if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                if isReplaceTabs then
                    for i=1 to length(c) do
                        c[i] = ConvertTabs(c[i],isTabWidth,0)
                    end for
                elsif isTabWidth!=8 or (isEu and Xtrans) then
                    -- This also performs translation:
                    for i=1 to length(c) do
--                      c[i] = UnPackTabs(c[i])
                        c[i] = ConvertTabs(c[i],isTabWidth,8)
                    end for
                end if

                if unicodefile[currfile]=0 then
                    fmt = CF_TEXT
                else
                    fmt = CF_UNICODETEXT
                end if
                void = copyTextToClipboard(c,fmt)
                Paste()
                restoreBlockPos(pos)
            end if
        end if
    end if
end procedure

include src\eaisense.ew as isense

integer chmHotKeyRegistered
        chmHotKeyRegistered = 0

function saveAllFilesAndINI()
-- returns 0 if OK, 1 if cancelled
    if saveAll(1) then return 1 end if
    if isDebug=False and not iniHandModded then
--?isDebug
--puts(1,"ummm:")
--if getc(0) then end if
        saveINI()   --warning: assumes closedown imminent.
    end if
    if chmHotKeyRegistered then
        void = c_func(xUnregisterHotKey,{mainHwnd,1})
        chmHotKeyRegistered = 0
    end if
    closeChm()
    void = sendMessage(TVdirl,WM_CLOSE,0,0) -- for manual tree deletion
    return 0
end function

include src\eamarea.ew  -- message area (resize handling, mainly)

--with trace
function charInput(integer keycode, integer control, integer shift)
sequence oneline, acrest
integer k
object res
--, d
    res = 0
--?{keycode,control,shift}
--if keycode=131 then trace(1) end if
    if clearSB6 then
        setText(SB6,"")
        clearSB6 = 0
    end if
    if keycode=12 and control then                      -- Ctrl L
        if not F11mode then 
            if shift then                               -- Toggle Line nos
                isLineNumbers = not isLineNumbers
                setMarginRqd()
                paintall()
            else
                toggleTreeView(2)                       -- Show/Hide file panel
            end if
        end if
    elsif keycode=13 and control then                   -- Ctrl M (Show/Hide message area)
        if not F11mode then toggleMsgArea() end if
    elsif keycode=14 then newFile("",{""},{1},0)        -- Ctrl N (New File)
    elsif keycode=15                                    -- Ctrl O (Open File)
      and not shift then -- (reopen is below)
        void = openFile(0,1,1)
    elsif currfile then
        if keycode<' '
        and keycode!=12 then -- not Ctrl L
            if keycode=1 then    selectAll()            -- Ctrl A
            elsif shift
              and keycode=2 then numbConv(8)            -- Ctrl Shift B (Show as Octal)
            elsif keycode=2 then numbConv(2)            -- Ctrl B (Show as Binary)
            elsif keycode=3 then Clip(COPY,shift)       -- Ctrl C (Copy)
            elsif keycode=4 then                        -- Ctrl D (Duplicate line)
                if and_bits(isClearOverStrike,cOVRdupline) then
                    insertMode = 1
                end if
                selON = 0
                k = CursorX                 -- Save
                CursorX = 0                 -- move to start of line
                oneline = {filetext[currfile][CursorY+1],{}}    -- with trailing CR
                addAction(INSERTBLOCK,oneline)
                InsertBlock(oneline)
                CursorX = k                 -- restore
            elsif keycode=5 then EnlargeFontSize(+1)    -- Ctrl Shift E (Enlarge font size)
--          elsif keycode=6 then Find() return {1}      -- Ctrl F (Find)
            elsif keycode=6 then
                if shift then FIF()                     -- Ctrl Shift F (Find in files)
                else Find()                 -- Ctrl F (Find)
                end if
                return {1}
            elsif keycode=7 then Goto()                 -- Ctrl G (Goto Line)
            elsif keycode=8 and control and shift then  -- Ctrl Shift H (NB not Backspace)
                toggleSpecials()
            elsif keycode=8 then numbConv(16)           -- Ctrl H (Show as Hex)
            elsif keycode='\t' then -- ie 9             -- Tab aka Ctrl I
                if shift then
--                  addAction(UNINDENT,{VK_TAB,unindent(VK_TAB)})
                    addAction(UNINDENT,unindent(VK_TAB))
                else
--DEV 23/1/11: (I thought we might need this, but seems OK without)
--                  addAction(INDENT,indentWith(VK_TAB))
                    if not deleteSelection() then
                        oneline = filetext[currfile][CursorY+1]
                        k = MapToByte(oneline,CursorX)
                        if k then
                            if not insertMode then
                                addAction(DELETECHAR,oneline[k])
                            end if
                        else
--DEV isense: autocomplete?
--DEV if at end of line...
                            if synclr:isautocomplete(VK_ESCAPE) then
                                insertMode = 1
                                acrest = {synclr:getautocomplete()}
                                addAction(INSERTBLOCK,acrest)
                                InsertBlock(acrest)
                                keycode = 0
                            end if
                        end if
                    end if
if keycode='\t' then
                    addAction(INSERTCHAR,VK_TAB)
                    InsertChar(VK_TAB,insertMode)
end if
                end if
                forceCursorOnscreen()
            elsif keycode = 10 then numbConv(-1)            -- Ctrl J (Show as sequence/string)
            elsif keycode = 11 then numbConv(10)            -- Ctrl K (Show as Decimal)
            elsif shift
              and keycode = 15 then reopen()                -- Ctrl Shift O (ReOpen File)
            elsif keycode = 16 then void = LDRun(1)         -- Ctrl P (Print Preview)
            elsif keycode = 17 then onClickToolQjmp()       -- Ctrl Q (Quick Jump)
            elsif keycode = 18 then EnlargeFontSize(-1)     -- Ctrl Shift R (Reduce font size)
            elsif keycode = 19 then void = saveCurr()       -- Ctrl S (Save)
            elsif keycode = 20 then tabsList(0)             -- Ctrl T (Tabs List)
            elsif keycode = 21 then caseOp(shift)           -- Ctrl U (Fake Ctrl U) [fake if shift<0]
            elsif keycode = 22 then Paste()                 -- Ctrl V (Paste)
            elsif keycode = 23 then selectWord(1)           -- Ctrl W (Select Word)
            elsif keycode = 24 then Clip(CUT,shift)         -- Ctrl X (Cut)
            elsif keycode = 25 then UndoRedo(REDO)          -- Ctrl Y (Redo)
            elsif keycode = 26 then UndoRedo(UNDO)          -- Ctrl Z (Undo)
                if and_bits(isClearOverStrike,cOVRpaste) then
                    insertMode = 1
                end if
            else return 0   -- don't record (no point!)
            end if
            res = {1}
        elsif keycode=' ' and control then
            if not shift and isDebug=False then
                isense:get_intellisense(0)
            end if
--15/07/2013
--      elsif keycode<=#FF then
        elsif keycode<=#FF or unicodefile[currfile] then
--        if not control then           -- [eg] ctrl backspace is 127 [???]
            if deleteSelection() then
                addAction(INSERTCHAR,keycode)
                InsertChar(keycode,True)
            else
                oneline = filetext[currfile][CursorY+1]
                k = MapToByte(oneline,CursorX)
                if k and not insertMode then
                    if not extendOverStrike(keycode,oneline[k]) then
                        addAction(INSERTCHAR,keycode)
                        CursorX += 1    -- it cannot be a tab
                        addAction(DELETECHAR,oneline[k])
                        CursorX -= 1
                    end if
--                  addAction(INSERTCHAR,keycode)   --this bug introduced in 0.1.8
                    InsertChar(keycode,insertMode)
                elsif not skipAutoComplete(keycode) then
                    synclr:stripacchar(keycode)
                    addAction(INSERTCHAR,keycode)
                    InsertChar(keycode,insertMode)
                    if isAutoComplete then
                        AutoComplete(keycode,oneline,k)
                    end if
                end if
            end if
            forceCursorOnscreen()
            res = {1}
--        end if
            shift = 0       -- for macro recording, show eg AaBbCc as one string.
        end if
        if MacroLearn then
            MacroKeys[MacroLearn] = append(MacroKeys[MacroLearn],{MR_CHAR,{keycode,control,shift}})
        end if
    end if
--  doLLtest = 1
    return res
end function
r_CharInput = routine_id("charInput")
MacroRtns[MR_CHAR] = r_CharInput


function autoindent(sequence prevline, integer k)
integer tabs, taba, tokstart, ctype, tokend, c, IndentIdx, thisII
    tabs = 0
    while tabs<k and prevline[tabs+1]='\t' do
        tabs += 1
    end while
    tokstart = tabs+1
    taba = 0
    while tokstart<=k do
        c = prevline[tokstart]
        if c>128 then
            ctype = TokenChar
        else
            ctype = charMap[c+1]
        end if
--DEV may need tweak for TokenFirst/Last:
        if ctype=TokenStart then
            tokend = tokstart+1
            while tokend<=k do
                c = prevline[tokend]
                if c>128 then
                    ctype = TokenChar
                else
                    ctype = charMap[c+1]
                end if
                if ctype>TokenChar then exit end if
                tokend += 1
            end while
            IndentIdx = find(prevline[tokstart..tokend-1],Indents[newSyntax][1])
            if IndentIdx then
                thisII = Indents[newSyntax][2][IndentIdx]
                if taba or thisII = +1 then -- keep taba>=0
                    taba += thisII
                end if
            end if
            tokstart = tokend
        elsif c='\"' then
            while 1 do
                tokstart += 1
                if tokstart>k then exit end if
                c = prevline[tokstart]
                if c = '\\' then
                    tokstart += 1
                elsif c='\"' then
                    tokstart += 1
                    exit
                end if
            end while
        elsif length(comment) and c=comment[1]
        and (length(comment)<2 or (tokstart<k and prevline[tokstart+1]=comment[2]))
        and (length(comment)<3 or (tokstart<k-1  and prevline[tokstart+2]=comment[3])) then
            exit        
        else
            if length(Indents[newSyntax][3]) then   -- single char indents, eg '{'
                IndentIdx = find(prevline[tokstart],Indents[newSyntax][3])
                if IndentIdx then
                    thisII = Indents[newSyntax][4][IndentIdx]
                    if taba or thisII = +1 then
                        taba += thisII
                    end if
                end if
            end if
            tokstart += 1
        end if
    end while
    return repeat('\t',tabs+taba)
end function

--constant VK_CSM=93
function virtualKey2(integer keycode, integer control, integer shift, integer menu)
integer filelen, k, myAction, newCol, newY, wasCursorX
sequence oneline, tabline
object res
object bci
integer alt
--?{{keycode,control,shift}}
--if keycode=112 then trace(1) end if
    res = 0
    if clearSB6 then
        setText(SB6,"")
        clearSB6 = 0
    end if
--  if not find(keycode,{VK_INSERT,VK_DELETE,VK_BACK,VK_TAB}) then
    if find(keycode,{VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN,VK_NEXT,VK_PRIOR,VK_HOME,VK_END,VK_RETURN,VK_ESCAPE,
                     '>'+128,'<'+128,']'+128,'['+128,61+128,'-'-64+128,59,'+'-64+128})
    or (keycode>=VK_F1 and keycode<=VK_F12) then
        if synclr:isautocomplete(keycode) then paintCursorY() end if
        isense:clearintellitip()
    end if
    if currfile then
        if keycode = VK_LEFT then
            startSelection(shift,menu)
            if isWordWrapON and isCurrLineColoured then paintCursorY() end if
            if control then -- jump word left
--              alt = Menu()    -- [=getKeyState(VK_MENU)]
                alt = menu  -- [=getKeyState(VK_MENU)]
                while 1 do
                    CursorX = WordLeft(filetext[currfile][CursorY+1],CursorX,alt)
                    if CursorX != -1 then exit end if
                    if CursorY = 0 then
                        CursorX = 0
                        exit
                    end if
                    newY = adjustLine(CursorY,-1,0)
                    CursorX = ExpLength(filetext[currfile][newY+1])+alt
                    if selON or isCurrLineColoured or isWordWrapON then
                        paintCursorY()
                        CursorY = newY
                        paintCursorY()
                    else
                        CursorY = newY
                    end if
                end while
            else
                if CursorX then
                    CursorX = CursorLeft(filetext[currfile][CursorY+1],CursorX)
                    if selON then paintCursorY() end if
                elsif CursorY then  -- move to end of prev. line
--          CursorX = ExpLength(filetext[currfile][adjustLine(CursorY,-1,CursorX)+1])
--          newY = adjustLine(CursorY,-1,CursorX)
                    newY = adjustLine(CursorY,-1,0)         -- 21/5/07
                    CursorX = ExpLength(filetext[currfile][newY+1]) -- ""
                    if selON=2 or isCurrLineColoured or isWordWrapON then
                        paintCursorY()
                        CursorY = newY
                        paintCursorY()
                    else
                        CursorY = newY
                    end if
                end if
            end if
            forceCursorOnscreen()
            if selON=2 then
                paintLines(selY,CursorY)
            end if
        elsif keycode = VK_RIGHT then
            startSelection(shift,menu)
            if isWordWrapON and isCurrLineColoured then paintCursorY() end if
            if control then -- jump word right
--              alt = Menu()    -- [=getKeyState(VK_MENU)]
                alt = menu      -- [=getKeyState(VK_MENU)]
                while 1 do
                    CursorX = WordRight(filetext[currfile][CursorY+1],CursorX,alt)
                    if CursorX != -1 then exit end if
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                    if CursorY >= length(filetext[currfile])-1 then exit end if
                    newY = adjustLine(CursorY,+1,CursorX)
                    CursorX = -1    -- Let next call to WordRight stop on column 1.
                    if selON or isCurrLineColoured or isWordWrapON then
                        paintCursorY()
                        CursorY = newY
                        paintCursorY()
                    else
                        CursorY = newY
                    end if
                end while
            else
                if CursorX<ExpLength(filetext[currfile][CursorY+1]) then
                    CursorX = CursorRight(filetext[currfile][CursorY+1],CursorX)
                else                -- linewrap
                    newY = adjustLine(CursorY,+1,CursorX)
                    if newY<length(filetext[currfile]) then
                        if selON or isCurrLineColoured or isWordWrapON then
                            paintCursorY()
                            CursorY = newY
                            paintCursorY()
                        else
                            CursorY = newY
                        end if
                        CursorX = 0
                    end if
                end if
            end if
            forceCursorOnscreen()
            if selON=2 then
                paintLines(selY,CursorY)
            end if
        elsif keycode = VK_UP then
            if and_bits(isClearOverStrike,cOVRup) then
                insertMode = 1
            end if
            startSelection(shift,menu)
--      if CursorY then
            if control then
                if TopLine then
                    TopLine = adjustLine(TopLine,-1,TopChunk)
                    TopChunk = nacX
                    CursorY = adjustLine(CursorY,-1,CursorX)
                    paintall()
                end if
            else
                if TopLine then
                    if distanceFromTopLine(CursorY,CursorX)=0 then
                        TopLine = adjustLine(TopLine,-1,TopChunk)
                        TopChunk = nacX
                        paintall()
                    end if
                end if
                newY = adjustLine(CursorY,-1,CursorX)
                if selON or isCurrLineColoured then
                    paintLines(newY,CursorY)
                end if
                CursorY = newY
            end if
            CursorX = nacX
            checkCursorX()
--      end if
        elsif keycode = VK_DOWN then
            if and_bits(isClearOverStrike,cOVRdown) then
                insertMode = 1
            end if
            startSelection(shift,menu)
            newY = adjustLine(CursorY,+1,CursorX)
            if newY<length(filetext[currfile]) then
                if control then
                    wasCursorX = nacX
                    TopLine = adjustLine(TopLine,+1,TopChunk)
                    TopChunk = nacX
                    nacX = wasCursorX
                    CursorY = newY
                    paintall()
                else
                    if selON or isCurrLineColoured then
                        paintLines(CursorY,newY)
                    end if
                    CursorY = newY
                end if
                CursorX = nacX
                checkCursorX()
            end if
        elsif keycode = VK_NEXT then
            if control then
                if currfile<length(filenames) then
                    if isEnabled(TC) then
                        if shift and isTabBarVIS then
                            for i = currfile+1 to length(tabs) do
                                if tabs[i] then
                                    shuffleTabs(i-currfile)
                                    exit
                                end if
                            end for
--              shuffleTabs(+1)
                        else
                            for i=currfile+1 to length(filenames) do
                                if isTabBarVIS=0 or tabs[i] then
                                    changeTo(i)
                                    exit
--              elsif i=length(tabs) then
--                  changeTo(currfile+1)
                                end if
                            end for
--              changeTo(currfile+1)
                        end if
                    end if
                end if
            else
                if and_bits(isClearOverStrike,cOVRpage) then
                    insertMode = 1
                end if
                startSelection(shift,menu)
                filelen = length(filetext[currfile])
                if adjustLine(TopLine,+linesPerPage,TopChunk) < filelen then
                    TopLine = adjustLine(TopLine,+linesPerPage,TopChunk)
                    TopChunk = nacX
                    CursorY = Min(adjustLine(CursorY,+linesPerPage,CursorX),filelen-1)
                    CursorX = nacX
                    paintall()
                    checkCursorX()
                elsif CursorY != filelen-1 then
                    jumpTo(ExpLength(filetext[currfile][filelen]),filelen-1)
                end if
            end if
        elsif keycode = VK_PRIOR then
            if control then
                if currfile>1 then
                    if isEnabled(TC) then
                        if shift and isTabBarVIS then
                            for i=currfile-1 to 1 by -1 do
                                if tabs[i] then
                                    shuffleTabs(i-currfile)
                                    exit
                                end if
                            end for
                        else
                            for i=currfile-1 to 1 by -1 do
                                if isTabBarVIS=0 or tabs[i] then
                                    changeTo(i)
                                    exit
                                end if
                            end for
                        end if
                    end if
                end if
            else
                if and_bits(isClearOverStrike,cOVRpage) then
                    insertMode = 1
                end if
                startSelection(shift,menu)
--24/2/10:
--              if TopLine then
                if TopLine or TopChunk then
                    TopLine = adjustLine(TopLine,-linesPerPage,TopChunk)
                    TopChunk = nacX
                    CursorY = adjustLine(CursorY,-linesPerPage,CursorX)
                    CursorX = nacX
                    paintall()
                    checkCursorX()
                elsif CursorY then
                    jumpTo(0,0)
                end if
            end if
        elsif keycode = VK_HOME then       
            if and_bits(isClearOverStrike,cOVRhome) then
                insertMode = 1
            end if
            startSelection(shift,menu)
            if control then
--DEV: prevRtnIdx is not set if the toolbar is not visible...
--      if rtnList and prevRtnIdx 
--              if getKeyState(VK_MENU) then        -- Ctrl Alt Home = col 1 (useful for wordwrapped lines)
--              if Menu() then  --[=getKeyState(VK_MENU)]       -- Ctrl Alt Home = col 1
                if menu then    --[=getKeyState(VK_MENU)]       -- Ctrl Alt Home = col 1
                    jumpTo(0,CursorY)                           --  (useful for wordwrapped lines)
                elsif prevRtnIdx 
                and sequence(routines[currfile])
                and CursorY!=routines[currfile][rtnSTART][prevRtnIdx]-1 then
                    jumpTo(0,routines[currfile][rtnSTART][prevRtnIdx]-1)
                else
                    jumpTo(0,0)
                end if
            elsif isHomeFirstNonBlank then
                if isWordWrapON then
                    void = distanceFromTopLine(CursorY,CursorX)
                end if
                if isWordWrapON and landingChunk then
                    CursorX = landingChunk
                else
                    newCol = leadingWhiteSpaceLength(filetext[currfile][CursorY + 1])
--          if CursorX = newCol then
--          CursorX = 0
--          else
--          CursorX = newCol
--          end if
                    if CursorX = 0 then
                        CursorX = newCol
                    else
                        CursorX = 0
                    end if
                end if
            elsif isWordWrapON then
                void = distanceFromTopLine(CursorY,CursorX)
                CursorX = landingChunk
            else
                CursorX = 0
            end if
            forceCursorOnscreen()
        elsif keycode = VK_END then    
            if and_bits(isClearOverStrike,cOVRhome) then
                insertMode = 1
            end if
            startSelection(shift,menu)
            if control then
--      if rtnList and prevRtnIdx 
--              if Menu() then  -- [=getKeyState(VK_MENU)]                  -- Ctrl Alt End = eol
                if menu then    -- [=getKeyState(VK_MENU)]                  -- Ctrl Alt End = eol
                    CursorX = ExpLength(filetext[currfile][CursorY+1])      -- (useful in wordwrap mode)
                    jumpTo(CursorX,CursorY)
                elsif prevRtnIdx 
                and sequence(routines[currfile])
                and prevRtnIdx<=length(routines[currfile][rtnEND])
                and CursorY!=routines[currfile][rtnEND][prevRtnIdx]-1 then
                    jumpTo(0,routines[currfile][rtnEND][prevRtnIdx]-1)
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                else
                    CursorY = length(filetext[currfile])-1
                    -- BUT: if last line is folded away (eg eacca.e, Alt -, Ctrl End)
                    --      then position at the start of the fold that ends there.
                    for i=length(bookmarks[currfile]) to 1 by -1 do
                        bci = bookmarks[currfile][i]
                        if sequence(bci)
                        and and_bits(bci[bfType],FOLD)
                        and CursorY=bci[bfEnd] then
                            CursorY = bci[bfStart]
                            exit
                        end if
                    end for
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                    TopLine = 0
                    TopChunk = 0
                    k = distanceFromTopLine(CursorY,CursorX)
                    if k>=linesPerPage then
                        TopLine = adjustLine(0,k-linesPerPage+1,0)
                        TopChunk = nacX
                    end if
                    paintall()
                end if
            else
                endChunk = 0
                if isWordWrapON then
                    void = distanceFromTopLine(CursorY,CursorX)
                end if
                if endChunk then
                    CursorX = endChunk-1
                else
                    CursorX = ExpLength(filetext[currfile][CursorY+1])
                end if
            end if
            forceCursorOnscreen()
        elsif keycode = VK_INSERT then
            if control then
                Clip(COPY,shift)
            elsif shift then
                Paste()
            else
                insertMode = not insertMode
                clearSelection()
            end if
        elsif keycode = VK_DELETE
           or keycode = VK_BACK then
            if control then
                if keycode = VK_DELETE then
                    Clip(CUT,shift)
                end if
--          elsif shift and keycode = VK_DELETE then
--              Cut(0)  -- No, Ctrl Delete is Cut, not Shift Delete (CSD is cuta)
            else
                if not deleteSelection() then
                    filelen = length(filetext[currfile])
                    if keycode = VK_DELETE and CursorX=ExpLength(filetext[currfile][CursorY+1]) then
                        -- join two lines
                        if CursorY+1<filelen then
                            addAction(DELETEBLOCK,{{},{}})
                            replaceLine(CursorY+1,filetext[currfile][CursorY+1]&filetext[currfile][CursorY+2])
                            removeLineLength(CursorY+2)
                            updateQJ(CursorY+1,-1)--,5)
                            filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                                 filetext[currfile][CursorY+3..filelen]
                            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?94/(1-isDebug) end if
                            paintall()
                        end if
                    elsif keycode = VK_BACK and CursorX=0 then
                        -- join two lines
                        if CursorY then
                            CursorX = ExpLength(filetext[currfile][CursorY])
                            CursorY -= 1        -- NB this is correct; previous line, visible or not.
                            replaceLine(CursorY+1,filetext[currfile][CursorY+1]&filetext[currfile][CursorY+2])
                            removeLineLength(CursorY+2)
                            updateQJ(CursorY+1,-1)--,6)
                            filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                                 filetext[currfile][CursorY+3..filelen]
                            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?95/(1-isDebug) end if
                            paintall()
                            forceCursorOnscreen()
                            addAction(DELETEBLOCK,{{},{}})
                        end if
                    else
                        oneline = filetext[currfile][CursorY+1]
                        if keycode = VK_BACK then
                            CursorX = CursorLeft(oneline,CursorX)
                            myAction = BACKSPACE
                        else
                            myAction = DELETECHAR
                        end if
                        k = MapToByte(oneline,CursorX)
                        if k then
                            addAction(myAction,oneline[k])
                            oneline = oneline[1..k-1]&oneline[k+1..length(oneline)]
                            replaceLine(CursorY+1,oneline)
                            paintCursorY()
                            forceCursorOnscreen()
                        end if
                    end if
                end if
            end if
        elsif keycode = VK_RETURN then
            ensureVisible(CursorY,True) -- unfold (top line too)
            if deleteSelection() then end if
            filelen = length(filetext[currfile])
            oneline = filetext[currfile][CursorY+1]
            k = MapToByte(oneline,CursorX)
            if acNoDrag(k,oneline,VK_RETURN) then -- check for autocompletes
                k = 0 -- so don't drag "then", "do", etc to next line.
            end if
            if k=0 then -- end of line
--DEV strip trailing spaces then?
                tabline = autoindent(oneline,length(oneline))
                oneline = tabline
            else
                replaceLine(CursorY+1,oneline[1..k-1])
                tabline = autoindent(oneline,k-1)
                oneline = tabline&oneline[k..length(oneline)]
            end if
            addLineLengths({oneline})
            updateQJ(CursorY+1,1)--,7)
            filetext[currfile] = filetext[currfile][1..CursorY+1]&
                                 {oneline}&
                                 filetext[currfile][CursorY+2..filelen]
            if length(bookmarks[currfile])!=length(filetext[currfile]) then ?9/(1-isDebug) end if

            addAction(INSERTBLOCK,{{},tabline}) -- /before/ cursor moves...
            CursorX = ExpLength(tabline)
--DEV 8/5/07: hmm... we've just unfolded cY anyhow...
--          CursorY = adjustLine(CursorY,+1,CursorX)
            CursorY += 1
            paintall()
            forceCursorOnscreen()
        elsif keycode = VK_TAB then -- Ctrl tab handled here...
            if control then
                addAction(INDENT,indentWith(VK_TAB))
            end if
            res = {1}
        elsif keycode = VK_ESCAPE then
            clearSelection()
--DEV isense:
--          if not hide_intellisense() then
            if F11mode then F11(0) end if   -- turn off fullscreen mode
--          end if
        elsif keycode = VK_F2 then
            F2(control,shift)
        elsif keycode = VK_F3 then  -- find next
            if selON or isCurrLineColoured then
                paintCursorY()
            end if
            F3key(control,shift)
        elsif keycode = VK_F4 then
            if control then
                if isEnabled(TC) then
                    closeFile()
                end if
            else
                clearSelection()
                if isCurrLineColoured then paintCursorY() end if
                F4key(shift)
            end if
        elsif keycode = VK_F5 then
            if isFTP then
                if not saveCurr() then return 0 end if
                if needsFTPing(logFile(filepaths[currfile],filenames[currfile],0)) then
                    runviaFTP(filepaths[currfile]&filenames[currfile])
                    return 0
                end if
            end if
            Run(control,shift)
        elsif keycode >= VK_F6 and keycode <= VK_F9 then
            if control then     -- start/stop recording
                RecordMacro(keycode)
                return 0        -- done
            elsif shift then
                stopMacroLearn(0)
                MacroManagement()
                return 0        -- done
            else
                PlayMacro(keycode)
            end if
        elsif keycode = VK_CSM then
            TrackMenu(control,0,CursorX,CursorY)
--      elsif not Menu() and control then
        elsif keycode = ' ' and control and shift then
--DEV incomplete
--          if isDebug=False then
                isense:intellitip()
--          end if
        elsif not menu and control then
            k = keycode - 128
            if k = '>' then
                addAction(INDENT,indentWith(comment))
                res = {1}
            elsif k = '<' then
                addAction(UNINDENT,unindent(comment))
                res = {1}
            elsif k = ']' then
-- added 17/2/09:
                if selON then
                    if selY = CursorY then
                        CursorX = 0
                        clearSelection()
                    end if
                end if
                startSelection(shift,menu)
                ctrlBracket(1)  -- forward
                if cbY = CursorY
                and cbX = CursorX
                and CursorX then
                    wasCursorX = CursorX
                    CursorX = 0
                    ctrlBracket(1)
                    if cbY=CursorY then  cbX = wasCursorX  end if
                end if
                jumpTo(cbX,cbY)
            elsif k = '[' then
-- added 17/2/09:
                if selON then
                    if selY = CursorY then
                        CursorX = 0
                        clearSelection()
                    end if
                end if
                startSelection(shift,menu)
                ctrlBracket(-1) -- backward
                if cbY = CursorY
                and cbX = CursorX
                and CursorX then
                    wasCursorX = CursorX
                    CursorX = 0
                    ctrlBracket(-1)
                    if cbY=CursorY then  cbX = wasCursorX  end if
                end if
                jumpTo(cbX,cbY)
            elsif k = 61 or k = '-' - 64 then       -- ?? Ctrl underscore/minus
                Fold('-',shift)
            elsif k = 59 or k = '+' - 64 then       -- ?? Ctrl +/= key
                Fold('+',0)
            elsif keycode!=VK_F1 then   -- unhandled keycode
                return {1}
            end if
--          end if
        elsif not find(keycode,{VK_F1,VK_F11,VK_F12}) then  -- unhandled keycode
            return 0
        end if
        if MacroLearn then
            MacroKeys[MacroLearn] = append(MacroKeys[MacroLearn],{MR_VIRT,{keycode,control,shift}})
        end if
    end if
    if keycode = VK_F1 then
        if currfile then
            rcX = CursorX
            rcY = CursorY
        end if
        F1help(control)
    elsif keycode = VK_F11 then
        F11(shift)
    elsif keycode = VK_F12 then
        F12(0,control)
    end if
--  doLLtest = 1
    return res
end function

function virtualKey(integer keycode, integer control, integer shift)
    return virtualKey2(keycode, control, shift, Menu())
end function
r_VirtualKey = routine_id("virtualKey")
MacroRtns[MR_VIRT] = r_VirtualKey


procedure acBlock(sequence lines)
-- A bit like paste, for fleshing out the autocomplete bits 'n bobs.
-- Main task here is to get indentation and undo/redo right.
sequence oneline, tabline
    oneline = filetext[currfile][CursorY+1]
    tabline = autoindent(oneline,length(oneline))
    if length(tabline) then
        for i=2 to length(lines) do
            lines[i] = tabline&lines[i]
        end for
    end if
    addAction(INSERTBLOCK,lines)
    InsertBlock(lines)
end procedure
acBlockID = routine_id("acBlock")


function sysKey(integer wParam, integer ctrl, integer shift)
-- Process Alt function keys.
integer newY
--setText(Main,"Edita: "&sprint({wParam,shift}))
    if ctrl then return 0 end if    -- avoid ctrl+alt & AltGr combos
    if    wParam=VK_INSERT then addAction(INDENT,indentWith(comment)) -- Alt Insert (comment)
    elsif wParam=VK_DELETE then addAction(UNINDENT,unindent(comment)) -- Alt Delete (uncomment)
    elsif wParam=VK_F12 then F12(1,0)
--  else    --DEV
--  if MacroLearn then  -- not supported?
    elsif isVisible(TVprjl) then    void = sendMessage(TVprjl,WM_KEYDOWN,wParam,0)
    elsif isVisible(TVdirl) then    void = sendMessage(TVdirl,WM_KEYDOWN,wParam,0)
    elsif isVisible(TVrecl) then    void = sendMessage(TVrecl,WM_KEYDOWN,wParam,0)
    elsif currfile then
        if find(wParam,{VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN}) then
            -- column selection
            mouseDown = 1
            void = virtualKey2(wParam,0,1,1) -- pretend shift down
            mouseDown = 0
        elsif wParam = VK_HOME then
            stopMacroLearn(1)
            startSelection(shift,1)
            jumpTo(TopChunk,TopLine)
        elsif wParam = VK_END then
            stopMacroLearn(1)
            startSelection(shift,1)
            newY = Min(adjustLine(TopLine,linesPerPage-1,TopChunk),length(filetext[currfile])-1)
            if isWordWrapON then
                void = distanceFromTopLine(newY,nacX)
            end if
            if isWordWrapON and landingChunk and endChunk then
                jumpTo(endChunk-1,newY)
            else
                jumpTo(ExpLength(filetext[currfile][newY+1]),newY)
            end if
        elsif wParam = VK_PRIOR then
            if currfile>1 then                  shuffleTabs(-1) end if
        elsif wParam = VK_NEXT then
            if currfile<length(filenames) then  shuffleTabs(+1) end if
        end if
    end if
    releaseMouse()
--  doLLtest = 1
    return 0
end function

--added 02/03/13:
procedure DragLine(integer direction)
-- swap current line with line+direction, move the cursor with it, and redisplay both
integer SaveCursorX
sequence oneline
integer newY

if currfile then

    newY = adjustLine(CursorY,direction,CursorX)
    if newY!=CursorY
    and newY<length(filetext[currfile]) then
        if and_bits(isClearOverStrike,cOVRup+cOVRdown+cOVRdupline) then
            insertMode = 1
        end if
        clearSelection()
        SaveCursorX = CursorX                   -- Save
        if direction=+1 then
            -- (hack)
            -- I had everything working except drag down on last but one line,
            -- which triggered an index out of bounds in InsertBlock. However
            -- drag up worked nicely everywhere, so decided to always use that.
            -- ie swap cY,nY and do a drag up, because that way works.
            CursorX = CursorY
            CursorY = newY
            newY = CursorX
        end if
        CursorX = 0                 -- move to start of line
        oneline = {filetext[currfile][CursorY+1],{}}    -- with trailing CR
--if direction=+1 then
--      if virtualKey2(VK_DOWN, 0, 1, 0) then end if
--else
        if virtualKey2(VK_END, 0, 0, 0) then end if
        if virtualKey2(VK_HOME, 0, 1, 0) then end if
        if virtualKey2(VK_LEFT, 0, 1, 0) then end if
--end if
        if not deleteSelection() then end if
        CursorY = newY
        CursorX = 0
        addAction(INSERTBLOCK,oneline)
        InsertBlock(oneline)
        if direction=-1 then
            CursorY = newY
        end if
        paintLines(newY,CursorY)
        CursorX = SaveCursorX                   -- Restore
    end if
end if
end procedure

--with trace
function sysChar(integer wParam, integer control, integer shift)
-- Process Alt normal keys
integer k
    if control then return {0} end if   -- avoid ctrl+alt & AltGr combos
    if    find(wParam,",<") then            void = charInput(VK_TAB,0,1)        -- Alt '<' = reduce indent (== shift tab)
    elsif find(wParam,".>") then            void = virtualKey2(VK_TAB,1,0,1)    -- Alt '>' = increase indent (== control tab)
    elsif find(wParam,"cC") and shift then  void = charInput(3,0,-1)            -- Alt Shift C = Copy prepend
    elsif find(wParam,"xX") and shift then  void = charInput(24,0,-1)           -- Alt Shift X = Cut prepend
    elsif find(wParam,"mM") and shift then  toggleMultiLineTabs(1)              -- Alt Shift M = toggleMLT
    elsif find(wParam,"gG") then            Goto()                              -- Alt G (== Ctrl G) (Goto Line)
    elsif find(wParam,"-_") then            setFolds('-')                       -- Alt - = fold all
    elsif find(wParam,"+=") then            setFolds('+')                       -- Alt + = expand all
    elsif find(wParam,"bB") then            DragLine(-1)                        -- Alt B = drag line back up
    elsif find(wParam,"dD") then            DragLine(+1)                        -- Alt D = drag line down
    else
        k = find(UpperCase(wParam),ULIW)    -- upper/lower/invert/wordwrap
        if k then
            if k=1 then -- uppercase/capitalise
                if shift then
                    void = charInput(21,0,-CAPITALISE)  -- Fake Ctrl U
                else
                    void = charInput(21,0,-UPPER)       -- Fake Ctrl U
                end if
            elsif k=2 then -- lowercase/sentence
                if shift then
                    void = charInput(21,0,-SENTENCE)    -- Fake Ctrl U
                else
                    void = charInput(21,0,-LOWER)       -- Fake Ctrl U
                end if
            elsif k=3 then -- invert case
                void = charInput(21,0,-INVERT)          -- Fake Ctrl U
            elsif k=4 then
                toggleWordWrap()
            else
                ?9/0
            end if
        elsif isVisible(TV) then
            shift = find(UpperCase(wParam),PDRkeys)
            if shift then
                setFocus(PDRids[shift])
            else
                return 0
            end if
        else
--setText(Main,sprintf("Edita: sysChar %s [#%02x]",wParam))
            return 0
        end if
    end if
--  doLLtest = 1
    return {0}
end function

constant BeamCursor = loadCursor(IDC_IBEAM),
         ArrowCursor = loadCursor(IDC_ARROW),
         SizeWECursor = loadCursor(IDC_SIZEWE)

integer WESizing, WExStart
        WESizing = 0

integer F12down
        F12down = 0

--constant WM_MOUSEWHEEL = #20A -- mouse wheel moved

integer justDblClick
        justDblClick = 0

integer mouseover
        mouseover = False

without trace
--with trace
procedure mouseHandler(integer msg, atom wParam, object lParam)
integer x, y, inClipRgn
integer prevCursorY, k
sequence oneline, chunk
object path
--atom msg_pos
atom point
integer tCtrl
sequence screen_coords
integer foldMargin, foldchar
--integer cip3
integer fn
integer ch
integer startx


    if currfile then
        if sequence(lParam) then
            x = lParam[1]
            y = lParam[2]
            if F11mode then
                screen_coords = clientToScreen(Main,0,0)
                x += screen_coords[1]
                y += screen_coords[2]
            end if
        end if
        if msg = WM_LBUTTONDOWN 
        or msg = WM_RBUTTONDOWN then
            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            WExStart = x
        end if
        foldMargin = marginRqd*CharWidth
        if (msg = WM_MOUSEMOVE and and_bits(wParam,MK_LBUTTON) and not F12down)
        or (msg = WM_LBUTTONDOWN and inClipRgn)
        or (msg = WM_RBUTTONDOWN and inClipRgn) then
            if WESizing and WExStart>=0 then
                void = setCursor(SizeWECursor)
                isFilePanelWidth += x-WExStart
                WExStart = x
                hideCaret()
                void = sendMessage(Main,WM_SIZE,0,0)
            else
                startSelection(Shift(),Menu())
                prevCursorY = CursorY
                if y<ClipRect[2] then                   -- above line 1
                    if TopLine then
                        TopLine = adjustLine(TopLine,-1,TopChunk)
                        TopChunk = nacX
                        paintall()
                    end if
                    CursorY = TopLine
                    paintLines(TopLine,prevCursorY)
                elsif y>ClipRect[4] then                -- below last line
                    CursorY = Min(length(filetext[currfile])-1,
                                  adjustLine(TopLine,linesPerPage,TopChunk))
                    paintall()
                else    -- anywhere inbetween, just move cursor, but not past eof.
                    CursorY = Min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
                                  length(filetext[currfile])-1)
                    paintLines(CursorY,prevCursorY)
                end if
                if x<ClipRect[1]+foldMargin then            -- left of column 1
                    if Column then
                        Column = CursorLeft(filetext[currfile][CursorY+1],Column)
                        paintall()
                    end if
                    CursorX = Column
                    if foldMargin and msg = WM_LBUTTONDOWN then
                        foldchar = '-'
                        if sequence(bookmarks[currfile][CursorY+1])
                        and and_bits(bookmarks[currfile][CursorY+1][bfType],FOLD) then
                            foldchar = '+'
                        end if
                        Fold(foldchar,0)
                    end if
                elsif x>ClipRect[3] then                -- right of last column
                    if CursorX<ExpLength(filetext[currfile][CursorY+1]) then
                        CursorX = CursorRight(filetext[currfile][CursorY+1],CursorX)
                    end if
                else    -- anywhere inbetween, just move cursor, but not past eol.
                    CursorX = Min(Column+floor((x-ClipRect[1]-foldMargin)/CharWidth),
                                  ExpLength(filetext[currfile][CursorY+1]))
                    if isWordWrapON then
                        void = adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk)
                        CursorX += nacX
                    end if
                end if
                checkCursorX()
                if msg = WM_LBUTTONDOWN then
                    mouseDown = 1
                    captureMouse(Main)
                elsif msg = WM_RBUTTONDOWN then

-- added 5/6/14:
--trace(1)
                    chovinfo = 0
                    if not find(filenames[currfile],{"ex.err","p.err","ctrace.out"}) then
                        oneline = ExpandTabs(filetext[currfile][CursorY+1])
                        chunk = syntaxColour(oneline,CursorY+1,0,0)
                        x = 0
                        for i=1 to chunkMax by 4 do
                            x += chunk[i] -- plus length
                            if x > CursorX then
                                if chunk[i+3] = 5 then  -- correct font
                                    oneline = oneline[x-chunk[i]+1..x]
                                    if chovline=CursorY+1 
                                    and chovto=x then
                                        chovinfo = 1
                                    end if
                                end if
                                exit
                            end if
                        end for
                        chunk = {}
                        x = WExStart
                    end if

                    TrackMenu(0,1,
                              Min(Column+floor((x-ClipRect[1])/CharWidth),
                                  ExpLength(filetext[currfile][CursorY+1])),
                              Min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
                                  length(filetext[currfile])-1))
                end if
                if selON=2 or isCurrLineColoured then
                    paintLines(selY,CursorY)
                else
                    paintCursorY()
                end if
            end if
        elsif msg = WM_MOUSEMOVE then
            WESizing = 0
            softSetFocus(Main)
            if caretBelongsToMain then
                if x >= ClipRect[1]+foldMargin and x <= ClipRect[3]
                and y >= ClipRect[2] and y <= ClipRect[4] then
                    void = setCursor(BeamCursor)
                    captureMouse(Main)
                else
                    if isFilePanelVIS and x<=ClipRect[1] and x>=ClipRect[1]-5 then
                        WESizing = 1
                        WExStart = -1
                        void = setCursor(SizeWECursor)
                    else
                        void = setCursor(ArrowCursor)
                    end if
                    releaseMouse()
                end if
            end if
            if not mouseover then
                mouseover = True
                trackMouseEvent(Main,or_bits(TME_HOVER,TME_LEAVE),HOVER_DEFAULT)
            end if
        elsif msg = WM_LBUTTONDOWN and WESizing then
            void = setCursor(SizeWECursor)
            captureMouse(Main)
        elsif msg = WM_LBUTTONDBLCLK then
            justDblClick = 1    -- focus issues (see eaqj)
        elsif (msg = WM_LBUTTONUP and justDblClick) then
--trace(1)
            justDblClick = 0

            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            if inClipRgn then
                if find(filenames[currfile],{"ex.err","p.err","ctrace.out"}) then
                    void = virtualKey(VK_F12,0,0)
                    F12down = 1
                else
                    oneline = ExpandTabs(filetext[currfile][CursorY+1])
                    chunk = syntaxColour(oneline,CursorY+1,0,0)
                    x = 0
--                  for i=1 to length(chunk) by 4 do
                    for i=1 to chunkMax by 4 do
                        x += chunk[i] -- plus length
                        if x > CursorX then
--                          cip3 = chunk[i+3]
                            if chunk[i+3] = 5 then  -- correct font
                                oneline = oneline[x-chunk[i]+1..x]
                                if chovline=CursorY+1 
                                and chovto=x then
                                    intellilinkgo()
                                    x = -1
                                else
                                    if length(oneline) >= 5 and oneline[5]=':' then
                                        k = find(LowerCase(oneline[1..4]),{"file","edit"})
                                        if k then
                                            if k=1 and length(oneline)>17
                                            and equal(LowerCase(oneline[1..17]),"file://localhost/") then
                                                k = 3
                                            elsif oneline[6]='\"' and oneline[length(oneline)]='\"' then
                                                oneline = oneline[7..length(oneline)-1]
                                            else
                                                oneline = oneline[6..length(oneline)]
                                            end if
                                            if k=2 then     -- edit:
                                                void = openFile(oneline,1,isLegacyTabHandling)
                                                x = -1
                                                exit
                                            end if
                                            if find('#',oneline)>2 then
                                                if k=1 and not find(oneline[2],":/\\") then
                                                    oneline = "file://localhost/"&filepaths[currfile]&oneline
                                                end if
                                                fn = open("redirect.htm","w")
                                                puts(fn,"<html><head><meta http-equiv=refresh content=\"0;url=")
                                                puts(fn,oneline)
                                                puts(fn,"\"></head></html>")
                                                close(fn)
                                                oneline = "redirect.htm"
                                            end if
                                        end if
                                    end if
                                    path = NULL
                                    for j=length(oneline) to 1 by -1 do
                                        if oneline[j]='\\' then
--path = filepaths[currfile]
                                            path = oneline[1..j]
--oneline = oneline[j+1..length(oneline)]
                                            exit
                                        end if
                                    end for
                                    void = shellExecute(NULL, "open", oneline, NULL, path, SW_SHOWNORMAL)
--
--  ShellExecute:
--  If the function fails, the return value is an error value that is less than or equal to 32.
--  The following table lists these error values:
--Value Meaning
--0                             The operating system is out of memory or resources.
--   2  ERROR_FILE_NOT_FOUND    The specified file was not found.
--   3  ERROR_PATH_NOT_FOUND    The specified path was not found.
--  11  ERROR_BAD_FORMAT        The .EXE file is invalid (non-Win32 .EXE or error in .EXE image).
--   5  SE_ERR_ACCESSDENIED     Windows 95 only: The operating system denied access to the specified file. 
--  ?   SE_ERR_ASSOCINCOMPLETE  The filename association is incomplete or invalid.
--  ?   SE_ERR_DDEBUSY          The DDE transaction could not be completed because other DDE transactions 
--                              were being processed.
--  ?   SE_ERR_DDEFAIL          The DDE transaction failed.
--  ?   SE_ERR_DDETIMEOUT       The DDE transaction could not be completed because the request timed out.
--  ?   SE_ERR_DLLNOTFOUND      Windows 95 only: The specified dynamic-link library was not found. 
--  ?   SE_ERR_FNF              Windows 95 only: The specified file was not found. 
--  ?   SE_ERR_NOASSOC          There is no application associated with the given filename extension.
--  ?   SE_ERR_OOM              Windows 95 only: There was not enough memory to complete the operation.
--  ?   SE_ERR_PNF              Windows 95 only: The specified path was not found.
--  32  SE_ERR_SHARE            A sharing violation occurred.
                                    if void = 2 then
                                        void = messageBox(xl("Error"),"ERROR_FILE_NOT_FOUND\n("&oneline&")",0)
                                    elsif void = 3 then
                                        void = messageBox(xl("Error"),"ERROR_PATH_NOT_FOUND\n("&path&")",0)
                                    elsif void = 31 then
                                        void = messageBox(xl("Error"),"ERROR_GEN_FAILURE",0)
                                    elsif void<=32 then
                                        void = messageBox(xl("Error"),sprintf("shellExecute error %d",void),0)
                                    end if
                                    x = -1
                                end if
                            end if
                            exit
                        end if
                    end for
                    if x!=-1 then selectWord(1) end if
                    chunk = {}
                end if
            end if
        elsif msg = WM_LBUTTONUP then
            mouseDown = 0
            F12down = 0
            releaseMouse()
-- moved above 5/6/14 (and forced CursorX/CursorY update).
--      elsif msg = WM_RBUTTONDOWN and inClipRgn then
--
--          TrackMenu(0,1,
--                    Min(Column+floor((x-ClipRect[1])/CharWidth),
--                        ExpLength(filetext[currfile][CursorY+1])),
--                    Min(adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk),
--                        length(filetext[currfile])-1))
        end if
    end if
    if msg=WM_MOUSEWHEEL then
        wParam = floor(wParam/#10000)
        if wParam>=#8000 then   -- sign bit set
            wParam-=#10000
        end if
        wParam = floor(wParam/120)*mouseWheelScroll

        -- get the mouse position in Client coords
        point = allocate_Point()
        void = c_func(xGetCursorPos,{point})
        void = c_func(xScreenToClient,{mainHwnd,point})
        if peek4s(point)<ClipRect[1] then
            if isVisible(TVdirl) then
                tCtrl = TVdirl
            elsif isVisible(TVprjl) then
                tCtrl = TVprjl
            elsif isVisible(TVrecl) then
                tCtrl = TVrecl
            else
                tCtrl = 0
            end if
            if tCtrl then
                while wParam>0 do
                    void = sendMessage(tCtrl,WM_VSCROLL,SB_LINEUP,0)
                    wParam -= 1
                end while
                while wParam<0 do
                    void = sendMessage(tCtrl,WM_VSCROLL,SB_LINEDOWN,0)
                    wParam += 1
                end while
            end if
        elsif currfile then
            startSelection(Shift(),Menu())
            while wParam>0 and CursorY and TopLine do
                TopLine = adjustLine(TopLine,-1,TopChunk)
                TopChunk = nacX
                CursorY = adjustLine(CursorY,-1,CursorX)
                CursorX = nacX
                paintall()
                wParam -= 1
            end while
            while wParam<0 and CursorY+1<length(filetext[currfile]) do
                TopLine = adjustLine(TopLine,+1,TopChunk)
                TopChunk = nacX
                CursorY = adjustLine(CursorY,+1,CursorX)
                CursorX = nacX
                paintall()
                wParam += 1
            end while
            forceCursorOnscreen()
        end if
    elsif msg=WM_MOUSEHOVER then
        if and_bits(wParam,MK_CONTROL) 
        and currfile then
            inClipRgn = c_func(xPtInRegion,{ClipRgn,x,y})
            if inClipRgn
            and y>=ClipRect[2]
            and y<=ClipRect[4]
            and x>=ClipRect[1]+foldMargin
            and x<=ClipRect[3] then
                y = adjustLine(TopLine,floor((y-ClipRect[2])/CharHeight),TopChunk)+1
                if y<=length(filetext[currfile]) then
                    x = Column+floor((x-ClipRect[1]-foldMargin)/CharWidth)
                    if x<=ExpLength(filetext[currfile][y]) then
                        oneline = ExpandTabs(filetext[currfile][y])
                        while x>0 do
                            ch = oneline[x]
                            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
                            if ch='.' then exit end if
                            x -= 1
                        end while
                        startx = x+1
                        while x<length(oneline) do
                            ch = oneline[x+1]
                            if ch<=128 and wordChar[ch+1]!=TokenChar then exit end if
                            if ch='.' then exit end if
                            x += 1
                        end while
                        if x>=startx then
                            intellilink(oneline[startx..x],y,startx)
                        end if
                    end if
                end if
            end if
        elsif chovline!=0 then
            chovline -= 1
            paintLines(chovline, chovline)
            chovline = 0
        end if
        trackMouseEvent(Main,or_bits(TME_HOVER,TME_LEAVE),HOVER_DEFAULT)
--      trackMouseEvent(Main,TME_HOVER,1)
    elsif msg=WM_MOUSELEAVE then
        mouseover = False
    end if
end procedure
mouseHandler(WM_MOUSEHOVER,0,0)

--with trace

--
-- CD_ constants (for WM_COPDATA messages) are granted unique numbers 
--         based (approximately) on their date of invention.
--
-- These *must* match values defined in eama.ew and easinst.ew, 
--  and also the standalone components pp, eawpaint, pFTP, and vedb.exw:
--
constant CD_CPR     = #20050224,    -- eacons.exw: Child Process ID
         CD_OWR     = #20050225,    --        "    Output Write handle
         CD_CONS    = #20050226,    --        "    Captured console output (also eama.ew)
--       CD_OPEN    = #20050227,    -- easinst.ew: open file
--       CD_EDITA   = #20050228,    --        "     Are you really Edita?
--       CD_GETF    = #20050603,
         CD_FILL    = #20050329,    -- Get filename length
--       CD_FILE    = #20050330,    --        "      filename
         CD_FILC    = #20050606,    -- Get filename character
         CD_MODE    = #20050331,    --  pp : print/preview/design
         CD_SETSEL  = #20050401,    -- eawpaint: set selection
         CD_CHKSEL  = #20050604,
         CD_SETPOS  = #20050403,    -- eawpaint: set position
         CD_INSLN   = #20050404,    -- eawpaint: insert line
         CD_INSERT  = #20050405,    -- eawpaint: insert
         CD_DELSEL  = #20050406,    -- eawpaint: delete selection
         CD_SETDEF  = #20050415,    -- eawpaint: set default
         CD_GETDEFL = #20050416,    -- eawpaint: get default length
         CD_GETDEFC = #20050603,    -- eawpaint: get default char
--       CD_WPAINT  = #20050417,    -- in use by eawpaint.
         CD_ISEU    = #20050816,    -- isEu (pp.exe)
         CD_TABW    = #20050817,    -- isTabWidth (pp.exe)
         CD_CL1L    = #20050927,    -- command_line[1] Length
         CD_CL1C    = #20050928,    -- command_line[1] Char
         CD_CL2L    = #20050929,    -- command_line[2] Length
         CD_CL2C    = #20050930,    -- command_line[2] Char
         CD_FBGS    = #20051003,    -- full background scan start
         CD_FBGSD   = #20051004,     -- full background scan done?
         CD_OPENF   = #20070501     -- "Edit with Edita" from pFTP
--       CD_ISENS   = #20130505,    -- intellisense ready   -- defined in eaisense.ew
--       CD_IHWND   = #20130506     -- intellisense hwnd
--constant CDSR = allocate(12)

--atom hGlobal
--   hGlobal = 0
sequence defaultWin
         defaultWin = "*"

constant cl = command_line()

function CDmessage(atom CDS)
-- handle WM_COPYDATA messages (single instance handling, etc)
sequence text, selection
integer msg, len, line, colfrom, colto
atom mem
--, hwnd
object s
sequence pos
--object path
    if isDebug!=False then return 0 end if
    msg = peek4u(CDS)
    len = peek4u(CDS+4) --DEV might crash if hwnd?
    if msg=CD_OPEN   -- single instance: open specified file
    or msg=CD_OPENF then    -- "Edit with Edita" from pFTP
        if len then
            mem = peek4u(CDS+8)
            text = peek({mem,len})
            void = openFile(text,1,isLegacyTabHandling)
            if msg=CD_OPENF then
                if void=3 then  -- a "switch"
                    -- so re-open as just re-downloaded
                    void = openFile(-1,1,isLegacyTabHandling)
                end if
                isFTP = 1
                markAsFTP()
            end if
            c_proc(xSetForegroundWindow,{mainHwnd})
        end if
    elsif msg=CD_EDITA then -- single instance: are you really edita?
--?CD_EDITA
        return {CD_EDITA}
    elsif msg=CD_CPR then -- Run: Child Process ID
        if len!=4 then ?9/0 end if  -- sanity check
        StoreCPR(peek4u(CDS+8)) -- see eacons.ew
    elsif msg=CD_OWR then -- Run: Output Write handle
        if len!=4 then ?9/0 end if  -- sanity check
        StoreOWR(peek4u(CDS+8)) -- see eacons.ew
    elsif msg=CD_CONS then -- Run: captured console output
--13/11/16: (temp fix for get_interpreter on 64 bit)
--      if len then
        if len and len<500 then
            text = peek({peek4u(CDS+8),len+1})
            len = length(text)
            while len and text[len] = 0 do
                len -= 1
            end while
            if len then
                if not isMessageVIS then
                    showMessageArea()
                end if
                void = c_func(xSendMessage,{maHwnd,EM_SETSEL,-1,0})     -- remove any selection
                void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,0})      -- move caret to top
                void = c_func(xSendMessage,{maHwnd,EM_REPLACESEL,True,peek4u(CDS+8)})
-- added 10/10/10:
                void = c_func(xSendMessage,{maHwnd,EM_SETSEL,0,0})      -- move caret to top
                void = c_func(xSendMessage,{maHwnd,EM_SCROLLCARET,0,0}) -- and ensure visible
            end if
        end if      
        return {CD_EDITA}   -- success!
    elsif msg=CD_FILL then -- Get path&filename length
        if actionsave[currfile]!=actionptr[currfile] then
            void = saveFile(1)
        end if
        return {length(filepaths[currfile])+length(filenames[currfile])}
    elsif msg=CD_FILC then      -- get ONE char of path&filename
        mem = peek4u(CDS+8)
        len = peek4s(mem)
        if len<=length(filepaths[currfile]) then
            return {filepaths[currfile][len]}
        else
            len -= length(filepaths[currfile])
            return {filenames[currfile][len]}
        end if
    elsif msg=CD_MODE then
        return {LDOpcode}
    elsif msg=CD_ISEU then  --DEV still used by pp
        return {isEuFile(filenames[currfile])}
    elsif msg=CD_TABW then
        return {isTabWidth}
    elsif msg=CD_SETSEL then        -- eawpaint: set selection.
        if len=12 then
            mem = peek4u(CDS+8)
            selection = peek4s({mem,3}) -- {line,colfrom,colto}
            line = selection[1]
            if line>0 and line<=length(filetext[currfile]) then
--              colto = selection[3]
--              if colto <= length(filetext[currfile][line]) then
                colto = MapToByte(filetext[currfile][line],selection[3]-1)
                if colto then
--              if colto <= ExpLength(filetext[currfile][line]) then
--                  colfrom = selection[2]
                    colfrom = MapToByte(filetext[currfile][line],selection[2]-1)
                    if colfrom>0 and colfrom<=colto then
                        clearSelection()
                        selON = 1
                        selX = ExpLength(filetext[currfile][line][1..colfrom-1])
                        selY = line-1
                        CursorX = ExpLength(filetext[currfile][line][1..colto])
                        CursorY = line-1
                        return {CD_EDITA}   -- success!
                    end if
                end if
            end if
        end if
    elsif msg=CD_CHKSEL then
        s = getSelection(SEL_COPY)
        if sequence(s) and length(s)=1 and sequence(s[1]) and length(s[1])=len then
            s = s[1]
            mem = peek4u(CDS+8)
            text = peek({mem,len})
            if text[1] = '#' then
                text = text[2..length(text)]
                if s[1] != '#' then return {0} end if
                while 1 do
                    s = s[2..length(s)]
                    if length(s) < 2 or s[1] != '0' then exit end if
                end while
            end if
            if equal(s,text) then return {CD_EDITA} end if
        end if
        return {0}
    elsif msg=CD_DELSEL then
        pos = DeleteBlockPos()  -- save co-ords
        s = getSelection(SEL_DELETE)
        if sequence(s) and not equal(s,{{}}) then
            addAction(pos,s)
        end if
        if sequence(s) and length(s)=1 and sequence(s[1]) and length(s[1])=len then
            s = s[1]
            mem = peek4u(CDS+8)
            text = peek({mem,len})
            if text[1] = '#' then
                text = text[2..length(text)]
                if s[1] != '#' then return {0} end if
                while 1 do
                    s = s[2..length(s)]
                    if length(s) < 2 or s[1] != '0' then exit end if
                end while
            end if
            if equal(s,text) then return {CD_EDITA} end if
        end if
        return {0}
    elsif msg=CD_SETPOS then        -- eawpaint: set position.
        if len = 8 then
            clearSelection()
            mem = peek4u(CDS+8)
            selection = peek4s({mem,2}) --{line,col}
            if equal(selection,{-1,-1}) then        -- EOF
                CursorY = length(filetext[currfile])
                if CursorY then
                    CursorX = ExpLength(filetext[currfile][CursorY])
                    CursorY -= 1
                    if CursorX then
                        void = virtualKey(VK_RETURN,0,0)
                    end if
                end if
                forceCursorOnscreen()
                return {CD_EDITA}
            end if
            line = selection[1]
            if line>0 and line<=length(filetext[currfile]) then
                colto = selection[2]-1
                if colto <= ExpLength(filetext[currfile][line]) then
--DEV may break if column passed is not 1...
                    CursorX = colto
                    CursorY = line-1
                    forceCursorOnscreen()
                    return {CD_EDITA}       -- success!
                end if
            end if
        end if
    elsif msg=CD_INSLN then -- eawpaint: insert line
        if len then
            text = {peek({peek4u(CDS+8),len}),{}} -- add CR to it
            addAction(INSERTBLOCK,text)
            InsertBlock(text)
            return {CD_EDITA}       -- success!
        end if      
    elsif msg=CD_INSERT then -- eawpaint: insert
        if len then
            text = {peek({peek4u(CDS+8),len})}      -- no CR
            addAction(INSERTBLOCK,text)
            InsertBlock(text)
            return {CD_EDITA}       -- success!
        end if      
    elsif msg=CD_SETDEF then        -- eawpaint: set default
        if len then
            mem = peek4u(CDS+8)
            defaultWin = peek({mem,len})
            return {CD_EDITA}       -- success!
        end if
    elsif msg=CD_GETDEFL then -- eawpaint: get default length
        return {length(defaultWin)}
    elsif msg=CD_GETDEFC then -- get default, one char at a time.
        mem = peek4u(CDS+8)
        len = peek4s(mem)
        return {defaultWin[len]}
    elsif msg=CD_CL1L then
        return {length(cl[1])}
    elsif msg=CD_CL1C then
        mem = peek4u(CDS+8)
        len = peek4s(mem)
        return {cl[1][len]}
    elsif msg=CD_CL2L then
        return {length(cl[2])}
    elsif msg=CD_CL2C then
        mem = peek4u(CDS+8)
        len = peek4s(mem)
        return {cl[2][len]}
    elsif msg=CD_FBGS then      -- CD_full_background_scan
        isBackGround = 1
        if alreadyBackGroundProcessing then
            -- force restart
            runBack = 0
            return {0}
        end if
        clearGlobalCache()
        runBack = 1
        runFullBackgroundScan = 1
        return {CD_EDITA}
    elsif msg=CD_FBGSD then     -- query full bacground scan completion status
        return {runBack}
    elsif msg=CD_RUNF then      -- "here it is" back from pFTP when asked for remote filename
        mem = peek4u(CDS+8)
        text= peek({mem,len})
--      path = NULL
--      for j=length(text) to 1 by -1 do
--          if text[j]='\\' then
--              path = text[1..j]
--              exit
--          end if
--      end for
--      void = shellExecute(NULL, "open", oneline, NULL, path, SW_SHOWNORMAL)
        void = shellExecute(NULL, "open", text, NULL, NULL, SW_SHOWNORMAL)
        if void = ERROR_GEN_FAILURE then
            void = messageBox(xl("Error"),"ERROR_GEN_FAILURE",0)
        end if
--?text
    elsif msg=CD_ISENS then
        isense:show_intellisense()
--DEV to go:
--  elsif msg=CD_IHWND then
--      if len!=4 then ?9/0 end if  -- sanity check
--      mem = peek4u(CDS+8)
--      isense:save_hwnd(peek4u(mem))
    else
        ?9/0    -- unhandled copydata message
    end if
    return 0
end function

procedure doDrag(atom hDrop)
integer len
atom mem
sequence filename
    for i=1 to c_func(xDragQueryFile,{hDrop,#FFFFFFFF,NULL,0}) do
        len = c_func(xDragQueryFile,{hDrop,i-1,NULL,0})
        mem = allocate_TextSpace(len+1)
        void = c_func(xDragQueryFile,{hDrop,i-1,mem,len+1})
        filename = peek({mem,len})
        void = openFile(filename,1,isLegacyTabHandling)
    end for
    c_proc(xDragFinish,{hDrop})
end procedure
c_proc(xDragAcceptFiles,{mainHwnd,1})


--without trace

-- for fullscreen mode:
constant screenDC = c_func(xGetDC, {0})

constant ETO_OPAQUE = 2

procedure showCaret()
sequence screen_coords
integer d, c, x
atom mem, pSize
sequence oneline
    if isWordWrapON or (CursorX>=Column and CursorX<=Column+charsWide) then
        d = distanceFromTopLine(CursorY,CursorX)
        if d>=0 and d<linesPerPage then
            CaretPosY = ClipRect[2]+CharHeight*d
            if isWordWrapON then
                c = landingChunk
--              CaretPosX = ClipRect[1]+CharWidth*(CursorX-landingChunk+marginRqd)
            else
                c = Column
--              CaretPosX = ClipRect[1]+CharWidth*(CursorX-Column+marginRqd)
            end if
--DEV unicodeflag
            if unicodefile[currfile]=0 then
                c = CharWidth*(CursorX-c+marginRqd)
            else
--trace(1)
                mem = allocate((CursorX-c)*2)
--              mem = allocate((CursorX-c)*2+4) -- Temp, allocate(0) got itself broken
                oneline = ExpandTabs(filetext[currfile][CursorY+1])
-- 2/6/14: (slice ends past of sequence, when mousewheeling on a unicode file, it seems)
--              poke2(mem,oneline[c+1..CursorX])
--              void = c_func(xGetTextExtentPoint32W,{mainDC,mem,CursorX-c,pSize})
                x = CursorX
                if x>length(oneline) then x = length(oneline) end if
                poke2(mem,oneline[c+1..x])
                pSize = allocate_Point()    -- (same size as SIZE)
                void = c_func(xGetTextExtentPoint32W,{mainDC,mem,x-c,pSize})
                c = peek4u(pSize+SIZE_cx)+CharWidth*marginRqd
                free(mem)
            end if
            CaretPosX = ClipRect[1]+c --CharWidth*(CursorX-c+marginRqd)
            if F11mode then
                screen_coords = clientToScreen(Main,0,0)
                CaretPosX -= screen_coords[1]
                CaretPosY -= screen_coords[2]
            end if
            void = c_func(xSetCaretPos,{CaretPosX,CaretPosY})
            if not CaretVisible then
                void = c_func(xShowCaret,{mainHwnd})
                CaretVisible = True
            end if
        end if
    end if
end procedure

integer IDLETIME
        IDLETIME = 250

constant CheckCapturedTimer = createTimer()
--constant CtrlHoverTimer = createTimer()
integer cctActive
        cctActive = 0

procedure doTimer(integer wParam)
    if wParam = AutoSaveTimer then
        if currfile 
        and match(untitled,filenames[currfile])!=1
        and actionsave[currfile] != actionptr[currfile] then
            void = saveFile(1)
        end if
    elsif wParam = CheckCapturedTimer then
        if CheckCaptured()=0 then
            cctActive = 0
            stopTimer(CheckCapturedTimer)
            startIdle(IDLETIME)
        end if
--  elsif wParam = CtrlHoverTimer then
--DEV
    end if
end procedure


atom lastSSB
     lastSSB = 0

integer finishINI           -- 1 initially, 2 when loadIniPart2() is in progress,
        finishINI=1         --          and 0 when done/safe to use newcurrfile.

procedure IdleHandler()
integer x,y,newx
sequence chunk  --DEV we not using a global here???
atom mem, mem2
integer offset, chunklen, zeroDrawn
sequence oneline
integer lineno
integer bkColour
integer unpacklineno, unpacklineend, unpacklinecount
atom mDC
--integer nextImportantLine, foldIdx
integer marginColour
sequence BookMarkSet
integer goIdle
integer conti
--integer wrapIdx
sequence nWrap
integer charsLeft
integer BwiT
integer nWrapIdx
--integer wasImportantLine
integer isCY    -- (lineno=CursorY+1) and (isWordWrapON=0 or displaying the chunk with CursorX in it)
integer clearRestOfScreen
integer newChunkMax
integer rebuildbCfwdAtEnd
atom oRect, pSize

    if finishINI=0 and newcurrfile then
        changeTo(newcurrfile)
        newcurrfile = 0
    end if

    if needVedb=1 and not isDebug then
        needVedb = 2
        void = proemh("Upgrade required","Verify edita.edb must be run to update the database",MB_OK)
        if LDRun("vedb") then end if
    end if

    if not currfile then
        paintRqd = 0
    end if
    if paintRqd then

        unicodeflag = unicodefile[currfile]

        unpacklineno = unpacked[currfile]
        unpacklineend = adjustLine(TopLine,linesPerPage,TopChunk)
        if unpacklineno!=-1 and unpacklineno<unpacklineend then
--          if isEu and (isReplaceTabs or Xtrans or isTabWidth!=8) then
            if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                while 1 do
                    if unpacklineno>=length(filetext[currfile]) then
                        unpacklineno=-1
                        exit
                    end if
                    unpacklineno += 1
--                  filetext[currfile][unpacklineno] = PackTabs(filetext[currfile][unpacklineno],0)
                    filetext[currfile][unpacklineno] = ConvertTabs(filetext[currfile][unpacklineno],8,isTabWidth)
                    if unpacklineno>unpacklineend then exit end if
                end while
                unpacked[currfile] = unpacklineno
            end if
--          unpacked[currfile] = unpacklineno
        end if
        rebuildbCfwdAtEnd = 0
--4/3/2013: (put back 02/08/2013)
        if atom(bCfwd) then
--      if atom(bCfwd) and not unicodefile[currfile] then
            rebuildbCfwd(unpacklineend)
            rebuildbCfwdAtEnd = 1
        end if
        lineno = adjustLine(TopLine,paintRqd-1,TopChunk)+1
        BookMarkSet = bookmarks[currfile]
        mDC = mainDC
        if F11mode then
            mDC = screenDC
            if atom(hFont) then
                void = selectObject(mDC, hFont)
            else
                void = selectObject(mDC, hFont[4])
            end if
        end if

        -- hide the Caret to prevent it being erased
        hideCaret()
        -- clip anything we draw on the tab control
        void = c_func(xSelectClipRgn,{mDC,ClipRgn})
        clearRestOfScreen = 0
        if paintRqd=1 and paintLast=0 then
            -- if drawing top line during a full redraw,
            -- then blank out the background
            --DEV set a flag: clearRestOfScreen (but is this really needed [not that it hurts]?).
            if adjustLine(TopLine,linesPerPage,TopChunk)>=length(filetext[currfile]) then
--              void = c_func(xFillRgn,{mDC,ClipRgn,backBrush})
                clearRestOfScreen = 1
            end if
        end if
        y = ClipRect[2]+(paintRqd-1)*CharHeight

        while 1 do

            lineno = adjustLine(TopLine,paintRqd-1,TopChunk)+1

            if lineno>length(filetext[currfile])
            or (paintLast!=0 and paintRqd>paintLast)
            or y>ClipRect[4] then
                if clearRestOfScreen and paintLast=0 and y<ClipRect[4] then
                    bkColour = ColourTab[Background]
                    void = c_func(xSetTextColor, {mDC, bkColour})
                    void = c_func(xSetBkColor, {mDC, bkColour})
                    x = ClipRect[1]
                    chunklen = floor((ClipRect[3]-x)/CharWidth)+1
                    mem2 = allocate_StringZ(repeat(' ',chunklen))
                    oRect = allocate_Rect()
                    while 1 do
                        poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
                        void = c_func(xExtTextOut, {mDC,x,y,ETO_OPAQUE,oRect,mem2,chunklen,NULL})
                        y += CharHeight
                        if y>ClipRect[4] then exit end if
                    end while
                end if
                paintRqd = 0
                paintLast = 0
--              if isWordWrap then
--                  x = ClipRect[1]+CharWidth*(isWordWrapCol-Column)
--                  void = c_func(xMoveToEx,{mDC,x,ClipRect[2],NULL})
--                  void = c_func(xSetBkColor, {mDC, ColourTab[Background]})
--                  void = c_func(xLineTo,{mDC,x,ClipRect[4]})
--              end if
                -- remove clip region (allow windows to display outside it!)
                void = c_func(xSelectClipRgn,{mDC,NULL})
                if rebuildbCfwdAtEnd then
                    setText(SB6,"rebuilding bCfwd")
                    rebuildbCfwd(length(filetext[currfile]))
                    setText(SB6,"")
                end if

                if atom(routines[currfile]) and isEu 
                and match(untitled,filenames[currfile])!=1 then
                    setText(SB6,"rebuilding routine list")
                    setListOfAllRoutines(currfile,filetext[currfile],2,filenames[currfile])
                    --      setRtnIndex()   -- added 17/05 (no help!)
                    setText(SB6,"")
                end if

                exit
            end if
            x = ClipRect[1]--+1     --+5 for margin
            oneline = ExpandTabs(filetext[currfile][lineno])
            chunk = {}
            --      wrapIdx = 0
            if isWordWrapON then
                nWrap = {}
                if atom(BookMarkSet[lineno])
                or not and_bits(BookMarkSet[lineno][bfType],FOLD) then
                    if length(oneline)>charsWide-marginRqd then
                        nWrap = calcnWrap(oneline)
                        if sequence(BookMarkSet[lineno]) then
                            -- there is an existing BookMarkSet entry for lineno
                            BwiT = BookMarkSet[lineno][bfType]
                            if and_bits(BwiT,WRAP) then
                                if length(BookMarkSet[lineno][bfEnd])!=length(nWrap) then
                                    paintLast = 0
                                    clearRestOfScreen = 1   -- (DEV) strictly needed only if shortening
                                end if
                                BookMarkSet[lineno][bfEnd] = nWrap
                            else
                                BookMarkSet[lineno][bfType] = MARK+WRAP
                                BookMarkSet[lineno][bfEnd] = nWrap
                                paintLast = 0
                            end if
                        else
                            -- there is no BookMarkSet entry for lineno
                            BookMarkSet[lineno] = {WRAP,lineno-1,nWrap}
                            paintLast = 0
                        end if
                    else
                        if not atom(BookMarkSet[lineno]) then
                            -- there is an existing BookMarkSet entry for lineno
                            BwiT = BookMarkSet[lineno][bfType]
                            if and_bits(BwiT,WRAP) then
                                if BwiT=WRAP then
                                    BookMarkSet[lineno] = 0
                                else
                                    BookMarkSet[lineno][bfType] = MARK
                                end if
                                paintLast = 0
                                clearRestOfScreen = 1 -- as we are shortening
                            end if
                        end if
                    end if
                end if
            end if
            if marginRqd or isLineNumbers then
                if isLineNumbers then
                    marginRqd = length(sprint(length(filetext[currfile])))+isMarginSpace
                    if isMarginSpace then
                        oneline = sprintf(sprintf("%%%dd ",marginRqd-1),lineno) & oneline
                    else
                        oneline = sprintf(sprintf("%%%dd",marginRqd),lineno) & oneline
                    end if
                else
                    marginRqd = 1+isMarginSpace
                    oneline = repeat(' ',marginRqd) & oneline
                end if
                marginColour = ColourTab[Linenos]
            else
                marginColour = 0
            end if
            if sequence(BookMarkSet[lineno]) then
                if marginRqd then
                    if and_bits(BookMarkSet[lineno][bfType],MARK) then -- a bookmark
                        oneline[1..marginRqd]=' '   -- blank out line no
                        oneline[marginRqd-isMarginSpace]='*'
                        marginColour = ColourTab[BookMarks]
                    end if
                    if and_bits(BookMarkSet[lineno][bfType],FOLD) then -- [also] a fold
                        oneline[1..marginRqd]=' '   -- blank out line no
                        oneline[marginRqd-isMarginSpace]='>'        -- shows Yellow if line is
                                -- both bookmark and fold.
                    end if
                end if
            end if

            chunk = syntaxColour(oneline,lineno,marginRqd,marginColour)
            -- chunk is now {length,txtclr,bkclr,font,length,txtclr...}
            if CursorY=synclr:getcY() 
            and MapToByte(filetext[currfile][lineno],CursorX)=0 then
                oneline &= synclr:getacrest()
            end if

            conti = 1
            offset = 0

            if isWordWrapON then

                if isDebug then
                    for i=1 to length(BookMarkSet) do
                        if sequence(BookMarkSet[i]) then
                            if BookMarkSet[i][bfStart]!=i-1 then ?96/(1-isDebug) end if
                        end if
                    end for
                end if

                bookmarks[currfile] = BookMarkSet

                nWrapIdx = 1
                if paintRqd=1 then
                    if TopChunk then
                        -- ensure TopChunk exists within nWrap.
                        -- (eg after a resize)
                        for i=length(nWrap) to 0 by -1 do
                            if i=0 then  TopChunk = 0  exit  end if
                            if TopChunk>=nWrap[i] then  TopChunk = nWrap[i]  exit  end if
                        end for
                    end if
                    if TopChunk then
                    -- align within the wrap table
                        while nWrapIdx<=length(nWrap) and TopChunk>=nWrap[nWrapIdx] do
                            nWrapIdx += 1
                        end while
                        -- align within the text itself
                        offset = TopChunk
                        -- patch in a dummy blank margin
                        oneline[TopChunk+1..TopChunk+marginRqd]=' '
                        -- and finally, leaving first marginRqd alone, 
                        --  remove TopChunk chars from the chunk table, which....
                        charsLeft = TopChunk
                        chunklen = chunk[1]
                        if chunklen>marginRqd then
                            chunklen -= marginRqd
                            if charsLeft>chunklen then
                                charsLeft -= chunklen
                                chunk[1] = marginRqd
                            else
                                chunk[1] = chunklen-charsLeft
                                charsLeft = 0
                            end if
                        end if
                        if charsLeft then
                            for i=5 to chunkMax by 4 do
                                chunklen = chunk[i]
                                if charsLeft>chunklen then
                                    charsLeft -= chunklen
                                    chunk[i] = 0
                                else
                                    chunk[i] = chunklen-charsLeft
                                    exit
                                end if
                            end for
                        end if
                        -- .... may then need a repack/shuffle:
                        --  (ie remove any length=0 entries, [lengths are in chunk[1,5,9,etc]].)
                        newChunkMax = 0
                        for i=1 to chunkMax by 4 do         -- scan for any zeroes
                            if chunk[i]=0 then              -- cut this&more out
                                for j=i+4 to chunkMax by 4 do       -- scan for later non-zeroes
                                    if chunk[j] then            -- keep this&remainder
                                        for k=j to chunkMax by 4 do
                                            chunk[i+k-j] = chunk[k]
                                            chunk[i+k-j+1] = chunk[k+1]
                                            chunk[i+k-j+2] = chunk[k+2]
                                            chunk[i+k-j+3] = chunk[k+3]
                                            newChunkMax += 4
                                        end for
                                        exit    -- quit the seconday scan for non-zero, once any found
                                    end if
                                end for
                                exit    -- quit the initial scan for zero, once any found
                            end if
                            newChunkMax += 4
                        end for
                        chunkMax = newChunkMax
                    end if
                end if
            end if  -- isWordWrapON
--bugfix 9/9/2012: (allocate_StringZ has a 100000 byte limit)
if length(oneline)>50000 then
    oneline = oneline[1..50000]
end if
if unicodeflag=0 then
            mem = allocate_StringZ(oneline)
else
            mem = allocate(length(oneline)*2)
            poke2(mem,oneline)
end if
            zeroDrawn = True
            bkColour = ColourTab[Background]

            while 1 do  -- wordwrap loop
                charsLeft = charsWide
                isCY = (lineno=CursorY+1)
                for i=conti to chunkMax by 4 do
                    conti = 0
                    -- chunk is {len, textcolour, backcolour, font,
                    --       len, textcolour, backcolour, font,
                    --       ...}
                    chunklen = chunk[i]
                    if isWordWrapON then
                        if sequence(BookMarkSet[lineno])
                        and not and_bits(BookMarkSet[lineno][bfType],FOLD) then
                            if nWrapIdx<=length(nWrap)
                            and offset+chunklen>=nWrap[nWrapIdx]+marginRqd then
                                chunklen = nWrap[nWrapIdx]-offset+marginRqd
                                nWrapIdx += 1
                                if chunklen = chunk[i] then
                                    conti = i+4
                                else
                                    chunk[i] = chunk[i]-chunklen
                                    conti = i
                                end if
                            end if
                        end if
                    end if
                    if offset+chunklen>=Column then -- skip blocks wholly left of view
                        if offset<Column then
                            chunklen -= Column-offset
                            offset = Column
                        end if
                        if chunklen>charsLeft then
                            chunklen = charsLeft+1
                        end if
                        void = c_func(xSetTextColor, {mDC, chunk[i+1]})
                        bkColour = chunk[i+2]
                        --
                        -- modify/narrow down that isCY to one chunk of a wordwrapped line:
                        --
                        if isCY=1 and isWordWrapON then
                            isCY = 2    -- Still True, but do this once per screenline only.
                                        -- (the tests below only work for offset as at display
                                        --  of the very first chunk and/or margin aka line nos)
                                        -- isCY will (may) be reset to 1 when resuming from conti.
                            if sequence(BookMarkSet[lineno])
                            and not and_bits(BookMarkSet[lineno][bfType],FOLD) then
                                -- is CursorX in the same chunk as offset?
                                for wi=length(nWrap) to 0 by -1 do
--                                  if wi=0 or offset-marginRqd>=nWrap[wi] then
                                    if wi=0 or offset>=nWrap[wi] then
                                        if (wi!=0 and CursorX<nWrap[wi])
                                        or (wi<length(nWrap) and CursorX>=nWrap[wi+1]) then
                                            isCY = 0    -- Nope! (so display this chunk with normal bg)
                                        end if
                                        exit
                                    end if
                                end for
                            end if
                        end if
--                      if lineno = CursorY+1
                        if isCY 
                        and bkColour = ColourTab[Background] then
                            bkColour = ColourTab[HighLine]
                        end if
                        void = c_func(xSetBkColor, {mDC, bkColour})
                        if lastFont!=chunk[i+3] then
                            lastFont = chunk[i+3]
--                          if atom(hFont) then
--                              -- stock fonts already set in eafonts.ew
--                              void = selectObject(mDC, hFont)
--                          elsif
                            if sequence(hFont) then
--                          if lastFont > 4 then    -- url underline
--                              void = selectObject(mDC, hFont[5])
--                          else
                                void = selectObject(mDC, hFont[lastFont])
                            end if
                        end if
--                      c_proc(xTextOut, {mDC,x,y,mem+offset,chunklen})
                        oRect = allocate_Rect()
if unicodeflag=0 then
                        if (i+4<chunkMax and not conti)
                        or bkColour != ColourTab[Background] then
                            poke4(oRect,{x,y,x+chunklen*CharWidth,y+CharHeight})
                        else
                            poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
                        end if
                        void = c_func(xExtTextOut, {mDC,x,y,ETO_OPAQUE,oRect,mem+offset,chunklen,NULL})
                        x += chunklen*CharWidth
else
--                      void = c_func(xGetTextExtentPoint32,{mDC,mem+offset*2,chunklen,pSize})
                        pSize = allocate_Point()    -- (same size as SIZE)
                        void = c_func(xGetTextExtentPoint32W,{mDC,mem+offset*2,chunklen,pSize})
                        newx = x + peek4u(pSize+SIZE_cx)
                        if (i+4<chunkMax and not conti)
                        or bkColour != ColourTab[Background] then
                            poke4(oRect,{x,y,newx,y+CharHeight})
                        else
                            poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
                        end if
                        void = c_func(xExtTextOutW,{mDC,x,y,ETO_OPAQUE,oRect,mem+offset*2,chunklen,NULL})
                        x = newx
end if
                        zeroDrawn = False
                        if not isWordWrapON then
                            if x>ClipRect[3] then exit end if
                        end if
                        charsLeft -= chunklen
                    end if
                    offset += chunklen
--                  if isWordWrapON and conti then exit end if (no need to test isWordWrapON)
                    if conti then exit end if   -- (only set if isWordWrapON)
--                  paintRqd += 1 -- NO, this endfor is more chunks same screen line...
                end for
                if zeroDrawn or bkColour != ColourTab[Background] then
                    void = c_func(xSetTextColor, {mDC, ColourTab[Background]})      -- removed 25/8.
                    if isCY then
                        bkColour = ColourTab[HighLine]
                    else
                        bkColour = ColourTab[Background]
                    end if
                    void = c_func(xSetBkColor, {mDC, bkColour})
--                  void = selectObject(mDC, hFont[lastFont])       -- no help for clipping problem
                    chunklen = floor((ClipRect[3]-x)/CharWidth)+1
                    if chunklen>0 then
--DEV use a permanent allocation of spaces? (clearly TextOut does not need a terminating null)
                        mem2 = allocate_StringZ(repeat(' ',chunklen))
--                      c_proc(xTextOut, {mDC,x,y,mem,chunklen})
                        oRect = allocate_Rect()
                        poke4(oRect,{x,y,ClipRect[3],y+CharHeight})
                        void = c_func(xExtTextOut, {mDC,x,y,ETO_OPAQUE,oRect,mem2,chunklen,NULL})
                    end if
                end if
                paintRqd += 1
                y += CharHeight
                if zeroDrawn then exit end if
                if not isWordWrapON then exit end if
                if not conti then exit end if   -- no more bits of this line to display
--wrapIdx = foldIdx

                x = ClipRect[1]
--              nWrap = append(nWrap,offset-marginRqd)
                -- create a dummy margin [mid-line]:
                if marginRqd then
                    for j=1 to marginRqd do
                        offset -= 1
                        poke(mem+offset,' ')
                    end for
                    if conti>1 then
                        conti -= 4
                        chunk[conti] = marginRqd    -- make up new chunk for marginRqd
                        chunk[conti+1] = chunk[2] -- copy textcolour,
                        chunk[conti+2] = chunk[3] --    background,
                        chunk[conti+3] = chunk[4] --    and font, from chunk [1..4].
                    else
                        chunk[conti] = chunk[conti]+marginRqd
                    end if
                end if
            end while   -- wordwrap loop
            if unicodeflag then
                free(mem)
            end if
            chunk = {}
        end while
    end if  -- if paintRqd, toplevel

    if not paintRqd and not alreadyBackGroundProcessing then        -- nothing else to do.
        alreadyBackGroundProcessing = 1

        if not F11mode and time()>lastSSB then
            lastSSB = time()+0.5
            setScrollBars()
        end if
        setRtnIndex()   -- moved up here 17/05
        chmHotKeyRegistered = setChmHotKey(chmHotKeyRegistered)
-- if anything, this slows it down:
--if not (c_func(xGetQueueStatus, {QS_ALLINPUT}) < #FFFF) then
        if caretBelongsToMain then
            showCaret()
        end if
        for c=1 to length(unpacked) do
            unpacklineno = unpacked[c]
            if unpacklineno!=-1 then
                if isShowBGprogress then
                    setText(SB6,sprintf("unpacking %s %d",{filenames[c],unpacklineno}))
                end if

                unpacklinecount = 0
                setIsEu(filenames[c])
--              if (isEu and (isReplaceTabs or Xtrans)) or isTabWidth!=8 then
                if isTabWidth!=8 or isReplaceTabs or (isEu and Xtrans) then
                    while 1 do
                        if unpacklineno<length(filetext[c]) then
                            unpacklineno += 1
--                          filetext[c][unpacklineno] = PackTabs(filetext[c][unpacklineno],0)
                            filetext[c][unpacklineno] = ConvertTabs(filetext[c][unpacklineno],8,isTabWidth)
                        else
                            unpacked[c] = -1
                            exit
                        end if
                        unpacklinecount += 1
                        if unpacklinecount>2000 then
                            unpacked[c] = unpacklineno
                            exit
                        end if
                    end while
                else
                    unpacked[c] = -1
                end if
                if isShowBGprogress then
                    setText(SB6,"")
                end if
                setIsEu(filenames[currfile])
                alreadyBackGroundProcessing = 0
                IDLETIME = 20
--trace(1)
--sleep(2)
--?1
                return
            end if
        end for
        --
        -- complete wordwrap setup (eg for vertical scrollbar):
        --
        if wrappedWidth!=charsWide then
            for i=1 to length(wrapped) do
                wrapped[i] = 0
            end for
            wrappedWidth = charsWide
        end if
        for c=1 to length(unpacked) do
            if (c=currfile and isWordWrapON)
            or (c!=currfile and c<=length(filecursel) and length(filecursel[c])>=11 and filecursel[c][11]) then
                unpacklineno = wrapped[c]
                if unpacklineno!=-1 then
                    if isShowBGprogress then
                        setText(SB6,sprintf("rewrapping %s %d",{filenames[c],unpacklineno}))
                    end if
                    rebuildWraps(c,1)
                    if isShowBGprogress then
                        setText(SB6,"")
                    end if
                    alreadyBackGroundProcessing = 0
                    IDLETIME = 20
                    return
                end if
            end if
        end for

        goIdle = (CheckCaptured()=0)
        if (goIdle or runFullBackgroundScan)
--      and runBack and isBackGround and isDebug=0 then
        and runBack and isBackGround then
--sleep(2)
--if isShowBGprogress then
--  setText(SB6,sprintf("Bg globals:%d",gMFstate))
--end if

            backGroundProcessing()  -- clears runBack when done
            IDLETIME = 20
--?2
            goIdle = 0
        else
            runBack = 0
            IDLETIME = 250
            --?3
            --?time()
            --          stopIdle()
            --  startIdle(IDLETIME)

            --doEvents(0)
            if not goIdle then
            --  goIdle = 2
                if CheckCapturedTimer and not cctActive then
                    cctActive = 1
                    startTimer(CheckCapturedTimer,Main,750)
                end if
            end if
            --      goIdle = (CheckCaptured()=0)

            goIdle = 1
        end if

        call_proc(r_enableMenuToolBar,{})   -- moved 9/11/2005 (multiple instances)

        if goIdle then

--          if isShowBGprogress then
--              setText(SB6,"")
--          end if

            if checkProj then
                checkProj = 0
                if isVisible(TVprjl) then
                    if resetProject(0) then
                        repaintWindow(TVprjl,False)
                    end if
                end if
            end if

            if updateRecoveryTree then
                if isVisible(TVrecl) then
                    void = sendMessage(TVrecl,WM_KEYDOWN,VK_F5,0)
                    updateRecoveryTree = 0
                end if
            end if

--      setRtnIndex()   -- moved up above 17/5

            if currfile and isEu then
                if resetProject(0) then end if
            end if

            if not F11mode then 
                setScrollBars()
                setRtnIndex()   -- added 5/6/7
            end if

            DBclose()       -- close if open

--if goIdle=2 then
----    sleep(1)
--doEvents(0)
--else
--DEV removed 30/12/13, just ate cpu clocks; no idea why it was ever here...
--          if notHotKeyying() then
                stopIdle()
--          else
--              IDLETIME = 250
--          end if
--end if
        end if
        alreadyBackGroundProcessing = 0
    end if
end procedure
setHandler(IDLE, routine_id("IdleHandler"))

--without trace

procedure destroyCaretAndReleaseMouse()
    caretBelongsToMain = 0
    hideCaret()
    void = c_func(xDestroyCaret,{})
    releaseMouse()
end procedure

--procedure postEnterIdleMsg()
---- repaint stall workaround...
--  void = postMessage(Main, WM_ENTERIDLE, 0,0)
--end procedure

procedure saveRect()
sequence rect
    if isWindowNormal(Main) then
        rect = getWindowRect(Main)
        isWindowPos = rect[1..2]
    end if
end procedure

constant sw = 15    -- scroll width

integer inResizeLoop
        inResizeLoop = 0

procedure newClipRect()
    --
    -- Destroy previous clip region, if any.
    --
    if ClipRgn then
        void = c_func(xDeleteObject,{ClipRgn})
    end if
    -- create the new clipping reigion
    ClipRgn = c_func(xCreateRectRgn,ClipRect)
    -- lastly calculate size in characters.
    charsWide = floor((ClipRect[3]-ClipRect[1])/CharWidth)-F11mode
--DEV:
--  if isDebug then
--      setText(Main,sprintf("Edita: charsWide=%d",charsWide))
--  end if
    linesPerPage = floor((ClipRect[4]-ClipRect[2])/CharHeight)
end procedure

--with trace
procedure recalculateClipRect()--integer updateDisplay)
--
-- resize the TabControl to fill the client area
--
sequence rect
integer vH, vV
--sequence vHV
integer r3x, r3y, r3w, r3h
atom lpRect
atom hwnd
integer toff, voff, moff    -- toolbar, treeview and message area offsets
integer height
    hideCaret()
    if isWindowNormal(Main) then
        rect = getWindowRect(Main)
        isWindowPos = rect[1..2]
--/**/  isWindowRect = sq_sub(rect[3..4],rect[1..2])    --/*    -- Positive
        isWindowRect = rect[3..4] - rect[1..2]          -- RDS --*/
    end if
--  if F11Mode and not inResizeLoop then
    if F11mode then
        newClipRect()
    elsif not isWindowMinimized(Main) and not inResizeLoop then
        inResizeLoop = 1
        while 1 do
            rect = getClientRect(Main)      -- less scroll bars, status line, and menu.
--          vHV = isVisible(HHH)&isVisible(VVV)
            vH = isVisible(HHH)
            vV = isVisible(VVV)
            toff = isToolBarVIS*40
            voff = (isFilePanelVIS!=0)*isFilePanelWidth
            moff = (isMessageVIS!=0)*isMessageHeight
            if isFilePanelVIS then
                void = c_func(xMoveWindow, {tvHwnd, rect[1], rect[2], voff, rect[4]-toff,1})
                void = c_func(xMoveWindow, {tvclsHwnd, voff-24, 4, 20, 20, 1})
                lpRect = allocate_Rect()    -- resuable memory
                void = c_func(xGetClientRect, {tvHwnd, lpRect})             -- get TabControl
                void = c_func(xSendMessage, {tvHwnd, TCM_ADJUSTRECT, 0, lpRect})    -- client area
                r3x = peek4s(lpRect)
                r3y = peek4s(lpRect+4)
                r3w = peek4s(lpRect+8)-r3x
                r3h = peek4s(lpRect+12)-r3y
                void = c_func(xMoveWindow,{getHwnd(TVdirl),r3x,r3y+22,r3w,r3h-24,1})
                void = c_func(xMoveWindow,{getHwnd(TVprjl),r3x,r3y+22,r3w,r3h-44,1})
                void = c_func(xMoveWindow,{getHwnd(TVprjt),r3x,r3y+r3h-20,r3w,20,1})
--              void = c_func(xMoveWindow,{getHwnd(TVrecl),r3x,r3y+22,r3w,r3h-64,1})
                void = c_func(xMoveWindow,{getHwnd(TVrecl),r3x,r3y+22,r3w,r3h-24,1})
--              void = c_func(xMoveWindow,{getHwnd(TVrecdel),r3x+5,r3h-29,50,25,1})
            end if
--          rect += {voff,toff,-voff,-moff-toff}
            rect[1] = rect[1]+voff
            rect[2] = rect[2]+toff
            rect[3] = rect[3]-voff
            rect[4] = rect[4]-moff-toff

            if isMessageVIS then
                hwnd = getHwnd(MA)  --DEV maHwnd?
                void = c_func(xMoveWindow, {hwnd, rect[1], rect[4]+toff, rect[3], moff, 1})
                maRect = getWindowRect(MA)  -- save for eamarea.ew
            end if
            if isVisible(VVV) then
--              rect[3] -= sw   -- 2.4 bug
                rect[3] = rect[3]-sw
            end if
            if isVisible(HHH) then
                hwnd = getHwnd(HHH)
--              rect[4] -= sw   -- 2.4 bug
                rect[4] = rect[4]-sw
                void = c_func(xMoveWindow, {hwnd, rect[1], rect[4]+toff, rect[3], sw, 1})
            end if
            hwnd = getHwnd(TC)
            void = c_func(xMoveWindow, {hwnd, rect[1], rect[2]-toff, rect[3], rect[4], 1})
            --
            -- get the clipping rectangle for TextOut
            --
            lpRect = allocate_Rect()        -- resuable memory
            void = c_func(xGetClientRect, {hwnd, lpRect})           -- get TabControl
            void = c_func(xSendMessage, {hwnd, TCM_ADJUSTRECT, 0, lpRect})  -- client area
--          ClipRect = peek4s({lpRect,4})+{voff,toff+2,voff,toff}       -- clip y by extra 2
            ClipRect = peek4s({lpRect,4})
            ClipRect[1] = ClipRect[1] + voff
            ClipRect[2] = ClipRect[2] + toff+2          -- clip y by extra 2
            ClipRect[3] = ClipRect[3] + voff
            ClipRect[4] = ClipRect[4] + toff 
            if isVisible(VVV) then
                hwnd = getHwnd(VVV)
                height = ClipRect[4]-ClipRect[2]+9
                void = c_func(xMoveWindow, {hwnd,rect[1]+rect[3],ClipRect[2]-5,sw,height,1})
            end if
            newClipRect()
            setScrollBars() -- NB: can change VVV/HHH visibility, hence the loop.
            if vH = isVisible(HHH) then
                if vV = isVisible(VVV) then exit end if
            end if
        end while
-- 2/1/14 completely reworked:
        if rtnList then
            if isVisible(rtnList) then
                rect = getWindowRect(TB)
                r3x = rect[1]
                r3w = rect[3]
                rect = getWindowRect(rtnList)
                r3x = rect[1] - r3x - 1 
                r3w -= rect[1] + 10
                r3h = rect[4]-rect[2]
                hwnd = getHwnd(rtnList)
                void = c_func(xMoveWindow, {hwnd,r3x,6,r3w,r3h,1})
            end if
        end if
--DEV: (no help)
--if isWordWrapON then paintall() end if
        inResizeLoop = 0
--doEvents(0) -- crashes!
--      postEnterIdleMsg()  -- No help!
--      if updateDisplay then IdleHandler() end if
    end if
-- 27/03/2010:
    if finishINI=1 then
-- 12/05/2010:
        finishINI = 2
        loadIniPart2()
        finishINI = 0
    end if
end procedure
--recalculateClipRect() -- initialise charsWide & ClipRect (for WM_SETFOCUS)

constant CaretBitmap = loadImage(initialcurrentdir&"bitmaps\\eacaret.bmp",IMAGE_BITMAP,0)

--procedure recreateCaret()--integer setHotKey)
procedure recreateCaret()--integer setHotKey)
    recalculateClipRect()
    if currfile then
        caretBelongsToMain = 1
--  void = c_func(xSelectClipRgn,{mainDC,ClipRgn})  -- BAD IDEA! (took me 3hrs to find this bug!) 
        void = c_func(xCreateCaret,{mainHwnd,CaretBitmap,2,CharHeight})
    end if
--  if setHotKey then
--      void = 
--  end if
    if chmHotKeyRegistered then
        void = c_func(xUnregisterHotKey,{mainHwnd,1})
--setText(Main,sprintf("unregisterhotkey: %d",void))
        chmHotKeyRegistered = 0
    end if
--16/07/2013:
    if inProemh=0 then
        softSetFocus(Main)
    end if
end procedure

function TVHandler(integer id, integer msg, atom wParam, object lParam)
    if wParam or object(lParam) then end if
--DEV as per toolbarhandler in eamenus, this should be wm_lbuttonup?
    if msg=WM_SETFOCUS then
        if id=TVcls then
            toggleTreeView(0)
        else -- id=TV
            softSetFocus(Main)
        end if
        return {1}
    elsif msg = WM_CONTEXTMENU then
        return {1}
    end if
    return 0
end function
--TVdirl now handled in eadir.ew...
setHandler({TV,TVdir,TVproj,TVrecov,TVcls},routine_id("TVHandler"))

without trace
function MainHandler(integer id, integer msg, atom wParam, object lParam)
    if not find(msg,{WM_NOTIFY,WM_SYSKEYDOWN,WM_SYSKEYUP,
                     WM_SYSCOMMAND,WM_ENTERMENULOOP,WM_CAPTURECHANGED,
                     WM_SETCURSOR,WM_INITMENU,WM_MENUSELECT,WM_CTLCOLORSCROLLBAR}) then
        -- (Nearly drove myself nuts on this one:
        --  p.exe, exw.exe, exwc.exe all worked fine, but pw.exe on windows XP
        --  [which worked fine on windows 98] used 100% cpu time... Yet the
        --  only difference between p.exe and pw.exe is one byte... After four
        --  days of hacking, I finally figured out it was all because I had a
        --  pw.exe.manifest file but no p.exe.manifest file; once I created
        --  the latter it was clearly the cause.)
        -- (Manifests are now embedded in the (all) exe resource sections so 
        --  you should no longer have to worry about them.)
        startIdle(IDLETIME)
    end if
    if id = Main then
        if    msg = WM_PAINT then           paintall()
        elsif msg = WM_SIZE then            recalculateClipRect()
        elsif msg = WM_SETFOCUS then        recreateCaret()
        elsif msg = WM_KILLFOCUS then       destroyCaretAndReleaseMouse()
        elsif msg = WM_CHAR then            return charInput(wParam,Ctrl(),Shift())
        elsif msg = WM_KEYDOWN then         return virtualKey(wParam,Ctrl(),Shift())
        elsif msg = WM_SYSKEYDOWN then      return sysKey(wParam,Ctrl(),Shift())
        elsif msg = WM_SYSCHAR then         return sysChar(wParam,Ctrl(),Shift())
        elsif msg = WM_COPYDATA then        return CDmessage(lParam)
        elsif msg = WM_DROPFILES then       doDrag(wParam)
        elsif isMouseMsg(msg)
           or msg = WM_MOUSEWHEEL then      mouseHandler(msg,wParam,lParam)
        elsif msg = WM_TIMER then           doTimer(wParam)
        elsif msg = WM_MOVE then            saveRect()
        elsif msg = WM_HOTKEY then          chmHotKeyRegistered=HotKeyEsc()
        elsif msg = WM_DISPLAYCHANGE then   recalculateClipRect() paintall()
        elsif msg = WM_MENUSELECT then      return menuHandler(id,msg,wParam,lParam)
        elsif(msg = WM_ENDSESSION and wParam)
           or msg = WM_CLOSE then           return saveAllFilesAndINI()
        elsif msg = WM_QUERYENDSESSION then
            if saveAllFilesAndINI() then    return {0}  end if
        end if
    end if
    return 0
end function
setHandler(Main, routine_id("MainHandler"))
setFocus(Main)

integer recalcClipRect  -- following a Tab Insert or Delete (see below).
        recalcClipRect = False

integer rDownTab
        rDownTab = 0

function handleTABCONTROL(integer id, integer msg, atom wParam, object lParam)
atom struct
integer x,y, rtab, d
    if id or object(lParam) then end if -- suppress warnings
--?{id,msg,wParam,lParam,WM_NOTIFY,TCN_SELCHANGE}
    if msg = WM_NOTIFY and wParam = TCN_SELCHANGE then
        changeTo(find(getIndex(TC),tabs))
    elsif msg = WM_SETFOCUS then
        softSetFocus(Main)
    elsif msg = TCM_INSERTITEMA or msg = TCM_DELETEITEM then
        recalcClipRect = True -- more work required for WM_PAINT.
    elsif msg = WM_PAINT then
        if recalcClipRect then
            destroyCaretAndReleaseMouse()
            recalculateClipRect()
            recreateCaret()--0)
            recalcClipRect = False
        end if
        --
        -- A startup check, for want of anywhere else to put it:
        --
        if atom(isLegacyTcod) then
            EditOptions()
        end if

    elsif msg = WM_RBUTTONDOWN
       or msg = WM_RBUTTONUP
       or msg = WM_LBUTTONUP then
        if atom(lParam) then
            struct = allocate_TextSpace(sizeofstruct(TC_HITTESTINFO))
            x = loWord(lParam)
            y = hiWord(lParam)
            poke4(struct+POINT_x, x)
            poke4(struct+POINT_Y, y)
            rtab = sendMessage(id, TCM_HITTEST, 0, struct) + 1
            struct = allocate_Rect()
            void = sendMessage(id, TCM_GETITEMRECT, rtab-1, struct)
            if msg=WM_RBUTTONDOWN then
                rDownTab = rtab
--              setText(Main,sprintf("Edita : Rdown on %d",rtab))
            elsif msg=WM_LBUTTONUP then -- 01/11/13
                if rCompareTarget then
                    -- if compare open, set target. (copied from changeTo)
                    if call_func(rCompareTarget,{rtab}) then end if
                end if
            elsif rDownTab=rtab then
                tabfile = rtab
                chovinfo = 0
                TrackMenu(1,1,0,0)
            else
--              setText(Main,sprintf("Edita : Rup on %d from %d",{rtab,rDownTab}))
                if x>floor((peek4s(struct)+peek4s(struct+8))/2) then
                    if rtab<rDownTab-1 then
                        rtab += 1
                    end if
                else
                    if rtab>rDownTab+1 then
                        rtab -= 1
                    end if
                end if
                if currfile!=rDownTab and rDownTab!=0 then
                    changeTo(rDownTab)
                end if
--              -- ooops! this does a swap(rtab,currfile) op...
--              shuffleTabs(rtab-currfile)
                if rtab>currfile then
                    shuffleLoop = rtab-currfile
                    d = +1
                else
                    shuffleLoop = currfile-rtab
                    d = -1
                end if
                while shuffleLoop do
                    shuffleLoop -= 1    -- only redraw on last iteration
                    shuffleTabs(d)
                end while
            end if
        end if
    end if
    return 0
end function
TChandler = routine_id("handleTABCONTROL")
setHandler(TC, TChandler)

function handleScrollBars(integer id, integer msg, atom wParam, object lParam)
integer screenY
    if id or object(lParam) then end if -- suppress warnings
    if msg = WM_SETFOCUS then
        softSetFocus(Main)
        return {0}
    elsif id = HHH and msg = WM_HSCROLL then
--setText(Main,sprintf("Edita: WM_HSCROLL, %d",wParam))
        Column = wParam - 1
        paintall()
--      postEnterIdleMsg()
        IdleHandler()
    elsif id = VVV and msg = WM_VSCROLL then
        if isMoveCursorOnScroll then
            startSelection(Shift(),Menu())
            screenY = distanceFromTopLine(CursorY,CursorX)
        end if
        TopLine = adjustLine(0,(wParam-1),0)
        TopChunk = nacX
        if isMoveCursorOnScroll then
--          CursorY = adjustLine(TopLine,screenY,CursorX)
            CursorY = Min(adjustLine(TopLine,screenY,CursorX),length(filetext[currfile])-1)
--                  if CursorY >= length(filetext[currfile])-1 then exit end if
--                  newY = adjustLine(CursorY,+1,CursorX)
--                  if newY<length(filetext[currfile]) then
--                  CursorY = Min(adjustLine(CursorY,+linesPerPage,CursorX),filelen-1)
            CursorX = nacX
        end if
        paintall()
--      postEnterIdleMsg()  -- DEV ineffective...
        IdleHandler()
    end if
    return 0
end function
setHandler({HHH,VVV}, routine_id("handleScrollBars"))

--DEV put this back to iff next release, and kill off(RDSEU-comment out) the thing in eamisc.e, which can go back to being called iff:
WinMain(Main, ifff(isWindowMaximised,SW_MAXIMIZE,SW_NORMAL))

--------------------------------------------------------------
fileopenFree()

