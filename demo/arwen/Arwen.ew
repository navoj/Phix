global constant ARWENVERSION = {
                                "ARWEN Win32 library",  -- name
                                0,                      -- major verion
                                93.21}                  -- minor version (Phix compatible)

global sequence WINDOWS_VERSION_EX  -- see also integer WINDOWS_VERSION defined below

without warning --DEV for eu4.0...

procedure fatalc(string msg)
    printf(1,"arwen is not %s compatible; use pGUI instead\n",{msg})
    {} = wait_key()
    abort(0)
end procedure

if machine_bits()=64 then fatalc("64-bit") end if
if platform()=LINUX then fatalc("linux") end if

-- DISCLAIMER
-- ==========
-- The software and documentation are provided "as is", without any express or
-- implied warranty for any use whatsoever. No warranty is provided that any
-- part of the software and/or documentation is error free. The Author will not in
-- any event be liable for any direct, indirect, special, incidental, consequential
-- or other imaginable damages related to any use, reproduction, modification, or
-- distribution of the software and/or documentation.

--without warning

-- getParentHwnd(): need update?

-- destroy() -- fonts now?
                 -- accelerators?

-- font dialogs..

-- selectDirectory doesn't properly relase some allocator thingie, what to do? Ask Derek? WIn32lib misses this one too..


global object void -- ubiquitous assignee variable

global integer ISMENUOWNERDRAWN  ISMENUOWNERDRAWN=0 -- initially do NOT use OD menus



-- include files (order is important here)
include "misc_arwen.e"
include "message_box.ew" -- stand alone message box dialog
include "constants.ew" -- Win32 constant declarations
include "dll_links.ew" -- Linking to various dll files
include "structures.ew" -- basic structure arrangement
--include "dib256.ew"   -- dib handling (incomplete)
include "Quick_Allocations.ew" -- code to manage pre-allocated memory blocks
include "classes.ew" -- predefined window/control class defaults

global constant

    UNDEFINED = -1,
    IDLE = -2,
    CLIPBOARD = -3


--IDLEON
integer
    PrimaryWindowID,    -- id of the main application window
    isAppStarted,       -- flag to indicate if application has started or not

    IdleTimer,
    IDLEROUTINE,            -- routine id of the procedure to be called during IDLE states
    IDLEON                  -- active only when user wants idle process to run

    PrimaryWindowID = UNDEFINED
    isAppStarted = False

    IdleTimer = UNDEFINED
    IDLEROUTINE = UNDEFINED
    IDLEON = 0


constant

    GETOPENFILENAME = 0,
    GETSAVEFILENAME = 1,
--  GETOPENFILENAMEPREVIEW = 2,

    TRACKBARREQUESTS = {TB_BOTTOM,
                        --TB_ENDTRACK,
                        TB_LINEDOWN,
                        TB_LINEUP,
                        TB_PAGEDOWN,
                        TB_PAGEUP,
                        --TB_THUMBPOSITION,
                        TB_THUMBTRACK,
                        TB_TOP},

    MENUINSERTFLAGS_TYPE = or_all({MFT_RADIOCHECK,
                                   MFT_MENUBARBREAK,
                                   MFT_MENUBREAK}),

    MENUINSERTFLAGS_STATE = or_all({MFS_DISABLED,
                                    MFS_CHECKED,
                                    MFS_ENABLED,
                                    MFS_UNCHECKED,
                                    MF_CHECKED}),

    MULTISELECTIONS = or_bits(LBS_EXTENDEDSEL, LBS_MULTIPLESEL),

    MAXLENGTHGETTABITEMTEXT = 100 -- max length-1 of text that getText() can extract from a TabItem

--  STATUSBARSIZEGRIPWIDTH = c_func(xGetSystemMetrics, {SM_CXVSCROLL})

-- Pen Colors, stolen from Win32lib hehehe...

global function rgb(integer r, integer g, integer b)
    return r + g*256 + b*65536
end function

global constant
    Black           = rgb(  0,   0,   0),
    Blue            = rgb(  0,   0, 128),
    Green           = rgb(  0, 128,   0),
    Cyan            = rgb(  0, 128, 128),
    Red             = rgb(128,   0,   0),
    Orange          = rgb(128,  64,   0),
    Amber           = rgb(255, 160,   0),
    Magenta         = rgb(128,   0, 128),
    DarkBrown       = rgb( 64,  64,   0),
    Brown           = rgb(128, 128,   0),
    DarkGray        = rgb( 64,  64,  64),
    Gray            = rgb(128, 128, 128),
    LightGray       = rgb(192, 192, 192),
    BrightBlue      = rgb(  0,   0, 255),
    BrightGreen     = rgb(  0, 255,   0),
    BrightCyan      = rgb(  0, 255, 255),
    BrightRed       = rgb(255,   0,   0),
    Pink            = rgb(255, 176, 176),
    BrightMagenta   = rgb(255,   0, 255),
    Purple          = rgb(208, 128, 208),
    Yellow          = rgb(255, 255,   0),
    White           = rgb(224, 224, 224),
    Parchment       = rgb(255, 255, 224),
    BrightWhite     = rgb(255, 255, 255)

constant
    MENUCOLOUR_DISABLED = rgb(80,128,144), -- colour of any disabled text

    MENUBRUSH_BORDER    = c_func(xCreateSolidBrush,{MENUCOLOUR_DISABLED}),  -- border of selected menuitem

    MENUBRUSH_ICON      = c_func(xCreateSolidBrush,{rgb(168, 192, 208)}), -- background of icon
    MENUBRUSH_SELECT    = c_func(xCreateSolidBrush,{rgb(200, 216, 224)}), -- background of selected item
    MENUBRUSH_NORMAL    = c_func(xCreateSolidBrush,{rgb(240, 240, 240)}), -- background of non-selected item
    MENUBRUSH_TOPSELECT = c_func(xCreateSolidBrush,{rgb(  0,  96, 192)})    -- background of selected top-level Menu


atom
    WndProcCallBack,    -- 32-bit callback address for WndProc routine
    SubProcCallBack     -- 32-bit callback address for SubProc routine
-- removed 21/05/2010:
--  DlgProcCallBack,    -- 32-bit callback address for DlgProc routine
--  PrgProcCallBack     -- 32-bit callback address for PrgProc routine

sequence
    ObjectClass,        -- integer:     holds the base class for each entity
    ObjectType,         -- integer:     Holds the type of each control defined in classes.ew
    ObjectHwnd,         -- atom:        Hwnd of each control.
    ObjectParent,       -- integer:     Parent id of each object. Is NULL for top-level controls
    ObjectLabel,        -- sequence:    Text label of control, not used for large edit controls
    ObjectImage,        -- atom:        Handle of bitmap associated with the control
    ObjectFont,         -- font handle
    ObjectTextColour,
    ObjectBackColour,
    ObjectExtra,        -- integer:     unique Flags of the control
    ObjectChildren,     -- Object:      unique attributes for controls - details are in AddObject()
    WndProcAddress,     -- atom:            store the (original) WndProc address here
    SubProcAddress,     -- atom:            store the (new) SubProc address here
    HandlerRoutine,     -- integer:     routine id's for each control

    DeletedObjects          -- holds a list of id's of deleted objects, used to recycle id numbers

    ObjectClass = {}
    ObjectType = {}
    ObjectHwnd = {}
    ObjectParent = {}
    ObjectLabel = {}
    ObjectImage = {}
    ObjectFont = {}
    ObjectTextColour = {}
    ObjectBackColour = {}
    ObjectExtra = {}
    ObjectChildren = {}
    WndProcAddress  = {}
    SubProcAddress = {}
    HandlerRoutine = {}

    DeletedObjects = {}



---------------------------------------------------

-- constants for accessing the ObjectExtra[] fields for windows
constant
    MENUBAR     = 1,    -- id of any menu bar attached to this window
    TOOLBAR     = 2,    -- id of any tool bar attached to this window
    STATUSBAR   = 3,    -- id of any status bar attached to this window
    HSCROLL     = 4,    -- id of any horizontal scroll bar
    VSCROLL     = 5,    -- id of any vertical scroll bar

    NUMMANAGEDWINDOWCONTROLS = VSCROLL, -- currently only used in destroy(), move when more controls added

    ACCELKEYS   = 6,
    ACCELIDS    = 7,

    PRIVATEDC   = 8,    -- Private DC of window
    LASTFOCUS   = 9
---------------------------------------------------


function addControl(integer objType, integer parentId, atom hwnd, sequence lbl, atom hBitmap)

integer id, ctrl_class, len

    -- PREPARE NEW ID OF OBJECT
    len = length(DeletedObjects)
    if len then -- get vacant id
        id = DeletedObjects[len] -- pop last item from stack, I think this may be faster
        DeletedObjects = DeletedObjects[1..len-1] -- shorten the stack
    else -- otherwise..
        ObjectClass     &= 0
        ObjectType      &= 0
        ObjectHwnd      &= 0
        ObjectParent    &= 0
        ObjectLabel     =  append(ObjectLabel, "")
        ObjectImage     &= 0
        ObjectFont      &= 0
        ObjectTextColour &= 0
        ObjectBackColour &= 0
        ObjectExtra     &= 0
        ObjectChildren  &= 0
        WndProcAddress &= 0
        SubProcAddress &= 0
        HandlerRoutine &= 0
        id = length(ObjectHwnd)
    end if

    -- get the class of the object
    ctrl_class = getClassBase(objType)

    -- set default values
    ObjectClass     [id] = ctrl_class
    ObjectType      [id] = objType
    ObjectHwnd      [id] = hwnd
    ObjectParent    [id] = parentId
    ObjectLabel     [id] = lbl
    ObjectImage     [id] = hBitmap
    ObjectFont      [id] = 0
    ObjectTextColour[id] = UNDEFINED
    ObjectBackColour[id] = UNDEFINED
    ObjectExtra     [id] = 0
    ObjectChildren  [id] = UNDEFINED
    WndProcAddress [id] = UNDEFINED
    SubProcAddress [id] = UNDEFINED
    HandlerRoutine [id] = UNDEFINED

    -- specify fields for certain objects
    if objType=Window then
        ObjectChildren[id] = {} -- list of ID's of all children controls
        ObjectExtra[id] = {
                           UNDEFINED,       -- ID of any Menu
                           UNDEFINED,       -- ID of any ToolBar
                           UNDEFINED,       -- ID of any StatusBar
                           UNDEFINED,       -- ID of Horizontal scroll bar
                           UNDEFINED,       -- ID of Vertical scroll bar
                           {},              -- sequence of virtual keys for accelerating
                           {},              -- sequence of ids whose handlers will be sent the WM_COMMAND messages
                           UNDEFINED,       -- private dc of window
                           UNDEFINED}       -- last focus of window

    elsif objType=ToolBar then
        ObjectChildren[id] = {} -- id's of all child items
--PL 27/08/13:
--      ObjectExtra[id] = 0 -- this is the extent of the current y boundary
        ObjectExtra[id] = 1 -- this is the extent of the current y boundary

    elsif objType=Group then
        ObjectChildren[id] = {} -- id's of all child items

    elsif ctrl_class=LIST then
        ObjectExtra[id] = 0 -- creation style flags

    elsif objType=ListView then
        ObjectExtra[id] = {0,0,0,-1,1} -- Style,columns,cursel,formatrtn,lastSortCol

    elsif objType=TreeView then
        ObjectExtra[id] = {0,0,0}   -- -,-,hCurItem

    elsif ctrl_class=COMBO then
        ObjectExtra[id] = UNDEFINED -- id of the edit control that is also created

    elsif objType=TabControl then
        ObjectChildren[id] = {} -- id's of all child tab items

    elsif objType=TabItem then
        ObjectChildren[id] = {} -- list of id's of all controls associated with the TabItem
        ObjectExtra[id] = 1  -- the enabled state of the TabItem to emulate enabled/disabled behaviour

    elsif objType=StatusBar then
        ObjectChildren[id] = {} -- list of id's of StatusFields associated with the StatusBar
        ObjectExtra[id] = 0  -- width of StatusBar field

    elsif objType=StatusField then
        ObjectExtra[id] = 0  -- width of status field

    elsif objType=HyperText then
        ObjectExtra[id] = 0 -- PREVCURSOR when mouse hovers over control

    elsif objType=ReBar then
        -- allow menus and toolars to be placed on ReBars (this might want extending for others?)
        ObjectExtra[id] = {
                           UNDEFINED,       -- ID of any Menu
                           UNDEFINED}       -- ID of any ToolBar

    else -- All other controls
        -- ObjectChildren[id] = UNDEFINED

    end if

    return id

end function

-- PL 30/12/13:
Screen = addControl(Virtual, 0, 0, "", 0)

procedure eraseControl(integer id)
integer parent, objType

--PL 31/07/2013:
if id=UNDEFINED then ?9/0 end if
    -- determine if parent is a Window
    parent = ObjectParent[id]
    if parent and ObjectType[parent]!=Window then
        parent = 0
    end if

    -- get control type
    objType = ObjectType[id]

    -- remove any links to any parent window
    if parent then

        if objType=Window then -- child window, don't know what to do about this yet

        elsif objType=Menu then
            ObjectExtra[parent][MENUBAR] = UNDEFINED

        elsif objType=ToolBar then
            ObjectExtra[parent][TOOLBAR] = UNDEFINED

        elsif objType=StatusBar then
            ObjectExtra[parent][STATUSBAR] = UNDEFINED

        elsif objType=HScroll then
            ObjectExtra[parent][HSCROLL] = UNDEFINED

        elsif objType=VScroll then
            ObjectExtra[parent][VSCROLL] = UNDEFINED

        end if
        if ObjectExtra[parent][LASTFOCUS]=id then
            ObjectExtra[parent][LASTFOCUS] = UNDEFINED
        end if

    end if

    -- wipe all control info fields clean
    ObjectClass[id]     = UNDEFINED
    ObjectType[id]      = UNDEFINED
    ObjectParent[id]    = UNDEFINED
    ObjectHwnd[id]      = UNDEFINED
    ObjectLabel[id]     = UNDEFINED
    ObjectImage[id]     = UNDEFINED
    ObjectFont[id]      = UNDEFINED
    ObjectExtra[id]     = 0
    ObjectChildren[id]  = UNDEFINED
    WndProcAddress[id]  = UNDEFINED
    SubProcAddress[id]  = UNDEFINED
    HandlerRoutine[id]  = UNDEFINED

    -- store the unused id for later recycling
--trace(1)
    DeletedObjects &= id

end procedure


--function hasChildren(integer id)
--object children
--  children = ObjectChildren[id]
--  if sequence(children) then
--      if length(children) then
--          return 1
--      end if
--  end if
--  return 0
--end function

global function getChildren(integer id)
    return ObjectChildren[id]
end function

global function getChildHwndFromPoint(integer id)
     -- initially for combo boxes so I could subclass edit control but it don't seem to work!!!
atom hWnd, lpPOINT
    lpPOINT = allocate_Point()
--  for i=1 to 1000 do
    poke4(lpPOINT, {-1,-1})
    hWnd = c_func(xChildWindowFromPoint, {ObjectHwnd[id], lpPOINT})
    puts(1,"getChildHwndFromPoint\n")
    ? hWnd
--  end if
--  end for
    return 0--hWnd
end function

----------------------------------------------------------------------------
global function getHwnd(integer id)
    return ObjectHwnd[id]
end function

global function getObjectType(integer id)
    return ObjectType[id]
end function

global function getParentHwnd(integer id)
    id = ObjectParent[id]
    if id then
-- PL 22/07/2013:
--      return ObjectHwnd[id]
        if ObjectType[id]=TabItem then
            id = ObjectParent[id]
        end if
        return ObjectHwnd[id]
    end if
    return NULL
end function


global function getWindowHwnd(integer id)
    if ObjectType[id]=Window then
        return ObjectHwnd[id]
    elsif ObjectParent[id]=UNDEFINED then
        return NULL
    end if
    return getWindowHwnd(ObjectParent[id])
end function


global function getParentWindow(integer id)
integer pID
    if id then
        if ObjectType[id]=Window then
            return id
        end if
        pID = ObjectParent[id]
        if pID then
            return getParentWindow(pID)
        end if
    end if
    return 0
end function

global function isChildOf(integer pID, integer id)
    while 1 do
        if id=pID then return True end if
        if id=0 or ObjectType[id]=Window then return False end if
        id = ObjectParent[id]
    end while
end function

function isTopLevelMenu(integer id)
-- if the menu is on the top-level then will return the handle of the owner window else returns 0
integer pID
    pID = ObjectParent[id]
    if pID then
        pID = ObjectParent[pID]
        if pID and ObjectType[pID]=Window then
            return ObjectHwnd[pID]
        end if
    end if
    return 0
end function


function getMenuElementPosZ(integer id)
-- Find the position of a (sub) Menu or MenuItem within it's parent Menu.
-- The number return is 0-based. If an error occurs or there are no elements
-- then -1 is returned.

atom hMenu, hPopup
integer mcount

    -- check id is valid or that valid parent exists
    if ObjectClass[id]!=MENU or not ObjectParent[id] then
        return -1
    end if

    -- get the owner handle
    hMenu = getParentHwnd(id)

    -- get the count of items in the menu
    mcount = c_func(xGetMenuItemCount,{hMenu}) -- 1-based number
    if mcount<1 then -- error or no elements
        return -1
    end if


    -- loop through each item to see if it is correct one
    if ObjectType[id]=Menu then -- Menu
        hPopup = ObjectHwnd[id]
        for index=0 to mcount-1 do
            if c_func(xGetSubMenu,{hMenu,index})=hPopup then
                return index
            end if
        end for


    else -- must be MenuItem
        for index=0 to mcount-1 do
            if c_func(xGetMenuItemID,{hMenu,index})=id then
                return index
            end if
        end for


    end if

    return -1

end function


procedure drawMenuBar(integer id)
    -- if the id is a top-level menu then the menubar will be redrawn
atom hWnd
    hWnd = isTopLevelMenu(id)
    if hWnd then
        void = c_func(xDrawMenuBar,{hWnd})
    end if
end procedure


global function getLastError()
    return c_func(xGetLastError,{})
end function

global procedure reparentControl(integer id, integer newPID)
-- move control onto a new Parent.
-- newPID should be a Window, TabItem, or Group, or
-- possibly a ToolBar, StatusBar, or even a raw TabControl,
-- but if it is eg a label, you'll get a crash.
integer oldPID,     -- the old Parent.
        k
sequence children
integer cType
    cType = ObjectClass[id]
    if find(cType,{MENU}) then
        k = c_func(xSetParent,{ObjectHwnd[id],ObjectHwnd[newPID]})
    else
        oldPID = ObjectParent[id]
        --
        -- Remove id from old parent's child list and add to new:
        --
        if oldPID then
            children = ObjectChildren[oldPID]   -- see comment above
            k = find(id,children)               -- k should not be 0!
            children = children[1..k-1]&children[k+1..length(children)]
            ObjectChildren[oldPID] = children
        end if
        if newPID then
            ObjectChildren[newPID] &= id

            ObjectParent[id] = newPID
            --
            -- Set new parent hwnd and check the old one was as expected.
            --
            if oldPID and ObjectType[oldPID]=TabItem then
                oldPID = ObjectParent[oldPID]
            end if
            if ObjectType[newPID]=TabItem then
                newPID = ObjectParent[newPID]
            end if
            k = c_func(xSetParent,{ObjectHwnd[id],ObjectHwnd[newPID]})
        else
            ObjectParent[id] = 0
            k = c_func(xSetParent,{ObjectHwnd[id],NULL})
        end if
        --DEV ugh, cannot stop this crashing...
        --  if oldPID and ObjectHwnd[oldPID]!=k then ?9/0 end if
    end if

end procedure

function getStatusFieldIndex(integer id)
    -- get 0-based index of StatusField within StatusBar.
    -- Believe it or not no 1 adj is done since index 0 refers to the PARENT control. Woohoo!
    return find(id, ObjectChildren[ObjectParent[id]])
end function

function getID(atom hwnd)
    return c_func(xGetWindowLong,{hwnd,GWL_USERDATA})
end function

procedure setID(atom hwnd, integer id)
    void = c_func(xSetWindowLong,{hwnd,GWL_USERDATA,id})
end procedure




----------------------------------------------------------------------------

-- The SendMessage function sends the specified message to a window or windows.
-- The function calls the window procedure for the specified window and does not
-- return until the window procedure has processed the message. The PostMessage
-- function, in contrast, posts a message to a thread's message queue and returns
-- immediately.

global function postMessage(integer id, atom cmd, atom wParm, atom lParm)
    -- send a command to a control
    return c_func(xPostMessage,{ObjectHwnd[id],cmd,wParm,lParm})
end function


--
-- send a message to a Win32 object, usually a control
global function sendMessage(integer id, atom cmd, object wParam, object lParam)
atom result

    -- need to allocate any memory for wParam?
    if sequence(wParam) then
        wParam = allocate_StringZ(wParam)
    end if

    -- need to allocate any memory for lParam?
    if sequence(lParam) then
        lParam = allocate_StringZ(lParam)
    end if

    -- actually send the message
    result = c_func(xSendMessage,{ObjectHwnd[id],cmd,wParam,lParam})
    -- exit
    return result
end function



atom lpMSG
   lpMSG = allocate(sizeofstruct(MSG))


global function peekMessage(integer hwnd, integer wMsgFilterMin, integer wMsgFilterMax, integer wRemoveMsg)

integer isMsg
atom msg, wParam, lParam

-- wRemoveMsg can be:
--      PM_NOREMOVE = 0,
--      PM_REMOVE = 1,
--     [PM_NOYIELD = 2,]

    isMsg = c_func(xPeekMessage,{lpMSG,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg})

    if isMsg then

        msg     = peek4u(lpMSG + MSG_message)
        wParam  = peek4u(lpMSG + MSG_wParam)
        lParam  = peek4u(lpMSG + MSG_lParam)

        return {msg, wParam, lParam}

    end if

    return 0

end function


global function getPrivateDC(integer id)
    if ObjectType[id]=Window then
        return ObjectExtra[id][PRIVATEDC]
    end if
    return 0
end function

global function getDC(integer id)
    return c_func(xGetDC,{ObjectHwnd[id]})
end function


global procedure releaseDC(integer id, atom hDC)
    void = c_func(xReleaseDC,{ObjectHwnd[id],hDC})
end procedure


function getObject(atom hgdiobj, integer cbBuffer, atom lpvObject)
--    HGDIOBJ hgdiobj,  // handle to graphics object of interest
--    int cbBuffer, // size of buffer for object information
--    LPVOID lpvObject  // pointer to buffer for object information
    return c_func(xGetObject,{hgdiobj,cbBuffer,lpvObject})
end function


global function deleteObject(atom hObject)
    return c_func(xDeleteObject,{hObject})
end function

global function selectObject(atom hdc, atom hGdiObj)
    return c_func(xSelectObject,{hdc,hGdiObj})
end function

global function createCompatibleBitmap(integer id, integer width, integer height)
atom hDC, hBitmap

    hDC = getDC(id)
    hBitmap = c_func(xCreateCompatibleBitmap, {hDC, width, height})
--  void = c_func(xSelectObject,{hDC,hBitmap})
    releaseDC(id, hDC)

    return hBitmap

end function

-------------------------------------
-- DISK FILE/PATH MANAGEMENT ROUTINES
-------------------------------------
global function getEnvPaths(object env_variable)
sequence path, paths
integer start, finish, len

    env_variable = getenv(env_variable)
    if integer(env_variable) then
        return {}
    end if

    len = length(env_variable)
    start = 1
    paths = {}

    while start<=len do
        finish = find(';', env_variable[start..len])
        if finish then
            finish += start - 2
        else
            finish = len
        end if
        path = env_variable[start..finish]
        start = finish+2
        if length(path) then
            paths = append(paths, path)
        end if
    end while

    return paths

end function


global function extractPathAndName(sequence pathname)
-- extract path & name information from complete pathname
sequence path, name
integer len, pos

    len = length(pathname)
    pos = 0

    for i=len to 1 by -1 do
        if pathname[i]='\\' then -- delimiter found, must always exist
            pos = i
            exit
        end if
    end for

    path = pathname[1..pos]
    name = pathname[pos+1..len]

    return {path, name}
end function



global function extractNameAndExtn(sequence pathfile)
-- extract name and extension from complete filename
sequence name, extn

    name = pathfile
    extn = ""

    for i=length(pathfile) to 1 by -1 do
        if pathfile[i]='.' then
            name = pathfile[1..i-1]
            extn = pathfile[i+1..length(pathfile)]
            exit
        end if
    end for

    return {name, extn}
end function


global function createDirectory(sequence path)
atom lpPath
integer result
    lpPath = allocate_StringZ(path)
    result = c_func(xCreateDirectory, {lpPath, NULL})
    return result
end function


constant BFFM_INITIALIZED=1,
         BFFM_SETSELECTION=#466

function BFFMcallback(atom hWnd, atom msg, atom lParam, atom lpData)
    if msg=BFFM_INITIALIZED then
        if lParam then end if   -- suppress warnings
        void = c_func(xSendMessage, {hWnd, BFFM_SETSELECTION, 1, lpData})
    end if
    return 0
end function
constant BBFM_cb=call_back(routine_id("BFFMcallback"))

global function selectDirectory(integer id, object title, object sDir)--, object flags)--, atom callback, atom cbData)
-- PL 23/10/07 id and sDir added.
--  id is the parent window, pass 0 for PrimaryWindowID (as previously).
--  sDir is the start dir, pass NULL to start in root (as previously).

atom lpBI, lpTitle, lpDirName, pIIL
sequence folder

    -- prepare window title message
    if not sequence(title) then
        title = "Select folder.."
    end if
    lpTitle = allocate_StringZ(title)

    lpDirName = allocate(MAX_PATH)

    -- allocate & populate the BROWSEINFO structure
    lpBI = allocate(sizeofstruct(BROWSEINFO))
    if id=0 then
        id = PrimaryWindowID
    end if
    poke4(lpBI+BI_hwndOwner,        ObjectHwnd[id])
    poke4(lpBI+BI_pidlRoot,         NULL)
    poke4(lpBI+BI_pszDisplayName,   lpDirName)
    poke4(lpBI+BI_lpszTitle,        lpTitle)
    poke4(lpBI+BI_ulFlags,          BIF_RETURNFSANCESTORS + BIF_RETURNONLYFSDIRS + BIF_EDITBOX)
    if sequence(sDir) and length(sDir) then
        poke4(lpBI+BI_lpfn,         BBFM_cb)
        poke4(lpBI+BI_lParam,       allocate_StringZ(sDir))
    else
        poke4(lpBI+BI_lpfn,         0)
        poke4(lpBI+BI_lParam,       0)
    end if
    poke4(lpBI+BI_iImage,       0)

    pIIL = c_func(xSHBrowseForFolder, {lpBI})

    if pIIL then
        if c_func(xSHGetPathFromIDList,{pIIL,lpDirName}) then
            folder = peek_string(lpDirName)
        end if
--PL: http://www.mvps.org/vcfaq/sdk/20.htm
        --folder = getPathFromIDList(pIIL,lpDirName)
        --xSHGetMalloc - what to do here?
        --free(pIIL), this can't be right...
    else
        folder = ""
    end if

    free(lpBI)
    free(lpDirName)

    return folder

end function
--How do I display a Choose Directory dialog, instead of a Choose File dialog?
--
--/* Works only if we're Windows 95 capable */
--if (afxData.bWin4)
--{
--    LPMALLOC pMalloc;
--    /* Gets the Shell's default allocator */
--    if (::SHGetMalloc(&pMalloc) == NOERROR)
--    {
--        BROWSEINFO bi;
--        char pszBuffer[MAX_PATH];
--        LPITEMIDLIST pidl;
--        // Get help on BROWSEINFO struct - it's got all the bit settings.
--        bi.hwndOwner = GetSafeHwnd();
--        bi.pidlRoot = NULL;
--        bi.pszDisplayName = pszBuffer;
--        bi.lpszTitle = _T("Select a Starting Directory");
--        bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
--        bi.lpfn = NULL;
--        bi.lParam = 0;
--        // This next call issues the dialog box.
--        if ((pidl = ::SHBrowseForFolder(&bi))!=NULL)
--        {
--            if (::SHGetPathFromIDList(pidl, pszBuffer))
--            {
--            // At this point pszBuffer contains the selected path */.
--                DoingSomethingUseful(pszBuffer);
--            }
--            // Free the PIDL allocated by SHBrowseForFolder.
--            pMalloc->Free(pidl);
--        }
--        // Release the shell's allocator.
--        pMalloc->Release();
--    }
--}

global function getAppDir()
-- Returns the directory that the executable program is residing in.
-- Does *not* return the Phix/Euphoria interpreter path.
sequence s
    s = command_line()
    s = extractPathAndName(s[2])
    return s[1]
end function

global function getEuDir()
object environment
    environment = getenv("EUDIR")
    if integer(environment) then -- what happened? could not find Eu directory
        environment = "C:\\Windows\\"
    else
        environment &= '\\'
    end if
    return environment
end function


function getOSDir(atom cfunc)
    -- get the path of the particular Windows OS directory
    -- the function will return "" on failure OR the path with trailing backslash
atom lpBuffer
integer len, buf_size
sequence dirSet     --PL changed from dir 28/9/2005

    -- initialize buffer size
    buf_size = MAX_PATH

    while 1 do

        -- allocate space for text + NULL
        lpBuffer = allocate(buf_size + 1)

        -- call function
        len = c_func(cfunc, {lpBuffer, buf_size})

        -- exit if buffer was large enough
        if len<=buf_size then
            dirSet = peek({lpBuffer,len})
            free(lpBuffer)
            exit
        end if

        -- .. otherwise increase size of buffer and try again
        free(lpBuffer)
        buf_size += 200

    end while

    -- ensure trailing back slash always exists
    if length(dirSet) and dirSet[length(dirSet)]!='\\' then
        dirSet &= '\\'
    end if

    -- exit
    return dirSet

end function

global function getWinDir() -- get the Windows dir
    return getOSDir(xGetWindowsDirectory)
end function

global function getSysDir() -- get the Windows SYSTEM dir
    return getOSDir(xGetSystemDirectory)
end function

constant windescs = {WIN_3_1,       "WIN_3_1",
                     WIN_95,        "WIN_95",
                     WIN_95_OSR2,   "WIN_95_OSR2",
                     WIN_98,        "WIN_98",
                     WIN_98SE,      "WIN_98SE",
                     WIN_ME,        "WIN_ME",
                     WIN_NT_3_51,   "WIN_NT_3_51",
                     WIN_NT_4,      "WIN_NT_4",
                     WIN_2000,      "WIN_2000",
                     WIN_XP,        "WIN_XP",
                     WIN_UNKNOWN,   "WIN_UNKNOWN"}

integer win_type
global function getWinVersion()
integer len
atom OSV, lResp
integer major_version, minor_version, build_number, platform_id, servicepack_major
sequence vString, lResult

        len = sizeofstruct(OSVERSION)
        OSV = allocate_TextSpace(len)
        mem_set(OSV,0,len)
        poke4(OSV+OSV_dwSize,len)
        lResp = c_func(xGetVersionEx, {OSV})
        if lResp=0 then
            poke4(OSV+OSV_dwSize,OSV_wServicePackMajor)
            lResp = c_func(xGetVersionEx, {OSV})
        end if
        major_version = peek4s(OSV+OSV_dwMajorVersion)
        minor_version = peek4s(OSV+OSV_dwMinorVersion)
        build_number = peek4s(OSV+OSV_dwBuildNumber)
        platform_id = peek4s(OSV+OSV_dwPlatformId)
        vString = peek_string(OSV+OSV_szCSDVersion)
        servicepack_major = peek2s(OSV+OSV_wServicePackMajor)
        if platform_id=0 then               -- VER_PLATFORM_WIN32s  Win32s on Windows 3.1 
            win_type = WIN_3_1
        elsif platform_id=1 then            -- VER_PLATFORM_WIN32_WINDOWS      Win32 on Windows 95
            if minor_version=0 then
                if equal(vString, " C") then
                    win_type = WIN_95_OSR2
                else
                    win_type = WIN_95
                end if

            elsif minor_version=10 then
                if equal(vString, " A") then
                    win_type = WIN_98SE
                else
                    win_type = WIN_98
                end if
            else
                win_type = WIN_ME
            end if
            build_number = and_bits(#FFFF, build_number)
        else                                -- VER_PLATFORM_WIN32_NT   Windows NT 
            if minor_version=51 then
                win_type = WIN_NT_3_51
            elsif minor_version=0 then
                if major_version=4 then
                    win_type = WIN_NT_4
                else
                    win_type = WIN_2000
                end if
            elsif minor_version=1 then
                win_type = WIN_XP
            else
                win_type = WIN_UNKNOWN
            end if
        end if
        lResult = {win_type,
                   {windescs[find(win_type,windescs)+1],vString},
                   build_number}
        if servicepack_major then
            lResult &= {servicepack_major,
                        peek2s(OSV+OSV_wServicePackMinor),
                        peek2s(OSV+OSV_wSuiteMask),
                        peek(OSV+OSV_wProductType)}
        end if

--      free(OSV)
        return lResult
end function
WINDOWS_VERSION_EX = getWinVersion()
global constant WINDOWS_VERSION = win_type

global function copyFile(sequence srcFile, sequence destFile, integer AbortOnOverwrite)
atom lpExist, lpDest
integer result

    lpExist = allocate_StringZ(srcFile)
    lpDest = allocate_StringZ(destFile)

    result = c_func(xCopyFile, {lpExist, lpDest, AbortOnOverwrite})

    return result

end function

function buildDefaultOFN(atom pHwnd, sequence fName, sequence filters, atom flags, atom hookProc)
-- build the ofn structure used by open and save file

    -- filters is a sequence of paired strings in this form:
    -- {displayStr1, patternStr1, displayStr2, patternStr2...}

    -- eg, {"Text Files", "*.TXT", ... }

    -- To specify multiple filter patterns for a single display string, use a
    -- semicolon to separate the patterns, eg:  "*.TXT;*.DOC;*.BAK"


atom ofn, lpstrFilter, lpstrFile
sequence filterList

    -- set up default flags.
    flags = or_all({flags,                  -- from caller
                    OFN_EXPLORER,           -- looks like windows explorer
--                   OFN_ENABLEHOOK, Pete Lomax 31.1.05 : allows resizable open dialogue (the hook is NULL anyway)
                    OFN_LONGNAMES,          -- use long filenames
                    OFN_PATHMUSTEXIST}) -- path must exist

    -- Allocate the structure
    ofn = allocate(sizeofstruct(OPENFILENAME))

    -- build a sequential filter list of null terminated strings
    lpstrFilter = NULL -- default to no filters initially
    if length(filters) then
        filterList = {}
        for i=1 to length(filters) do
            filterList &= filters[i] & NULL
        end for
        lpstrFilter = allocate_StringZ(filterList)
    end if

    -- allocate space for default file name: allot an (at minimum) 256 byte buffer
    if length(fName) and fName[length(fName)]='\\'  then
        -- PL 22/10/07 use of filters[2] not *.* seems to help... (on GETOPENFILENAME anyway)
        if length(filters) then
            fName &= filters[2]
        else
            fName &= "*.*"
        end if
    end if
    fName &= 0 & repeat(' ',256)
    lpstrFile = allocate_StringZ(fName)

    -- populate the structure
    poke4(ofn + OFN_lStructSize,sizeofstruct(OPENFILENAME)) -- size of the structure
    poke4(ofn + OFN_hwndOwner,          pHwnd)          -- parent hWnd
    poke4(ofn + OFN_hInstance,          NULL)           -- handle of dialog box template. not used
    poke4(ofn + OFN_lpstrFilter,        lpstrFilter)    -- paired strings of filter desc. & patterns
    poke4(ofn + OFN_lpstrCustomFilter,  NULL)
    poke4(ofn + OFN_nMaxCustFilter,     NULL)
    poke4(ofn + OFN_nFilterIndex,       1)                  -- index of filter to default to at start
    poke4(ofn + OFN_lpstrFile,          lpstrFile)
    poke4(ofn + OFN_nMaxFile,           256)                -- max buffer size pointed to by OFN_lpstrFile
    poke4(ofn + OFN_lpstrFileTitle,     NULL)
    poke4(ofn + OFN_nMaxFileTitle,      NULL)
    poke4(ofn + OFN_lpstrInitialDir,    NULL)
    poke4(ofn + OFN_lpstrTitle,         NULL)
    poke4(ofn + OFN_Flags,              flags)
    poke2(ofn + OFN_nFileOffset,        NULL)
    poke2(ofn + OFN_nFileExtension,     NULL)
    poke4(ofn + OFN_lpstrDefExt,        NULL)           -- default string extension is user omitted one
    poke4(ofn + OFN_lCustData,          NULL)           -- custom data is using a Hook procedure
    poke4(ofn + OFN_lpfnHook,           hookProc)       -- (ignored unless OFN_ENABLEHOOK is set)
    poke4(ofn + OFN_lpTemplateName,     NULL)

    return {ofn, lpstrFilter, lpstrFile}
end function

constant usegosDir=1
integer gosDirValid
        gosDirValid=0
sequence gosDir -- get open/save directory
                -- Allows getOpenFileName/getSaveFileName() to "resume where I left off last time",
                --  rather than always starting in C:\My Documents And Settings\..., or always in 
                --  C:\Program Files\..., etc, while at the same time leaving eg open("xxx.config") 
                --  unaffected and any ex.err in a predictable place.
--/*
include ..\..\builtins\file.e -- current_dir()
--*/

function DIALOG_FileName(integer dialog, integer id, sequence fName, sequence filters, atom flags, atom hookProc)
object result
atom ofn, lpstrFilter, lpstrFile, pHwnd
sequence sDir

if usegosDir then   -- 3/3/10:
    sDir = current_dir() -- so that eg open("xxx.config") is unaffected by all this,
    if gosDirValid       -- and that getOpen/SaveFileName starts where expected.
    and length(fName)=0 then -- gosDir only has any effect in this case.
        if not chdir(gosDir) then ?9/0 end if
    end if
end if

    -- make the OFN structure
    if id then
        pHwnd = ObjectHwnd[id]
    else
        pHwnd = NULL
    end if
    result = buildDefaultOFN(pHwnd, fName, filters, flags, hookProc)

    -- capture the allocated block pointers
    ofn         = result[1]
    lpstrFilter = result[2]
    lpstrFile   = result[3]

    -- call the correct routine
    if dialog=GETOPENFILENAME then
        result = c_func(xGetOpenFileName, {ofn})

    elsif dialog=GETSAVEFILENAME then
        result = c_func(xGetSaveFileName, {ofn})

--  elsif dialog=GETOPENFILENAMEPREVIEW then
--      result = c_func(xGetOpenFileNamePreview, {ofn})

    end if

    -- retrieve the names
    if result then

        -- were several file names selected? getSaveFileName has this flag removed beforehand
        if and_bits(flags, OFN_ALLOWMULTISELECT) then
            result = peek_string_zz(lpstrFile)

        -- must be single file
        else
            result = {peek_string(lpstrFile)}

        end if

    end if

    free(ofn)
--  if lpstrFilter then free(lpstrFilter) end if
--  free(lpstrFile)

if usegosDir then   -- 3/3/10:
    gosDir = current_dir()
    if equal(sDir,gosDir) then
        gosDirValid = 0
    else
        gosDirValid = 1
        if not chdir(sDir) then ?9/0 end if
    end if
end if

    return result

end function


--DEV incompatible with Eu2.4...
--/**/global function getOpenFileName(integer id, sequence fName, sequence filters, atom flags, atom hookProc=NULL)
--/*
global function getOpenFileName(integer id, sequence fName, sequence filters, atom flags, atom hookProc)
--*/
    return DIALOG_FileName(GETOPENFILENAME,id,fName,filters,flags,hookProc)
end function

--NO HELP...
--global function getOpenFileNamePreview(integer id, sequence fName, sequence filters, atom flags, atom hookProc=NULL)
--  return DIALOG_FileName(GETOPENFILENAMEPREVIEW,id,fName,filters,flags,hookProc)
--end function


--/**/global function getSaveFileName(integer id, sequence fName, sequence filters, atom flags, atom hookProc=NULL)
--/*
global function getSaveFileName(integer id, sequence fName, sequence filters, atom flags, atom hookProc)
--*/
    -- insist that multiple name selection is NOT possible with "Save as' dialog
    if and_bits(flags, OFN_ALLOWMULTISELECT) then
        flags = xor_bits(flags, OFN_ALLOWMULTISELECT)
    end if
    return DIALOG_FileName(GETSAVEFILENAME,id,fName,filters,flags,hookProc)
end function

global function getChooseColour(integer id, integer defaultColour, integer flags)
atom hwnd
integer size, res
atom lpCustom, lpCC

    -- get the window owner
    if id then
        if ObjectType[id]!=Window then
            WarnErr("ID sent to getChooseColor() must be a window")
            return NULL
        end if
        hwnd = ObjectHwnd[id]
    else
        hwnd = 0
    end if

    size = 16 * sizeofstruct(RGBQUAD)
    lpCustom = allocate(size)
    mem_set(lpCustom, #FF, size)    -- NULL-populate Custom colors array
    -- allocate & populate the CHOOSECOLOR structure
    size = sizeofstruct(CHOOSECOLOR)
    lpCC = allocate(size)
    poke4(lpCC + CC_lStructSize, size)
    poke4(lpCC + CC_lpCustColors, lpCustom)
    poke4(lpCC + CC_hwndOwner, hwnd)
--  poke4(lpCC + CC_hInstance, size)
    poke4(lpCC + CC_rgbResult, defaultColour)
    poke4(lpCC + CC_Flags, flags)       -- CC_RFS=CC_RGBINIT+CC_FULLOPEN+CC_SOLIDCOLOR
--  poke4(lpCC + CC_lCustData, size)

    res = defaultColour
    -- open the dialog
    if c_func(xChooseColor, {lpCC}) then
        res = peek4u(lpCC + CC_rgbResult)
    end if
    free(lpCustom)
    free(lpCC)
    return res
end function

global function shellExecute(atom hwnd, sequence op, sequence file, object lpParams, object lpDir, integer nShowCmd)
atom lpOperation, lpFile

    lpOperation = allocate_StringZ(op)
    lpFile = allocate_StringZ(file)
    if sequence(lpParams) then
        lpParams = allocate_StringZ(lpParams)
    else
        lpParams = NULL
    end if
    if sequence(lpDir) then
        lpDir = allocate_StringZ(lpDir)
    else
        lpDir = NULL
    end if

    return c_func(xShellExecute, {hwnd, lpOperation, lpFile, lpParams, lpDir, nShowCmd})
end function

global function openDocument(sequence target)
    return shellExecute(NULL, "open", target, NULL, NULL, SW_SHOWNORMAL)
end function
----------------------------------------------------------------------------

global function loadCursor(object fName)
    -- load single cursor
    -- if fName is filename only then will search for it in the application directory
    -- if fName is integer then will load stock cur resource
atom lpszName
atom hCur

    -- deal to internal resource
    if integer(fName) then
        return c_func(xLoadCursor, {NULL, fName})
    end if

    -- load from a file
    if not find('\\', fName) then -- assume filename passed only
        fName = getAppDir() & fName
    end if
    lpszName = allocate_StringZ(fName)
    hCur = c_func(xLoadCursorFromFile,{lpszName})

    -- ensure valid cursor obtained
    if hCur=NULL then
        hCur = IDC_ARROW -- std shape
    end if

    return hCur

end function


global function getCursor()
    -- get the handle of the current cursor associated with the mouse pointer
    return c_func(xGetCursor,{})
end function

global function setCursor(atom hCur)
    -- associates a new cursor with the mouse pointer
    return c_func(xSetCursor,{hCur})
end function

global function setClassCursor(integer id, atom hCur)
    return c_func(xSetClassLong,{getHwnd(id),GCL_HCURSOR,hCur})
end function

global function loadIcon(object icon)
    atom psz_icon, hIcon
-- get the handle of an icon : from an ico file, the icon bound to the executable OR a standard icon

--  IDI_APPLICATION = 32512, -- icon signifying plain window
--  IDI_HAND                = 32513, -- red circle with stocky x inside - fatal error
--  IDI_QUESTION        = 32514, -- Speech bubble with ? inside
--  IDI_EXCLAMATION = 32515, -- Yellow triangle with ! inside
--  IDI_ASTERISK        = 32516, -- Speech bubble with i inside
--  IDI_WINLOGO         = 32517, -- windows logo

    -- load icon from disk
    if sequence(icon) then
        if not find('\\', icon) then -- assume filename passed only
            icon = getAppDir() & icon
        end if
--      psz_icon = allocate_string(icon)
        psz_icon = allocate_StringZ(icon)
        hIcon = c_func(xExtractIcon, {NULL, psz_icon, 0})
--      free(psz_icon)

    -- load icon associated with executable
    elsif not icon then
--      psz_icon = allocate_string("exw")
        psz_icon = allocate_StringZ("exw")
        hIcon = c_func(xLoadIcon, {instance(), psz_icon})
--      free(psz_icon)

    -- load standard (built-in) icon
    else
        hIcon = c_func(xLoadIcon, {NULL, icon})
    end if

    return hIcon

end function

global function extractIcon(sequence Filename, integer iIdx, integer iSize)
--
-- iIdx is an (optional) 1-based index of which icon to extract
-- iSize is 0 for small, 1 for large, both of which return an atom,
--       or 2 for both, in which case {small,large} is returned.
-- You must manually destroy all icons returned from this function 
--  using DestroyIcon, eg:
--      atom hIcon = extractIcon("C:\\Program Files\\Phix\\p.exe",1,0)
--      constant IDI3 = addIcon(hIcon)
--      hIcon = c_func(xDestroyIcon,{hIcon})
--
object icon
atom lBuffer

    iIdx -= 1
    if iSize = 2 then
        lBuffer = allocate(8)
        void = c_func(xExtractIconEx, {Filename, iIdx, lBuffer, lBuffer+4, 1})
        icon = peek4u({lBuffer,2})
    else
        lBuffer = allocate(4)
        if iSize = 0 then   -- small
            void = c_func(xExtractIconEx, {Filename, iIdx, NULL, lBuffer, 1})
        else                -- large
            void = c_func(xExtractIconEx, {Filename, iIdx, lBuffer, NULL, 1})
        end if
        icon = peek4u(lBuffer)
    end if

    free(lBuffer)
    return icon
end function

atom hILsmall
    hILsmall = 0

global function addIcon(atom hIcon)
integer iIcon
integer pWidth, pHeight
atom hWnd

    if hILsmall = 0 then
        pWidth = c_func(xGetSystemMetrics, {SM_CXSMICON})
        pHeight = c_func(xGetSystemMetrics, {SM_CYSMICON})
        hWnd = c_func(xImageList_Create, {pWidth, pHeight, ILC_MASK+ILC_COLOR8,1,1})
        void = c_func(xImageList_SetBkColor, {hWnd, CLR_NONE})
        hILsmall = hWnd
    end if
    iIcon = c_func(xImageList_AddIcon, {hILsmall,hIcon})
    return iIcon+1
end function

global procedure setIcon(integer id, atom hIcon)
-- associate the icon to the window
atom hWnd
    hWnd = ObjectHwnd[id]
    void = c_func(xSendMessage,{hWnd,WM_SETICON,ICON_BIG,hIcon})
    void = c_func(xSendMessage,{hWnd,WM_SETICON,ICON_SMALL,hIcon})
end procedure


global function loadImage(sequence fName, integer iType, integer iFlags)
-- load an **INDIVIDUAL** icon or a bitmap from a file.
-- NB: more operations exist than can be accessed via this function
--
--  iType can be one of:
--      IMAGE_ICON
--      IMAGE_BITMAP
--      IMAGE_CURSOR
--
-- iFlags can be:
--      LR_DEFAULTCOLOR (default 0)
--      LR_LOADFROMFILE
--      LR_CREATEDIBSECTION
--      LR_DEFAULTSIZE
--      LR_LOADMAP3DCOLORS
--      LR_LOADTRANSPARENT
--      LR_MONOCHROME
--      LR_SHARED
--
-- For more info see "LoadImage" in API
--
atom lpszName

    lpszName = allocate_StringZ(fName)

    -- ensure that LR_LOADFROMFILE flag is asserted
    iFlags = or_bits(iFlags,or_bits(LR_LOADFROMFILE,LR_LOADMAP3DCOLORS))

    return c_func(xLoadImage,{NULL,lpszName,iType,0,0,iFlags})

end function

global procedure setImage(integer id, atom hBitmap)
    ObjectImage[id] = hBitmap
    if ObjectClass[id]=BUTTON then
        void = sendMessage(id, BM_SETIMAGE, IMAGE_BITMAP, hBitmap)
    end if
end procedure

--global procedure bitCopy_____________________________
--  -- m: change sometime
--  (atom srcDC, integer srcX, integer srcY, integer nWidth, integer nHeight,
--atom destDC, integer destX, integer destY)
--
--atom hdcDest, hdcSrc, hGDI
--
--  -- copy the image over
--  void = c_func(xBitBlt,{destDC,destX,destY,nWidth,nHeight,srcDC,srcX,srcY,SRCCOPY})
--
--end procedure



global function isChecked(integer id)
integer class, item, flag, state
    class = ObjectClass[id]
    if class=MENU then
        class = ObjectType[id]
        if class=MenuItem then
            item = id
            flag = MF_BYCOMMAND
        elsif class=Menu then
            item = getMenuElementPosZ(id)
            flag = MF_BYPOSITION
--      else    -- MenuSep?
--          ?9/0 (caught by unassigned item/flag)
        end if
        state = c_func(xGetMenuState,{getParentHwnd(id),item,flag})
        if state = #FFFFFFFF
        or not and_bits(state, MF_CHECKED) then
            return 0
        end if
        return 1

    elsif class=BUTTON then
        -- yields one of: BST_UNCHECKED = 0,  BST_CHECKED = 1,  BST_INDETERMINATE = 2
        return c_func(xSendMessage,{ObjectHwnd[id],BM_GETCHECK,0,0})

    else
        -- oops,

    end if

end function


global procedure setCheck(object id, integer flags)
integer objectType

    if sequence(id) then
        for i=1 to length(id) do
            setCheck(id[i], flags)
        end for

    else
        objectType = ObjectType[id]
        if objectType=MenuItem then

            if flags then
                flags = or_bits(MF_BYCOMMAND, MF_CHECKED)
            else
                flags = or_bits(MF_BYCOMMAND, MF_UNCHECKED)
            end if
            void = c_func(xCheckMenuItem,{getParentHwnd(id),id,flags})

        elsif objectType=Menu then

            if ObjectParent[id] and ObjectType[ObjectParent[id]]=Menu then
                if flags then
                    flags = or_bits(MF_BYPOSITION, MF_CHECKED)
                else
                    flags = or_bits(MF_BYPOSITION, MF_UNCHECKED)
                end if
                void = c_func(xCheckMenuItem,{getParentHwnd(id),getMenuElementPosZ(id),flags})
            end if

        elsif ObjectClass[id]=BUTTON then -- BUTTON class, only RadioButton or CheckBox

            void = c_func(xSendMessage,{ObjectHwnd[id],BM_SETCHECK,flags,0})

        else
            -- oops

        end if

    end if

end procedure


global procedure checkMenuRadioItem(integer id, integer first, integer last)
-- This routine will set a radiobutton mark next to the entry and remove any marks
-- against all members of the range as specified. Please note that all items must
-- belong to the same menu. The call will fail or behave corruptly if they are not.

atom hMenu

    hMenu = getParentHwnd(id)
    first = getMenuElementPosZ(first)
    last = getMenuElementPosZ(last)
    id = getMenuElementPosZ(id)
    void = c_func(xCheckMenuRadioItem,{hMenu,first,last,id,MF_BYPOSITION})
end procedure


global function isEnabled(integer id)
integer state, CtrlType

    CtrlType = ObjectType[id]

    if CtrlType=Menu then
        state = c_func(xGetMenuState,{getParentHwnd(id),getMenuElementPosZ(id),or_bits(MF_GRAYED,MF_BYPOSITION)})
        state = and_bits(state, MF_GRAYED)
        return not state

    elsif CtrlType=MenuItem then
        state = c_func(xGetMenuState,{getParentHwnd(id),id,or_bits(MF_BYCOMMAND,MF_GRAYED)})
        state = and_bits(state, MF_GRAYED)
        return not state

    elsif CtrlType=TabItem then
        return ObjectExtra[id]

--  elsif CtrlType=HyperText then
--      return ObjectExtra[id][ENABLEDFLAG]

    else -- all other items
        return c_func(xIsWindowEnabled,{ObjectHwnd[id]})

    end if

end function




global procedure setEnable(object id, integer flag)
-- Enable or disable control; True will enable and False will disable.

integer CtrlType, state
atom hWnd

    if sequence(id) then -- list of items
        for i=1 to length(id) do
            setEnable(id[i], flag)
        end for

    else -- single item

        flag = (flag!=0)

        CtrlType = ObjectType[id]

        if CtrlType=Menu then
            flag = MF_BYPOSITION + (flag=0) -- special translation for menu flags
            void = c_func(xEnableMenuItem,{getParentHwnd(id),getMenuElementPosZ(id),flag})
            -- force redraw of the menubar if at top level
            hWnd = getWindowHwnd(id)
            if hWnd then
                void = c_func(xDrawMenuBar,{hWnd}) -- force redraw
            end if

        elsif CtrlType=MenuItem then
            flag = MF_BYCOMMAND + (flag=0) -- special translation for menu flags
            void = c_func(xEnableMenuItem,{getParentHwnd(id),id,flag})

        elsif CtrlType=TabItem then
            state = (ObjectExtra[id]!=0)
            if state!=flag then
                ObjectExtra[id] = flag
                -- force repaint
                void = c_func(xInvalidateRect,{ObjectHwnd[ObjectParent[id]],NULL,False})
            end if

--      elsif CtrlType=HyperText then
--          ObjectExtra[id][ENABLEDFLAG] = (flag!=0)
--
        else -- other control
            c_proc(xEnableWindow, {ObjectHwnd[id], flag})

        end if

    end if

end procedure

--/* Not required for Phix (auto-loaded from psqop.e)
procedure fatal(sequence a, sequence b)
    printf(1,"sequence lengths not the same (%d!=%d)!\n",{length(a),length(b)})
    ?9/0
end procedure

function sq_add(object a, object b)     -- Phix: copy from psqop.e
    if atom(a) then
        if atom(b) then return a + b end if
        for i=1 to length(b) do
            b[i] = sq_add(a,b[i])
        end for
        return b
    elsif atom(b) then
        for i=1 to length(a) do
            a[i] = sq_add(a[i],b)
        end for
        return a
    end if
    if length(a)!=length(b) then fatal(a,b) end if
    for i=1 to length(a) do
        a[i] = sq_add(a[i],b[i])
    end for
    return a
end function
--*/

global function getIndex(integer id)
    -- Will return the index value of the item currently selected in the list
    -- or the currently selected TabItem of a TabControl (in this case an id is returned).
    -- If a multi-item list control is referenced then a sequence of indexes
    -- will be returned. Please note that they will be in logical order NOT
    -- selection order. Combo boxes are only single selection.
integer selcount, objectClass, objectType
atom lpArray, hwnd
sequence indici

    hwnd = ObjectHwnd[id]

    objectClass = ObjectClass[id]
    objectType = ObjectType[id]
    
    if objectClass=LIST then

        if not and_bits(ObjectExtra[id], MULTISELECTIONS) then -- single selection list
            return c_func(xSendMessage,{hwnd,LB_GETCURSEL,0,0}) + 1

        else -- multiple selection list
            selcount = c_func(xSendMessage,{hwnd,LB_GETSELCOUNT,0,0})
            if not selcount then
                return 0
            elsif selcount = 1 then
                return c_func(xSendMessage,{hwnd,LB_GETCURSEL,0,0}) + 1
            end if
            lpArray = allocate_ListIndexes(selcount * 4)
            selcount = c_func(xSendMessage,{hwnd,LB_GETSELITEMS,selcount,lpArray})
            indici = peek4u({lpArray,selcount})
--          indici += 1
--          return indici
            return sq_add(indici,1)
        end if


    elsif objectType=ListView then
        return ObjectExtra[id][3]   -- saved in WM_NOTIFY

    elsif objectType=TreeView then
        return ObjectExtra[id][3]   -- saved in WM_NOTIFY.

    elsif objectClass=COMBO then
        return c_func(xSendMessage,{hwnd,CB_GETCURSEL,0,0}) + 1

    elsif objectType=TabControl then
        selcount = c_func(xSendMessage,{hwnd,TCM_GETCURSEL,0,0}) + 1
        if selcount then
            selcount = ObjectChildren[id][selcount]
        end if
        return selcount -- will be an id OR 0

    else
        -- oops

    end if

end function


atom LVI
    LVI = allocate(sizeofstruct(LVITEM))    -- permanently allocated

--
global procedure setIndex(integer id, object selection)
    -- Set the current selection for Lists or Combo boxes.
    -- NB: Only multi-lists can have multiple indexes set.
    -- if selection is 0 then all selections in the control are cleared
    -- if selection is -1 then all items are selected (only for multi-list control)
integer objectClass

    objectClass = ObjectClass[id]

    if ObjectType[id]=ListView then
        if atom(selection) then
            poke4(LVI+LVITEM_mask,LVIF_STATE)
            poke4(LVI+LVITEM_stateMask,LVIS_SELECTED+LVIS_FOCUSED)
--DEV 10/5/09: (put back 4/4/15 over filedump jmp)
            poke4(LVI+LVITEM_state,0)
            void = sendMessage(id,LVM_SETITEMSTATE,ObjectExtra[id][3] - 1,LVI)
-- 5/9/2010:
            if selection=-1 then
                poke4(LVI+LVITEM_state,0)
            else
                poke4(LVI+LVITEM_state,LVIS_SELECTED+LVIS_FOCUSED)
            end if
            void = sendMessage(id,LVM_SETITEMSTATE,selection-1,LVI)
            ObjectExtra[id][3] = selection
            if selection!=-1 then
                void = sendMessage(id,LVM_ENSUREVISIBLE,selection-1,0)
            end if
        end if

    elsif objectClass=LIST then

        if not and_bits(ObjectExtra[id], MULTISELECTIONS) then -- single selection list
            if atom(selection) then
                void = sendMessage(id, LB_SETCURSEL, selection-1, 0)
            end if

        else -- multiple selection list
            if integer(selection) then
                if selection=0 then -- deselect all items
                    void = sendMessage(id, LB_SETSEL, 0, -1)
                elsif selection=-1 then -- user wants to select all items
                    void = sendMessage(id, LB_SETSEL, 1, -1)
                else
                    void = sendMessage(id, LB_SETSEL, 1, selection-1)
                end if
            else -- multiple selections
                void = sendMessage(id,  WM_SETREDRAW, 0, 0)
                void = sendMessage(id, LB_SETSEL, 0, -1)
                for i=1 to length(selection) do
                    void = sendMessage(id, LB_SETSEL, 1, selection[i]-1)
                end for
                void = sendMessage(id,  WM_SETREDRAW, 1, 0)
                void = c_func(xInvalidateRect,{ObjectHwnd[id],NULL,0})
            end if
        end if

    elsif objectClass=COMBO then
        if atom(selection) then
            void = sendMessage(id, CB_SETCURSEL, selection-1, 0)
        end if

    else
        -- oops

    end if

end procedure


global procedure setTopItem(integer id, integer pos)
--
-- scroll the list part of the control so that the item at pos is at the top of the list box
-- this will NOT set the current selection to that item - use setIndex() for that purpose.
--
integer objectClass
    objectClass = ObjectClass[id]
    if objectClass=LIST then -- List box
        void = sendMessage(id, LB_SETTOPINDEX, pos-1, 0)
    elsif objectClass=COMBO then -- Combo boxes
        void = sendMessage(id, CB_SETTOPINDEX, pos-1, 0)
    end if
end procedure


global function isVisible(integer id)

    -- make the visibility state of a TabItem the same as the parent TabControl
    if ObjectType[id]=TabItem then
        id = ObjectParent[id]
    end if

    -- get the visibility state
    return c_func(xIsWindowVisible, {ObjectHwnd[id]})
end function


global procedure setVisible(object id, atom flag)
-- set the control visible or in the case of a tabItem it will make the associated controls visible
integer resizeflag, pID

    resizeflag = 0

    -- prepare show/hide flags
    if flag then
        flag = SW_SHOWNORMAL    -- show a window
    else
        flag = SW_HIDE          -- hide a window
    end if

    -- account for single instance
    if integer(id) then
        if ObjectType[id]=TabItem then
            setVisible(ObjectChildren[id], flag) -- change state of all "child" controls
        else
            c_proc(xShowWindow,{ObjectHwnd[id],flag})
            pID = ObjectParent[id]
            if pID and ObjectType[pID] = Window
            and find(id, ObjectChildren[pID]) then
                resizeflag = 1
            end if
        end if

    else -- multiple instances
        for i=1 to length(id) do
            c_proc(xShowWindow,{ObjectHwnd[id[i]],flag})
            if resizeflag=0 then
                pID = ObjectParent[id[i]]
                if pID and ObjectType[pID]=Window and find(id, ObjectChildren[pID]) then
                    resizeflag = 1
                end if
            end if
        end for

    end if

    -- does window need to be resized?
    if resizeflag then
        void = sendMessage(pID, WM_SIZE, 0, 0)
    end if

end procedure


global procedure setFocus(integer id)
integer idCurrent, pID, iPart, objectType
atom hwnd

    objectType = ObjectType[id]
    if objectType=TabItem then
        if ObjectExtra[id] then
--?7659
            pID = ObjectParent[id]
            hwnd = ObjectHwnd[pID]
            if c_func(xIsWindowVisible,{hwnd}) then
                iPart = c_func(xSendMessage,{hwnd,TCM_GETCURSEL,0,0}) + 1
                if iPart then
                    idCurrent = ObjectChildren[pID][iPart]
                    iPart = find(id, ObjectChildren[pID])
                    if not iPart then
                        ?9/0 -- error!!
                    end if
                    if idCurrent!=id then -- Aha, time to switch over tab selections
                        void = c_func(xSendMessage,{hwnd,TCM_SETCURSEL,iPart-1,0})
                        setVisible(ObjectChildren[idCurrent],False) -- hide the old tab
                        setVisible(ObjectChildren[id],True) -- show the new tab
                        c_proc(xSetFocus,{hwnd}) -- VERY IMPORTANT LINE!!!!
                    else -- merely force focus onto tab (which is already active)
                        c_proc(xSetFocus,{hwnd}) -- VERY IMPORTANT LINE!!!!
                        void = c_func(xSendMessage,{hwnd,TCM_SETCURFOCUS,iPart-1,0})
                    end if
                else
                    ?9876
                end if
            end if
--else
--  ?9785
        end if

    else
        if objectType=Window then
            -- Attempts to programmatically set the focus onto a window
            -- (like Edita does with main) must get rid of any auto-focus info.
            ObjectExtra[id][LASTFOCUS] = UNDEFINED
        end if
        c_proc(xSetFocus, {ObjectHwnd[id]})

    end if

end procedure


global function getFocus()
integer id, temp
atom hFocus
    hFocus = c_func(xGetFocus, {})
    if not hFocus then
        return 0
    end if
    id = getID(hFocus)
--PL 24/09/2013
--  if id and ObjectType[id]=TabControl then
    if id<1 or id>length(ObjectType) then
        return 0
    end if
    if ObjectType[id]=TabControl then
        temp = getIndex(id)
        if temp then
            return temp
        else
            return 0
        end if
    end if
    return id
end function




function Tab_isEnterable(integer id)-- is this control normally enterable?
integer tmp
    tmp = ObjectType[id]
    if tmp!=StatusBar then
        if tmp!=Window then
            if tmp!=TabItem then
                if tmp!=Menu then
                    if tmp!=MenuItem then
                        return 1
                    end if
                end if
            end if
        end if
    end if
    return 0
--DEV tryme:
--  return not find(ObjectType[id],{StatusBar,Window,TabItem,Menu,MenuItem})
end function


function Tab_isFocussable(integer id) -- can the focus exist on this control right now?
    if hasWS_TABSTOP(ObjectType[id]) then
        if isEnabled(id) then
            if isVisible(id) then
                return 1
            end if
        end if
    end if
    return 0
end function


function Tab_nextValidControl(integer id, integer nextsibling, integer owner)

integer index, pID
object siblings

    if not id then -- 2ndpass, from start
        id = owner
    elsif id=owner and nextsibling then -- 1st pass, hit end so now exit
        return id
    end if

    pID = ObjectParent[id]

    if pID and nextsibling then
        siblings = ObjectChildren[pID]
        if integer(siblings) then
            return NULL
        end if
        index = find(id, siblings)
        if not index then
            return NULL
        end if
        index += 1
        if index>length(siblings) then
            return Tab_nextValidControl(pID, 1, owner)
        end if
        id = siblings[index]
        if Tab_isFocussable(id) then
            return id
        end if
    end if

    -- loop through all children from first to last, possibly recursively, seeking a valid TAB spot
    siblings = ObjectChildren[id]
    pID = id
    if sequence(siblings) then
        for i=1 to length(siblings) do
            id = siblings[i]
            if Tab_isFocussable(id) then
                return id
            elsif Tab_isEnterable(id) then
                id = Tab_nextValidControl(id, 0, owner) -- go down a level
                if id then
                    return id
                end if
            end if
        end for
    end if

    -- exit, failure here, go up to next level
    return Tab_nextValidControl(pID, 1, owner)

end function


function Tab_prevValidControl(integer id, integer prevsibling, integer owner)

integer index, pID
object siblings

    if not id then -- 2ndpass, commence at end
        id = owner
    elsif id=owner and prevsibling then -- 1st pass, hit start so exit
        return id
    end if

    pID = ObjectParent[id]

    if pID and prevsibling then
        siblings = ObjectChildren[pID]
        if integer(siblings) then
            return NULL
        end if
        index = find(id, siblings)
        if not index then
            return NULL
        end if
        index -= 1
        if not index then
            return Tab_prevValidControl(pID, 1, owner)
        end if
        id = siblings[index]
        if Tab_isFocussable(id) then
            return id
        end if
    end if

    -- loop from all children from last to first, possibly recursively, seeking a valid TAB spot
    siblings = ObjectChildren[id]
    pID = id
    if sequence(siblings) then
        for i=length(siblings) to 1 by -1 do
            id = siblings[i]
            if Tab_isFocussable(id) then
                return id
            elsif Tab_isEnterable(id) then
                id = Tab_prevValidControl(id, 0, owner) -- go down a level
                if id then
                    return id
                end if
            end if
        end for
    end if

    -- exit, failure here, go up to next level
    return Tab_prevValidControl(pID, 1, owner)

end function


procedure Tab_moveFocus(integer id, integer window, integer ctrl, integer shift)
integer objtype, pID, newid

    objtype = ObjectType[id]
    pID = ObjectParent[id]

    -- DEAL TO TABITEMS & CONTROLS OWNED BY THEM
    if objtype=TabItem then
        if shift then -- move to prev tab
            newid = Tab_prevValidControl(id, 1, window)
        elsif ctrl then -- move to next tab
            newid = Tab_nextValidControl(id, 1, window)
        else -- cycle through subordinates, NB: ONE WAY!
            newid = Tab_nextValidControl(id, 0, pID)
            if newid=pID then
                newid = id
            end if
            setFocus(newid)
            return
        end if

    elsif pID and ObjectType[pID]=TabItem then
        if shift then
            id = Tab_prevValidControl(pID, 1, window)
        elsif ctrl then
            id = Tab_nextValidControl(pID, 1, window)
        else
            id = Tab_nextValidControl(id, 1, pID)
        end if
        setFocus(id)
        return

    end if

    -- Attempt to retrieve the next valid Tab spot
    if not shift then -- forward
        newid = Tab_nextValidControl(id, 1, window) -- 1st pass, to end
        if newid=window then
            newid = Tab_nextValidControl(0, 0, window) -- 2nd pass, from start
        end if

    else -- backward
        newid = Tab_prevValidControl(id, 1, window) -- 1st pass, to start
        if newid=window then
            newid = Tab_prevValidControl(0, 0, window) -- 2nd pass, from end
        end if

    end if

    -- if an error happened then simply retrieve the owner window as a last resort
    if newid=NULL then
        newid = window
    end if

    -- for TabItems force tab focus, otherwise set focus as normal
    setFocus(newid)

end procedure


global procedure moveFocusNextAvailable(integer id)
integer wID, next

    wID = getParentWindow(id)

    if not wID then
        return
    end if

    next = Tab_nextValidControl(id, 0, wID)
    if next=wID then
        next = Tab_nextValidControl(0, 0, wID)
    end if

    if next=wID or next=0 then
        return
    end if

    setFocus(next)

end procedure


function convertAsciiToVirtualKey(integer ascii)
integer virtkey
    virtkey = and_bits(c_func(xVkKeyScan, {ascii}), #FF)
    if virtkey=255 then
        virtkey = 0
    end if
    return virtkey
end function



global function getKeyState(integer key)
-- return the state of any virtual key including: Shift, Control, or Menu keys
-- if the key is down then 1, else 0
atom result
    result = c_func(xGetKeyState,{key})
    -- check the high bit. (low bit is toggle state)
    return (floor(result/2)!=0)
end function


global function setAccelerator(integer id, object caption)

-- caption is either the caption string of the control OR an integer specifying the virtual keycode
-- if caption is a length-1 string then the element must be the ASCII code of the key

integer pID, virtkey, ascii

    pID = getParentWindow(id)
    if not pID then
        return 0
    end if

    -- get virtual key
    if integer(caption) then -- virtual keycode
        virtkey = caption
    else
        if length(caption)=1 then -- ASCII code
            ascii = caption[1]
        else
            ascii = find('&', caption) -- AMPERSANDed letter
            if not ascii then
                return 0
            end if
            ascii = caption[ascii+1]
        end if
        -- convert ASCII => virtual key code
        virtkey = convertAsciiToVirtualKey(ascii)
        if not virtkey then
            return 0
        end if
    end if

    -- store the Accelerator data
    if find(virtkey, ObjectExtra[pID][ACCELKEYS]) then
        return 0 -- already have one
    end if

    ObjectExtra[pID][ACCELKEYS] &= virtkey
    ObjectExtra[pID][ACCELIDS] &= id

    return 1 -- success

end function


global function getSystemMetrics(integer attr)
    return c_func(xGetSystemMetrics, {attr})
end function



global function getScreenSize()
integer width, height
    width = c_func(xGetSystemMetrics, {SM_CXSCREEN})
    height = c_func(xGetSystemMetrics, {SM_CYSCREEN})
    return {width, height}
end function


global function clientToScreen(integer id, integer x, integer y)
atom ps, hwnd
sequence screen_coords

    hwnd = ObjectHwnd[id]
    ps = allocate_Point()

    poke4(ps,{x,y})

    if c_func(xClientToScreen,{hwnd,ps}) then
        screen_coords = peek4s({ps,2})
        if screen_coords[1]>32767 then screen_coords[1] -= 65536 end if
        if screen_coords[2]>32767 then screen_coords[2] -= 65536 end if
    else
        screen_coords = {}
    end if

    return screen_coords
end function

global procedure invalidateRect(integer id, integer bErase)
    void = c_func(xInvalidateRect, {ObjectHwnd[id], NULL, bErase})
end procedure

global function getWindowRect(integer id)
-- returns {left,top,right,bottom}
object rect
atom hwnd, rs

    hwnd = ObjectHwnd[id]
    rs = allocate_Rect()

    if c_func(xGetWindowRect, {hwnd, rs}) then
        rect = peek4s({rs,4})
    else
        rect = 0
    end if

    return rect

end function


global function getClientRect(integer id)
-- returns {left,top,width,height}
object rect, TmpRect
atom hwnd, rs
integer temp

    hwnd = ObjectHwnd[id]
    rs = allocate_Rect()

    if not c_func(xGetClientRect, {hwnd, rs}) then
        rect = 0

    else
        rect = peek4u({rs,4})

        if ObjectType[id]=Window then

            -- does window have a tool bar?
            temp = ObjectExtra[id][TOOLBAR]
            if temp!=UNDEFINED then
                if isVisible(temp) then -- ToolBar exists & is visible
                    if c_func(xGetWindowRect, {ObjectHwnd[temp], rs}) then
                        TmpRect = peek4u({rs,4})
                        rect[2] += TmpRect[4] - TmpRect[2] + 1
                    end if
                end if
            end if

            -- does window have a status bar?
            temp = ObjectExtra[id][STATUSBAR]
            if temp!=UNDEFINED then
                if isVisible(temp) then -- StatusBar exists & is visible
                    if c_func(xGetWindowRect, {ObjectHwnd[temp], rs}) then
                        TmpRect = peek4u({rs,4})
                        rect[4] -= TmpRect[4] - TmpRect[2] + 1
                    end if
                end if
            end if

            -- does window have a horizontal scroll bar?
            temp = ObjectExtra[id][HSCROLL]
            if temp!=UNDEFINED then
                if isVisible(temp) then -- Vertical Scroll Bar exists & is visible
                    if c_func(xGetWindowRect, {ObjectHwnd[temp], rs}) then
                        TmpRect = peek4u({rs,4})
                        rect[4] -= TmpRect[4] - TmpRect[2] + 1
                    end if
                end if
            end if

            -- does window have a vertical scroll bar?
            temp = ObjectExtra[id][VSCROLL]
            if temp!=UNDEFINED then
                if isVisible(temp) then -- Horizontal Scroll Bar exists & is visible
                    if c_func(xGetWindowRect, {ObjectHwnd[temp], rs}) then
                        TmpRect = peek4u({rs,4})
                        rect[3] -= TmpRect[3] - TmpRect[1] + 1
                    end if
                end if
            end if

        end if
--DEV from win32lib::
--!global function getClientRect(integer id)
--
--  elsif ctrl_Type[id]=ReBarBand then
--      rect[1..4]  = getRect(id)
--
--              if find(ctrl_Type[toolbar],{ToolBar,FlatToolBar,ReBar}) then
--                  tb_position = and_bits(styles[1],CCS_MASK)
--                  if tb_position=CCS_TOP then
--                  -- add height to the y value
--                      rect[2] += size[2]
--                      rect[4] -= size[2]
--                  elsif tb_position=CCS_LEFT then
--                  -- add width to the x value
--                      rect[1] += size[1]
--                      rect[3] -= size[1]
--                  elsif tb_position=CCS_BOTTOM then
--                      rect[4] -= size[2]
--                  else        -- CCS_RIGHT
--                      rect[3] -= size[1]
--                  end if
--              else -- ReBar, nothing to do
--
--
    end if

    return rect

end function


global function getClientCoords(integer id)
    -- get the client coordinates of a control within its parent
atom hParent, hWnd, lpRect

--  hParent = ObjectParent[id]      -- PL 18/11/2006
    hParent = getParentHwnd(id)
    hWnd = ObjectHwnd[id]

    if hParent then

        lpRect = allocate_Rect()

        if c_func(xGetWindowRect,{hWnd,lpRect}) then

            if c_func(xScreenToClient,{hParent,lpRect}) then
                if c_func(xScreenToClient,{hParent,lpRect+8}) then
                    return peek4s({lpRect,4})
                end if
            end if

        end if

    end if

    return {0,0,0,0}

end function


function isPointIn(integer x, integer y, sequence rect)
    if x>=rect[1] then
        if x<=rect[3] then
            if y>=rect[2] then
                if y<=rect[4] then
                    return True
                end if
            end if
        end if
    end if
    return False
end function

global function isWindowMinimized(integer id)
    return c_func(xIsIconic, {ObjectHwnd[id]})
end function


global function isWindowMaximized(integer id)
    return c_func(xIsZoomed, {ObjectHwnd[id]})
end function


global function isWindowNormal(integer id)
atom hwnd
    hwnd = ObjectHwnd[id]
    return not (c_func(xIsIconic,{hwnd}) or c_func(xIsZoomed,{hwnd}))
end function

global procedure openWindow(integer id, integer styleFlag)
atom hwnd
integer wID
    hwnd = ObjectHwnd[id]
    c_proc(xShowWindow,{hwnd,styleFlag})
    -- ensure that first viable control has focus resting on it
    wID = Tab_nextValidControl(id, 0, id)
    if wID!=id then
        setFocus(wID)
    end if

end procedure


global procedure closeWindow(integer id)
    void = c_func(xSendMessage,{ObjectHwnd[id],WM_CLOSE,0,0}) -- this line has the better way of closing!!!
--  void = c_func(xCloseWindow,{ObjectHwnd[id]}) -- this function will minimize a child window or minimize & 
--                                               --  half close a main window. very poor name & behaviour!
end procedure

--21/6/15:
--global procedure repaintWindow(object id)
--/**/global procedure repaintWindow(object id, integer bErase=0)
--/*
global procedure repaintWindow(object id, integer bErase)
--*/
    if integer(id) then
        if ObjectType[id]=TabItem then
--          void = c_func(xInvalidateRect,{ObjectHwnd[ObjectParent[id]],NULL,False})
            void = c_func(xInvalidateRect,{ObjectHwnd[ObjectParent[id]],NULL,bErase})
        else -- other controls
--          if c_func(xInvalidateRect,{ObjectHwnd[id],NULL,1}) then
            if c_func(xInvalidateRect,{ObjectHwnd[id],NULL,bErase}) then
                void = sendMessage(id,WM_PAINT,0,0)
            end if
        end if
    else
        for i=1 to length(id) do
            repaintWindow(id[i],bErase)
        end for
    end if
end procedure

constant
   LEFT   = 1,
   TOP    = 2,
   RIGHT  = 3,
   BOTTOM = 4

global procedure moveWindow(integer id, integer x, integer y)
    void = c_func(xSetWindowPos, {getWindowHwnd(id), NULL, x, y, 0, 0, or_bits(SWP_NOSIZE, SWP_NOZORDER)})
end procedure

global procedure setWindowPos(integer id, integer x, integer y, integer w, integer h, integer flag)
--
-- flag must be one of:
--      SWP_NOMOVE - Retain the current position (ignore the x and y parameters).
--      SWP_NOSIZE - Retain the current size (ignore the w and h parameters).
--      0          - reposition and resize
-- id can be any type of control, except obviously things like Menu, MenuItem, ToolSep etc.
--
    if flag=SWP_NOMOVE then
        if x or y then ?9/0 end if
    elsif flag=SWP_NOSIZE then
        if w or h then ?9/0 end if
    elsif flag then
        ?9/0
    end if
    flag = or_bits(flag,SWP_NOZORDER)
    void = c_func(xSetWindowPos, {getHwnd(id), NULL, x, y, w, h, flag})
end procedure

global procedure centerWindow(integer id, integer hOffset, integer vOffset)
sequence wndRect
integer x, y

    wndRect = getWindowRect(id)

    x = getSystemMetrics(SM_CXSCREEN) + wndRect[LEFT] - wndRect[RIGHT]
    x = floor(x/2)

    y = getSystemMetrics(SM_CYSCREEN) + wndRect[TOP] - wndRect[BOTTOM] - getSystemMetrics(SM_CYCAPTION)
    y = floor(y/2)

    moveWindow(id, x+hOffset, y+vOffset)

end procedure


--------------------------------------------------------------------------------------

--/**/global function getClipboardText(integer fmt=CF_TEXT)
--/*
global function getClipboardText(integer fmt)
--*/
-- fmt should be CF_TEXT (1) or CF_UNICODETEXT (13)
-- Aside: xGetClipboardData performs automatic conversion between CF_TEXT and 
--        CF_UNICODETEXT; whichever it was saved in and whichever you ask for,
--        you'll always get something reasonable back (perhaps with a few '?').
--        I considered EnumClipboardFormats and returning a unicode string if 
--        that was what was actually in the clipboard, even manually checking 
--        for chars(words) > #FF, but realised that if your app cannot handle
--        unicode, not much point returning it. The safest thing, perhaps, is 
--        to always ask for CF_UNICODETEXT and convert it to UTF8, or, maybe,
--        a few tests may prove there is nothing to worry about.
atom hWnd, hClip, pData
sequence clip
integer size

    clip = {}
    hWnd = c_func(xGetActiveWindow, {})
    if c_func(xOpenClipboard, {hWnd}) then
        if c_func(xIsClipboardFormatAvailable,{fmt}) then
            hClip = c_func(xGetClipboardData, {fmt})
            pData = c_func(xGlobalLock,{hClip})
            if pData then
                size = c_func(xGlobalSize, {hClip})
                if fmt=CF_TEXT then
                    clip = peek({pData, size})
                elsif fmt=CF_UNICODETEXT then
--PL 01/08/2013:
--                  clip = peek2u({pData, size})
                    clip = peek2u({pData, floor(size/2)})
                else
                    ?9/0
                end if
                void = c_func(xGlobalUnlock, {hClip})
                size = find(0,clip)
                if size then
                    clip = clip[1..size-1]
                end if
            end if
        end if
        c_proc(xCloseClipboard, {})
    end if
    return clip
end function



--/**/global procedure setClipboardText(sequence text, integer fmt=CF_TEXT)
--/*
global procedure setClipboardText(sequence text, integer fmt)
--*/
-- copy CF_TEXT (1) or CF_UNICODETEXT (13) data to clipboard
integer len
atom hWnd, hGlobal, pData

    len = length(text) 
    if len!=0 then
        if text[len]!=0 then
            text &= 0
            len += 1
        end if
        hWnd = c_func(xGetActiveWindow, {})
        if c_func(xOpenClipboard, {hWnd}) then
            if c_func(xEmptyClipboard, {}) then
                -- allocate the text into global memory
                if fmt = CF_UNICODETEXT then
                    len *= 2
                end if
                hGlobal = c_func(xGlobalAlloc, {GMEM_CLIPBOARD, len})
                if hGlobal!=NULL then
                    pData = c_func(xGlobalLock, {hGlobal})
                    if pData=NULL then
                        c_proc(xGlobalFree, {hGlobal})
                    else
                        if fmt=CF_TEXT then
                            poke(pData, text)
                        else
                            poke2(pData, text)
                        end if
                        void = c_func(xGlobalUnlock, {hGlobal})

                        -- copy data to clipboard & close
                        void = c_func(xSetClipboardData, {fmt, hGlobal})
                        --Note that we should NOT GlobalFree hGlobal,  
                        --      since the clipboard now owns it.
                    end if
                end if
            end if
            c_proc(xCloseClipboard, {})
        end if
    end if
end procedure


global function getText(integer id)
integer pID, len, objType, uIDItem, uFlag
sequence text
atom buffer, hMenu, hwnd, struct, lpMII

    -- clipboard?
    if id=CLIPBOARD then
        return getClipboardText(CF_TEXT)
    end if

    -- ensure id is a +ve number
    if id<0 then
        id = 0 - id
    end if

    -- initialize some variables
    text = ""
    objType = ObjectType[id]

    if objType=StatusField then
        -- retrieve field index
        uFlag = getStatusFieldIndex(id)
        hwnd = ObjectHwnd[ObjectParent[id]]
        -- get the length of the text
        len = c_func(xSendMessage,{hwnd,SB_GETTEXTLENGTH,uFlag,0})
        len = and_bits(len, #FFFF)
        -- retrieve the text
        buffer = allocate_TextSpace(len+1)
        len = c_func(xSendMessage,{hwnd,SB_GETTEXT,uFlag,buffer})
        if len then
            text = peek({buffer,len})
        end if

    elsif objType=TabItem then
        uIDItem = find(id,ObjectChildren[ObjectParent[id]]) -- index of tab part
        if uIDItem!=0 then
            uIDItem -= 1 -- make 0-based
            -- use form other than allocate_TextSpace()?
            -- text buffer is tacked onto end of this struct
            struct = allocate_TextSpace(sizeofstruct(TC_ITEM)+MAXLENGTHGETTABITEMTEXT)
            buffer =  struct + TC_ITEM_lParam + 4
            poke4(struct, TCIF_TEXT)
            poke4(struct + TC_ITEM_pszText, buffer) -- start of buffer
            poke4(struct + TC_ITEM_cchTextMax, MAXLENGTHGETTABITEMTEXT) -- includes null terminator
            hwnd = ObjectHwnd[ObjectParent[id]] -- handle of the tab control "parent"
            if c_func(xSendMessage,{hwnd,TCM_GETITEMA,uIDItem,struct}) then
                text = peek_string(buffer)
            end if
        end if

    elsif ObjectClass[id]=MENU then
        return ObjectLabel[id]
    elsif 0 then

        -- deal to un-owned menus
        pID = ObjectParent[id]
        if not pID then
            return ObjectLabel[id]
        end if

        -- get the handle to the owner menu
        hMenu = ObjectHwnd[pID]
--      hMenu = ObjectHwnd[id]

        -- prepare variables for specific fields
        if objType=Menu then
            uIDItem = getMenuElementPosZ(id)
--          uFlag = MF_BYPOSITION
            uFlag = True
        else -- MenuItem
            uIDItem = id
--          uFlag = MF_BYCOMMAND
            uFlag = False
        end if

--  ?getLastError()

        -- get the length of the string
--PL 30/5/15:
--      len = c_func(xGetMenuString, {hMenu, uIDItem, 0, 0, uFlag})
--      -- poke the string into allocated memory
--      if len then
--          buffer = allocate_TextSpace(len+1)
--          if c_func(xGetMenuString, {hMenu, uIDItem, buffer, len+1, uFlag}) then
--              text = peek({buffer,len})
--          end if
----else -- no help, unchanged
----    ?getLastError()
--      end if
--/*
        lpMII = allocate_Menu()
        poke4(lpMII+MII_fMask, MFT_STRING)
        poke4(lpMII+MII_fType, MFT_STRING)
        poke4(lpMII+MII_dwTypeData, NULL)
        -- get the current info for the menu item
        if c_func(xGetMenuItemInfo,{hMenu,uIDItem,uFlag,lpMII}) then
            -- prepare the new text value
            len = peek4u(lpMII+MII_cch)+1
            buffer = allocate_TextSpace(len)
--MIIM_STRING 
--0x00000040 
            poke4(lpMII+MII_dwTypeData, buffer)
            poke4(lpMII+MII_cch, len)
            if c_func(xGetMenuItemInfo,{hMenu,uIDItem,uFlag,lpMII}) then
                text = peek({buffer,len})
            end if
        end if
--*/
        lpMII = allocate_Menu()
        poke4(lpMII+MII_fMask, MIIM_TYPE)
        poke4(lpMII+MII_fType, MFT_STRING)
        poke4(lpMII+MII_dwTypeData, NULL)
        if c_func(xGetMenuItemInfo,{hMenu,uIDItem,uFlag,lpMII}) then
            -- prepare the new text value
            len = peek4u(lpMII+MII_cch)+1
            buffer = allocate_TextSpace(len)
            poke4(lpMII+MII_dwTypeData, buffer)
            poke4(lpMII+MII_cch, len)
            if c_func(xGetMenuItemInfo,{hMenu,uIDItem,uFlag,lpMII}) then
                text = peek({buffer,len})
            end if
        end if

    else -- all other controls

        hwnd = ObjectHwnd[id]
        len = c_func(xSendMessage,{hwnd,WM_GETTEXTLENGTH,0,0})
            -- extract the text
        if len then
            buffer = allocate_TextSpace(len+1)
            len = c_func(xSendMessage,{hwnd,WM_GETTEXT,len+1,buffer})
            text = peek({buffer,len})
        end if

    end if

    -- store results
    ObjectLabel[id] = text

    -- exit
    return text

end function


global procedure setText(integer id, object text)
atom lpSz, lpMII, hMenu, hWnd, flags, struct
integer pos, pID, objectType

    -- convert the 'text' object to a char sequence if needed
    if atom(text) then
        text = sprintf("%g", text)
    end if

    -- clipboard?
    if id=CLIPBOARD then
        setClipboardText(text,CF_TEXT)
        return
    end if

-- PL added 28/03/2010:
-- (NB in vedb.exw, the messageBox limit was more like 2000 ..., but then again
--      this might be a MLE or somesuch with higher limits?)
    if length(text)>32000 then
        text = "... " & text[1..32000] & " ..."
    end if

    -- store text
    ObjectLabel[id] = text

    -- poke text string into memory
    lpSz = allocate_StringZ(text)

    objectType = ObjectType[id]

    -- STATUS FIELDS
    if objectType=StatusField then
        void = sendMessage(ObjectParent[id],SB_SETTEXT,getStatusFieldIndex(id),lpSz)

    -- MENU
    elsif ObjectClass[id]=MENU then
        -- must be "owned" menu
        pID = ObjectParent[id]
        if pID and objectType!=MenuSep then
            if objectType=Menu then
                pos = getMenuElementPosZ(id)
                flags = True
            else -- MenuItem
                pos = id
                flags = False
            end if
            hMenu = ObjectHwnd[pID]
            lpMII = allocate_Menu()
            poke4(lpMII+MII_fMask, MIIM_TYPE)
            -- get the current info for the menu item
            if c_func(xGetMenuItemInfo,{hMenu,pos,flags,lpMII}) then
                -- prepare the new text value
                poke4(lpMII+MII_dwTypeData, lpSz)
                -- call the API routine
                void = c_func(xSetMenuItemInfo,{hMenu,pos,flags,lpMII})
                -- repaint the menu bar if necessary
                drawMenuBar(id)
            end if
        end if

    -- TAB
    elsif objectType=TabItem then
        pos = find(id,ObjectChildren[ObjectParent[id]]) -- index of tab part
        if pos!=0 then
            pos -= 1 -- make 0-based
            struct = allocate_TextSpace(sizeofstruct(TC_ITEM))
            poke4(struct, TCIF_TEXT)
            poke4(struct + TC_ITEM_pszText, lpSz) -- start of buffer
            poke4(struct + TC_ITEM_cchTextMax, length(text)+1) -- includes null terminator
            hWnd = ObjectHwnd[ObjectParent[id]] -- handle of the tab control "parent"
            void = c_func(xSendMessage,{hWnd,TCM_SETITEMA,pos,struct})
        end if


    -- ALL OTHER CONTROLS, Windows & StatusBars
    else
        c_proc(xSetWindowText,{ObjectHwnd[id],lpSz})

        if objectType=HyperText then
            repaintWindow(id,False)
        end if

    end if

end procedure


global procedure setTextColour(object id, integer colour)
    if sequence(id) then
        for i=1 to length(id) do
            setTextColour(id[i],colour)
        end for
    else
        ObjectTextColour[id] = colour -- only valid for TabItems ATM - and labels with SS_OWNERDRAW
        repaintWindow(id,False)
    end if
end procedure

global function getTextColour(integer id)
    return ObjectTextColour[id] -- only valid for TabItems ATM
end function

--DEV
--global constant   CLR_INVALID = #FF000000


global procedure setBackColour(object id, integer colour)
atom brush
--atom hdc
if sequence(id) then
    for i=1 to length(id) do
        setBackColour(id[i],colour)
    end for
else
    ObjectBackColour[id] = colour
--  hdc = getDC(id)
--  if c_func(xSetBkColor,{hdc,colour})=CLR_INVALID then
----        warnErr("SetBkColor in setBackColour failed.")
--?9/0
--  elsif  then
    if ObjectClass[id]=WINDOW then
        brush = c_func(xCreateSolidBrush,{colour})
--  atom lNewBrush, lOldBrush
--
--      -- set that as the background color
--              lOldBrush = ctrl_Bg_Brush[lId]
--              ctrl_Bg_Brush[lId] = lNewBrush
--
--              -- delete the prior brush
--              deleteObject(lOldBrush)
--
        void = c_func(xSetClassLong,{ObjectHwnd[id],GCL_HBRBACKGROUND,brush})
--DEV untried (nicked from win32lib):
--global procedure setBackground(object id, integer flag, object bkData)
--setBackColour
--
--              elsif ctrl_Type[lId]=ReBar then
--                  VOID = sendMessage(lId,RB_SETBKCOLOR,0,lColor)

--else
--      hdc = getDC(id)
----        if c_func(xSetBkColor,{hdc,colour})=CLR_INVALID then end if
--      if c_func(xSetBkColor,{hdc,colour}) then end if

    end if
--  releaseDC(id,hdc)
    repaintWindow(id,False)
end if
end procedure

global function getBackColour(integer id)
    return ObjectBackColour[id]
end function

constant LOGPIXELSY=90

constant lf=allocate(sizeofstruct(LOGFONT))

global function createFontForDC(atom hDC, sequence face, integer points, object attributes)
integer PPLISH
integer fHeight
integer attr

    PPLISH = c_func(xGetDeviceCaps,{hDC, LOGPIXELSY}) -- Pixels Per Logical Inch of Screen Height
    fHeight = floor(-PPLISH*points/72)

    mem_set(lf,0,sizeofstruct(LOGFONT))

    poke4(lf + LOGFONT_lfHeight,    fHeight)
    poke(lf + LOGFONT_lfCharSet,    1)  -- DEFAULT_CHARSET
    if length(face)>=32 then ?9/0 end if
    poke(lf + LOGFONT_lfFaceName,   face&0)
    if atom(attributes) then
        attr = attributes
    else
        attr = attributes[1]
    end if
--DEV use proper constants here:
    if and_bits(attr,1) then    -- bold
        attr -= 1
        poke4(lf + LOGFONT_lfWeight,    700)    -- FW_BOLD
--  else
--      poke4(lf + LOGFONT_lfWeight,    400)    -- FW_NORMAL
    end if
    if and_bits(attr,2) then    -- italic
        attr -= 2
        poke(lf + LOGFONT_lfItalic,     1)
    end if
    if and_bits(attr,4) then    -- underline
        attr -= 4
        poke(lf + LOGFONT_lfUnderline,  1)
    end if
    if and_bits(attr,8) then    -- strikeout
        attr -= 8
        poke(lf + LOGFONT_lfStrikeOut,  1)
    end if
    if attr!=0 then ?9/0 end if
    if sequence(attributes) then
        poke4(lf + LOGFONT_lfWidth,         attributes[2])
        poke4(lf + LOGFONT_lfEscapement,    attributes[3])
        poke4(lf + LOGFONT_lfOrientation,   attributes[4])
        poke(lf + LOGFONT_lfCharSet,        attributes[5])
        poke(lf + LOGFONT_lfOutPrecision,   attributes[6])
        poke(lf + LOGFONT_lfClipPrecision,  attributes[7])
        poke(lf + LOGFONT_lfQuality,        attributes[8])
        poke(lf + LOGFONT_lfPitchAndFamily, attributes[9])
    end if
    return c_func(xCreateFontIndirect,{lf})
end function

global procedure setFont(object ids, sequence face, integer points, object attributes)
-- The /i attributes flag can be a atom that combines the following:
--
--    Normal    = 0
--    Bold      = 1
--    Italic    = 2
--    Underline = 4
--    Strikeout = 8
--
-- or a sequence of nine elements. This form is used when using non-TrueType
-- fonts or using some of the advanced features of the Windows font engine. /n
--
--/li [1] Attributes (eg Bold+Italic)
--/li [2] Average Char Width
--/li [3] Escapement  (How much it slopes in 10-degree increments)
--/li [4] Orientation (Should be set to the same as Escapement)
--/li [5] CharSet  (eg. ANSI_CHARSET, SYMBOL_CHARSET)
--/li [6] OutPrecision
--/li [7] ClipPrecision
--/li [8] Quality
--/li [9] PitchAndFamily

integer id
atom lDC
atom prevFont, hFont

    if atom(ids) then
        id = ids
    else
        id = ids[1]
    end if

    lDC = getDC(id)
    hFont = createFontForDC(lDC, face, points, attributes)
    while 1 do
        prevFont = selectObject(lDC, hFont)         -- needed for window (vtext.exw)
        void = sendMessage(id,WM_SETFONT,hFont,1)   -- needed for listbox (lbox.exw)
        void = deleteObject(prevFont)

        releaseDC(id,lDC)

        if atom(ids) then exit end if
        if length(ids)=1 then exit end if
        ids = ids[2..length(ids)]
        id = ids[1]
        lDC = getDC(id)
    end while

end procedure


global function getFont(integer id)
-- returns the font handle for an existing control
    return ObjectFont[id]
end function

global procedure wPuts(integer id, integer xpos, integer ypos, object s)
-- Display text at {xpos,ypos} on specified window.
-- s may be a simple text string, an atom (automatically formatted using %g),
-- or a pair of {format_string,params}, eg:
--  wPuts(main,10,10,"Test")
--  wPuts(main,10,50,3.5)
--  wPuts(main,10,90,{"%d of %d",{5,10}})
atom hdc

    -- Check for formatting
    if atom(s) then
        s = sprintf("%g", s)
    elsif length(s)=2 and sequence(s[1]) then
        s = sprintf(s[1], s[2])
    end if

    hdc = getDC(id)
--  hdc = getPrivateDC(id)  --NB this will only work for windows
    void = c_func(xSetBkMode , {hdc, TRANSPARENT})

    -- display the text in the buffer
    c_proc(xTextOut,{hdc,xpos,ypos,allocate_StringZ(s),length(s)})

    -- release the device context
    releaseDC( id , hdc )

end procedure

global function insertItem(integer id, sequence text, integer pos)

integer len, msg, disp, objectClass
atom lpBuffer, hwnd

    -- calculate length of memory buffer required
    len = length(text)

    -- make 0-based index,
    -- NB: a -1 in the API call will result in appending of the item so
    -- use 0 for that purpose and it will become -1 in due course

    -- get the control handle
    hwnd = ObjectHwnd[id]
    objectClass = ObjectClass[id]
    
    -- get the message, based on control type
    if objectClass=LIST then
        if pos=0 then
            disp = 0
            msg = LB_ADDSTRING
        else
            pos -= 1
            disp = 1
            msg = LB_INSERTSTRING
        end if

    elsif objectClass=COMBO then
        if pos=0 then
            disp = 0
            msg = CB_ADDSTRING
        else
            pos -= 1
            disp = 1
            msg = CB_INSERTSTRING
        end if
    end if


    if length(text) and sequence(text[1]) then -- group of strings
        -- disable list from updating until operation is over
        void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,0,0})

        -- loop through each item
        for i=1 to length(text) do

            -- re-allocate the text buffer if needed
            lpBuffer = allocate_StringZ(text[i])

            -- insert the item
            pos+= disp
            void = c_func(xSendMessage,{hwnd,msg,pos,lpBuffer})

        end for

        -- enable the list to update and redraw it
        void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,1,0})
        void = c_func(xInvalidateRect,{hwnd,NULL,0})

    else -- add/insert a single item
        lpBuffer = allocate_StringZ(text)
        pos = c_func(xSendMessage,{hwnd,msg,pos,lpBuffer})

    end if

    return pos + 1

end function



global procedure deleteItem(integer id, object pos)
    -- delete the item from the position specified
    -- if pos=0 then entire list will be erased
    -- if pos is a sequence then the range element#1 to element#2 will be deleted

atom hwnd
integer msg, objectClass

    hwnd = ObjectHwnd[id]

    objectClass = ObjectClass[id]
    if objectClass=LIST then

        if integer(pos) then
            if pos=0 then -- reset content of entire list
                void = c_func(xSendMessage,{hwnd,LB_RESETCONTENT,0,0})
                return

            else -- just delete the item
                void = c_func(xSendMessage,{hwnd,LB_DELETESTRING,pos-1,0})

            end if

            return

        else -- sequence, means a multiple delete
            msg = LB_DELETESTRING

        end if

    elsif objectClass=COMBO then

        if integer(pos) then

            if pos=0 then -- reset content of entire list
                void = c_func(xSendMessage,{hwnd,CB_RESETCONTENT,0,0})

            else
                void = c_func(xSendMessage,{hwnd,CB_DELETESTRING,pos-1,0})

            end if

            return

        else
            msg = CB_DELETESTRING

        end if

    else -- wrong sort of control
        return
--      FatalErr("Wrong control referenced in deleteItem() routine.")

    end if

    -- disable list from updating until operation is over
    void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,0,0})

--PL 12/8/8 sequence op:
--  pos -= 1

    -- loop through each item in reverse, it's faster
    for i=pos[2] to pos[1] by -1 do
--      void = c_func(xSendMessage,{hwnd,msg,i,0}) -- delete the item
        void = c_func(xSendMessage,{hwnd,msg,i-1,0}) -- delete the item
    end for

    -- enable the list to update and then redraw it
    void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,1,0})
    void = c_func(xInvalidateRect,{hwnd,NULL,0})

end procedure



global function getItem(integer id, object pos)
integer len, disp, get_len_msg, get_text_msg, class
atom hwnd, lpSz
sequence items

    -- check that caller is valid list-type control
    class = ObjectClass[id]
    if class=LIST then
        get_len_msg = LB_GETTEXTLEN
        get_text_msg = LB_GETTEXT
    elsif class=COMBO then
        get_len_msg = CB_GETLBTEXTLEN
        get_text_msg = CB_GETLBTEXT
    else
        return "" -- wrong class, silly!
    end if

    -- get windows handle of control
    hwnd = ObjectHwnd[id]

    if integer(pos) then
        if pos=0 then
            pos = getIndex(id)
            if sequence(pos) then -- multiple selection, can't help here
                return ""
            end if
        end if
        len = c_func(xSendMessage,{hwnd,get_len_msg,pos-1,0})
        if len>0 then -- means no error occurred OR text has definite length
            lpSz = allocate_TextSpace(len+1)
            if c_func(xSendMessage,{hwnd,get_text_msg,pos-1,lpSz}) then
                return peek({lpSz,len})
            end if
        end if
        return "" -- error
    end if

--PL 12/8/8 sequence op:
--  pos -= 1

    len = pos[2] - pos[1] + 1
    disp = pos[1] - 1
--  disp = pos[1]   -- 12/8/8 is above still OK? [DEV testing rqd]

    -- initialize array of blank strings
    items = repeat("", len)

    -- loop through list and retrieve each item in range
    for i=pos[1] to pos[2] do
--      len = c_func(xSendMessage,{hwnd,get_len_msg,i,0})
        len = c_func(xSendMessage,{hwnd,get_len_msg,i-1,0})
        if len>0 then -- means no error occurred OR text has definite length
            lpSz = allocate_TextSpace(len+1)
--          if c_func(xSendMessage,{hwnd,get_text_msg,i,lpSz}) then
            if c_func(xSendMessage,{hwnd,get_text_msg,i-1,lpSz}) then
                items[i-disp] = peek({lpSz,len})
            end if
        end if
    end for

    -- exit
    return items

end function



global procedure setItem(integer id, sequence text, integer pos)
atom hwnd, lpBuffer
integer index, objectClass

    pos -= 1
    hwnd = ObjectHwnd[id]
    lpBuffer = allocate_StringZ(text)

    -- prevent list from updating during operation
    void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,0,0})

    objectClass = ObjectClass[id]

    -- List boxes
    if objectClass=LIST then

        -- common list operations
        index = c_func(xSendMessage,{hwnd,LB_GETSEL,pos,0}) > 0
        void = c_func(xSendMessage,{hwnd,LB_DELETESTRING,pos,0})

        if and_bits(ObjectExtra[id], MULTISELECTIONS) then -- multiselection list
            void = c_func(xSendMessage,{hwnd,LB_INSERTSTRING,pos,lpBuffer})
            if index then void = c_func(xSendMessage,{hwnd,LB_SETSEL,True,pos}) end if

        else -- single selection list
            void = c_func(xSendMessage,{hwnd,LB_INSERTSTRING,pos,lpBuffer})
            if index then void = c_func(xSendMessage,{hwnd,LB_SETCURSEL,pos,0}) end if

        end if

    elsif objectClass=COMBO then
        index = c_func(xSendMessage,{hwnd,CB_GETCURSEL,0,0}) = pos
        void = c_func(xSendMessage,{hwnd,CB_DELETESTRING,pos,0})
        void = c_func(xSendMessage,{hwnd,CB_INSERTSTRING,pos,lpBuffer})
        if index then void = c_func(xSendMessage,{hwnd,CB_SETCURSEL,pos,0}) end if

    end if

    -- update the list window
    void = c_func(xSendMessage,{hwnd,WM_SETREDRAW,1,0}) -- enable list to now update
    void = c_func(xInvalidateRect,{hwnd,NULL,0}) -- force control to repaint

end procedure




global function getCount(integer id)
atom hwnd
integer objectClass, objectType

    hwnd = ObjectHwnd[id]

    objectClass = ObjectClass[id]
    objectType = ObjectType[id]
    
    if objectClass=LIST then
        return c_func(xSendMessage,{hwnd,LB_GETCOUNT,0,0})

    elsif objectClass=COMBO then
        return c_func(xSendMessage,{hwnd,CB_GETCOUNT,0,0})

    elsif objectType=TabControl then
        return c_func(xSendMessage,{hwnd,TCM_GETITEMCOUNT,0,0})

    elsif objectType=StatusBar then
        return c_func(xSendMessage,{hwnd,SB_GETPARTS,0,0})

    else
        -- oops

    end if

end function



global function findItem(integer id, sequence text, integer pos)
atom lpSz, hwnd
integer objectClass

    hwnd = ObjectHwnd[id]

    lpSz = allocate_StringZ(text)

    objectClass = ObjectClass[id]
    
    if objectClass=LIST then
        pos = c_func(xSendMessage,{hwnd,LB_FINDSTRING,pos-2,lpSz})

    elsif objectClass=COMBO then
        pos = c_func(xSendMessage,{hwnd,CB_FINDSTRING,pos-2,lpSz})

    end if

    if pos>=0 then
        pos += 1
    else
        pos = 0
    end if

    return pos

end function

atom LV
     LV = allocate(sizeofstruct(LVCOLUMN))  -- permanently allocated

global function getLVSelectedCount(integer id)
    return sendMessage(id, LVM_GETSELECTEDCOUNT, 0, 0)
end function

global function getLVSelected(integer id)
integer count, start
sequence selections

    selections = {}

    count = getLVSelectedCount(id)

    selections = repeat(0,count)
    count = 1

    poke4(LVI+LVITEM_mask,LVIF_STATE)
    poke4(LVI+LVITEM_stateMask,LVIS_SELECTED)

    start = 0
    while count<=length(selections) do
        poke4(LVI+LVITEM_iItem,start)
        if sendMessage(id, LVM_GETITEM, 0, LVI) then
            if peek4u(LVI+LVITEM_state) then
--?peek4u(LVI+LVITEM_stateMask)
                selections[count] = start+1
                count += 1
            end if
        end if
        start += 1
    end while
    return selections
end function

integer mask

global procedure insertLVColumn(integer id, sequence colinfo, integer column)
--
-- id must be a ListView control.
-- colinfo is: {text,   (eg "Name")
--              width,  (eg 100)
--              align}  (ie LVCFMT_LEFT, LVCFMT_CENTER, or LVCFMT_RIGHT)
-- column is 1-based
--

    if ObjectType[id]!=ListView then ?9/0 end if

    mem_set(LV, 0, sizeofstruct(LVCOLUMN))

    mask = LVCF_SUBITEM
    if length(colinfo[1]) then
        mask = or_bits(mask, LVCF_TEXT)
        poke4(LV + LVCOLUMN_pszText,allocate_StringZ(colinfo[1]))
    end if
    if colinfo[2] then
        mask = or_bits(mask, LVCF_WIDTH)
    end if
    if colinfo[3]!=0 then
        mask = or_bits(mask, LVCF_FMT)
    end if
    poke4(LV + LVCOLUMN_mask, mask)
    poke4(LV + LVCOLUMN_cx, colinfo[2])
    poke4(LV + LVCOLUMN_fmt, colinfo[3])
    poke4(LV + LVCOLUMN_iSubItem, column-1)

    void = sendMessage(id,LVM_INSERTCOLUMN,column-1,LV)

    ObjectExtra[id][2] = column

end procedure

--integer vNextLVid
--      vNextLVid=0

--global function insertLVItems(integer id, sequence data)
---- adds everything to the end of the list.
----DEV
---- DEFUNCT: see demo_listviews.exw vs. demo_listviews_old.exw
--integer last
--sequence oneRow
--  if ObjectType[id]!=ListView then ?9/0 end if
--
--  mem_set(LVI, 0, sizeofstruct(LVITEM))
--  poke4(LVI + LVITEM_mask, LVIF_TEXT+LVIF_PARAM)
--  last = sendMessage(id, LVM_GETITEMCOUNT, 0, 0)
----    void = sendMessage(id, LVM_DELETEALLITEMS, 0, 0)
--  if last=0 then
--      -- I believe the list must be empty for LVM_SETITEMCOUNT.
--      -- (this does not really speed things up much anyway)
--      void = sendMessage(id, LVM_SETITEMCOUNT, length(data), 0)
--  end if
--  for row=1 to length(data) do
--      oneRow = data[row]
--      for j=1 to length(oneRow) do
--          if not sequence(oneRow[j]) then
--              oneRow[j] = sprintf("%g",oneRow[j])
--          end if
--      end for
--      poke4(LVI + LVITEM_iItem, last + row-1)
--      poke4(LVI + LVITEM_iSubItem, 0)
--      vNextLVid += 1
--      poke4(LVI + LVITEM_lParam, vNextLVid)
--      poke4(LVI + LVITEM_pszText, allocate_StringZ(oneRow[1]))
--      void = sendMessage(id,LVM_INSERTITEM,0,LVI)
--
--      for col=2 to length(oneRow) do
--          poke4(LVI + LVITEM_iSubItem, col-1)
--          poke4(LVI + LVITEM_pszText, allocate_StringZ(oneRow[col]))
--          void = sendMessage(id,LVM_SETITEMTEXT,last+row-1,LVI)
--      end for
--  end for
--
--  return 1
--end function

global procedure setLVItemCount(integer id, integer count)
    void = sendMessage(id, LVM_DELETEALLITEMS, 0, 0)
    void = sendMessage(id, LVM_SETITEMCOUNT, count, 0)
    ObjectExtra[id][3]=0    -- no current record.
end procedure

--constant LVtext = allocate(256)

global function getLVItem(integer id, integer pos)
integer ncols
sequence res
integer frtn

    if ObjectType[id]!=ListView then ?9/0 end if
    if pos=0 then
--      pos = getIndex(id)  -- works, however below is the same but faster.
        pos = ObjectExtra[id][3]    -- saved in WM_NOTIFY
        if pos=0 then return -1 end if
    end if
    ncols = ObjectExtra[id][2]
    frtn = ObjectExtra[id][4]   -- format routine
    res = repeat(0,ncols)
    for j=1 to ncols do
--      poke4(LVI + LVITEM_iItem, pos-1)
--      poke4(LVI + LVITEM_iSubItem, j-1)
--      poke4(LVI + LVITEM_pszText, LVtext)
--      poke4(LVI + LVITEM_cchTextMax, 255)
--      void = sendMessage(id, LVM_GETITEMTEXT, pos-1, LVI)
--      res[j] = peek_string(LVtext)
        res[j] = call_func(frtn,{pos,j})
    end for
    return res
end function

global procedure resizeLVColumns(integer lvid)
--
-- Proportionally resize a listview's columns to fit the entire width,
--  always assuming/leaving space for a vertical scrollbar. Unless the
--  Alt key is held down, in which case no (column) resizing occurs.
-- lvid must, of course, be a ListView (undefined behaviour if not)
--
integer x, width
sequence c0
integer ctot
integer c1, c2, cnew, crem
--/*
sequence tmp
--*/

    c0 = {}
    ctot = 0
    c1 = 10
    if not getKeyState(VK_MENU) then    -- Alt key not depressed
--/**/  {x,?,width} = getClientRect(lvid)
--/*
        tmp = getClientRect(lvid)
        x = tmp[1]
        width = tmp[3]
--*/
        width -= x
        for i=1 to 20 do -- sensible limit (on max no of columns)
            c1 = sendMessage(lvid,LVM_GETCOLUMNWIDTH,i-1,0)
            if c1=0 then exit end if
            c0 &= c1
            ctot += c1
        end for
        if c1=0 then -- (if we read all the columns)
--          cnew = width-8-18
--          cnew = width-18
            cnew = width
            crem = ctot
            void = sendMessage(lvid,WM_SETREDRAW,0,0)
            for i=1 to length(c0) do
                c1 = c0[i]
                c2 = floor((c1/crem)*cnew+0.5)
                void = sendMessage(lvid,LVM_SETCOLUMNWIDTH,i-1,c2)
                crem -= c1
                cnew -= c2
            end for
            void = sendMessage(lvid,WM_SETREDRAW,1,0)
        end if
    end if
end procedure

global procedure setLVFormatRoutine(integer id, integer rtnid)
    ObjectExtra[id][4] = rtnid
end procedure

constant TVIS = allocate(sizeofstruct(TVINSERTSTRUCT))

    mem_set(TVIS,0,sizeofstruct(TVINSERTSTRUCT))
    poke4(TVIS + TVINSERTSTRUCT_hInsertAfter,TVI_LAST)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_mask,TVIF_TEXT+TVIF_IMAGE+TVIF_SELECTEDIMAGE+TVIF_PARAM+TVIF_CHILDREN)
--  poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_hItem,NULL)
--  poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_state,NULL)
--  poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_stateMask,NULL)
--  poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_iImage,0)
 -- poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_cChildren,0)

global procedure setTVInsertMode(atom mode)
-- mode should be TVI_LAST (initial default), TVI_FIRST, TVI_SORT, or
-- the handle to the item it should be inserted after.
    poke4(TVIS + TVINSERTSTRUCT_hInsertAfter,mode)
end procedure

global function addTVItem(integer id, atom hParen, integer tIdx, integer iImage, integer iSel, integer cChildren)
-- result is a handle to the inserted item (atom)
-- id is a TreeView Control
-- hParam is NULL or the result from a previous addTVItem call
-- iImage is a (0-based) index to the imagelist.
-- nChild should be zero for leaf items, non-zero (but not necessarily correct) if it
--  has children (and should be expandable)
    poke4(TVIS + TVINSERTSTRUCT_hParent,hParen)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_pszText,LPSTR_TEXTCALLBACK)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_iImage,iImage)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_iSelectedImage,iSel)
--  poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_lParam,hParen)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_lParam,tIdx)
    poke4(TVIS + TVINSERTSTRUCTITEM + TVITEM_cChildren,cChildren)
    return sendMessage(id,TVM_INSERTITEM,0,TVIS)
end function

global procedure deleteTVItem(integer id, atom hItem)
-- deletes the specified item from the treeview, or the entire treeview
-- if TVI_ROOT is passed. Note that after erasing the entire treeview,
-- you should *immediately* insert something, else it hangs.
    void = sendMessage(id,TVM_DELETEITEM,0,hItem)
end procedure

constant TVI=allocate(sizeofstruct(TVITEM))
    mem_set(TVI,0,sizeofstruct(TVITEM))

--constant txtbuf=allocate(256)

--function getTVPath(integer id, atom hItem, integer fullpath)
---- get the path of the treeview item
--atom hParent
--sequence res
--  poke4(TVI + TVITEM_mask, TVIF_PARAM)
--  poke4(TVI + TVITEM_hItem,hItem)
--  void = sendMessage(id,TVM_GETITEM,0,TVI)
--?9/0
--  hParent = peek4s(TVI + TVITEM_lParam)
--  if hParent then
--      res = getTVPath(id,hParent,fullpath)
--  else
--      res = ""
--  end if
--  poke4(TVI + TVITEM_mask, TVIF_TEXT)
--  poke4(TVI + TVITEM_hItem,hItem)
--  poke4(TVI + TVITEM_pszText,txtbuf)
--  poke4(TVI + TVITEM_cchTextMax,255)
--  void = sendMessage(id,TVM_GETITEM,0,TVI)
--  if fullpath=2 then
--      if length(res) then
--          return append(res,peek_string(txtbuf))
--      end if
--      return {peek_string(txtbuf)}
--  end if
--  return res&peek_string(txtbuf)&'\\'
--end function
--
--global function getTVText(integer id, integer fullpath)
---- gets the text of the treeview item, optionally returning the full tree path.
---- If fullpath is 0, the result is eg "ascii.bat";
---- if fullpath is 1, the result is eg "C:\\Euphoria\\bin\\ascii.bat";
---- if fullpath is 2, the result is eg {"C:\\Euphoria","bin","ascii.bat"}
----   (in demo_treeviews.exw, "C:\\Euphoria" is the "root" of the tree).
--atom hParent
--sequence res
--  res=""
--  if fullpath then
--      poke4(TVI + TVITEM_mask, TVIF_PARAM)
--      poke4(TVI + TVITEM_hItem,getIndex(id))
--      void = sendMessage(id,TVM_GETITEM,0,TVI)
--      hParent = peek4s(TVI + TVITEM_lParam)
--      if hParent then
--          res = getTVPath(id,hParent,fullpath)
--      end if
--  end if
--  poke4(TVI + TVITEM_mask, TVIF_TEXT)
--  poke4(TVI + TVITEM_hItem,getIndex(id))
--  poke4(TVI + TVITEM_pszText,txtbuf)
--  poke4(TVI + TVITEM_cchTextMax,255)
--  void = sendMessage(id,TVM_GETITEM,0,TVI)
--  if fullpath=2 then
--      if length(res) then
--          return append(res,peek_string(txtbuf))
--      end if
--      return {peek_string(txtbuf)}
--  end if
--  return res&peek_string(txtbuf)
--end function

--global procedure setTVIndex(integer id, atom hItem)
--  ObjectExtra[id][3] = hItem
--end procedure

--global function isTVChecked(integer id)
global function isTVChecked(integer id, atom hItem)
-- returns true if the specified treeview item
-- is checked, false otherwise.
    poke4(TVI + TVITEM_mask, TVIF_STATE)
    poke4(TVI + TVITEM_hItem, hItem)
    void = sendMessage(id,TVM_GETITEM,0,TVI)
    return (and_bits(peek4s(TVI + TVITEM_state),#2000)!=0)
end function

global procedure setTVCheck(integer id, atom hItem, integer flag)
-- sets the checkbox on the specified treeview item
    poke4(TVI + TVITEM_mask, TVIF_STATE)
    poke4(TVI + TVITEM_hItem, hItem)
    poke4(TVI + TVITEM_stateMask,#3000)     -- update ON/OFF bits
    if flag then
        poke4(TVI + TVITEM_state,#2000)     -- ON=true, (AND! off=false!)
    else
        poke4(TVI + TVITEM_state,#1000)     -- OFF=true, (AND! on=false!)
    end if
    void = sendMessage(id,TVM_SETITEM,0,TVI)
end procedure

--global procedure clearTVChildCount(integer id, atom hItem)
---- used by demo_treeviews, possibly bogus (see demo_treeviews' comments).
--  poke4(TVI + TVITEM_mask, TVIF_CHILDREN)
--  poke4(TVI + TVITEM_hItem, hItem)
--  poke4(TVI + TVITEM_cChildren, 0)
--  void = sendMessage(id,TVM_SETITEM,0,TVI)
--end procedure
--with trace

global function getTVChildFlag(integer id, atom hItem)
    poke4(TVI + TVITEM_mask, TVIF_CHILDREN)
    poke4(TVI + TVITEM_hItem, hItem)
    void = sendMessage(id,TVM_GETITEM,0,TVI)
    return peek4s(TVI +TVITEM_cChildren)
end function

global procedure setTVChildFlag(integer id, atom hItem, integer flag)
-- specify whether tree item has children (a '+' next to it)
    poke4(TVI + TVITEM_mask, TVIF_CHILDREN)
    poke4(TVI + TVITEM_hItem, hItem)
    poke4(TVI + TVITEM_cChildren, flag)
    void = sendMessage(id,TVM_SETITEM,0,TVI)
end procedure

global integer iSelectedImage
global function getTVicon(integer id, atom hItem)
-- get associated image list index for treeview item
    poke4(TVI + TVITEM_mask, TVIF_IMAGE+TVIF_SELECTEDIMAGE)
    poke4(TVI + TVITEM_hItem, hItem)
    void = sendMessage(id,TVM_GETITEM,0,TVI)
    iSelectedImage = peek4s(TVI +TVITEM_iSelectedImage)
    return peek4s(TVI +TVITEM_iImage)
end function

--global function setTVicon(integer id, atom hItem, integer iImage)
---- set associated image list index for treeview item
--  poke4(TVI + TVITEM_mask, TVIF_IMAGE)
--  poke4(TVI + TVITEM_hItem, hItem)
--  poke4(TVI + TVITEM_iImage,iImage)
--  return sendMessage(id,TVM_SETITEM,0,TVI)
--end function

global function getScrollInfo(object id)
integer fnBar
atom hwnd, lpsi, min, max, page, pos

    -- deal with TrackBars first
    if integer(id) and ObjectClass[id]=TRACKBAR then
        hwnd = ObjectHwnd[id]
        min =  c_func(xSendMessage,{hwnd,TBM_GETRANGEMIN,0,0})
        max =  c_func(xSendMessage,{hwnd,TBM_GETRANGEMAX,0,0})
        page = c_func(xSendMessage,{hwnd,TBM_GETPAGESIZE,0,0})
        pos =  c_func(xSendMessage,{hwnd,TBM_GETPOS,0,0})
        return {min, max, page, pos}
    end if

    -- sort out where builtin scroll bars are referred to
    if sequence(id) then
        fnBar = id[2] 
        id = id[1]
    else
        fnBar = SB_CTL
    end if

    -- get handle
    hwnd = ObjectHwnd[id]

    -- allocate space for the structure
    lpsi = allocate_Scroll()

    -- set this member to retrieve all parameters
    poke4(lpsi + SCROLLINFO_cbSize, sizeofstruct(SCROLLINFO))
    poke4(lpsi + SCROLLINFO_fMask, SIF_ALL)

    -- make the call and retrieve the parameters if call is successfull
    if c_func(xGetScrollInfo, {hwnd, fnBar, lpsi}) then

        return peek4u({lpsi+SCROLLINFO_nMin,5}) -- returns {min, max, page, pos, trackpos}

    else

        return 0 -- failure

    end if

end function


global procedure setScrollInfo(object id,  object settings, integer fRedraw)
-- settings is a sequence [Min]MaxPagePosTrack for scroll bars
-- or MinMax[PagePos] for track bars, NB: line size is 1 for TrackBars unless user sends message to do other
-- or MinMax[StepPos] for ProgressBars
integer fnBar, len, objectClass
atom lpsi, hwnd, cmpdRange

    if integer(id) then
        objectClass = ObjectClass[id]
        if objectClass=TRACKBAR then
            hwnd = ObjectHwnd[id]
            len = length(settings)
            if len > 2 then void = c_func(xSendMessage,{hwnd,TBM_SETPAGESIZE,0,settings[3]}) end if
            if len > 3 then void = c_func(xSendMessage,{hwnd,TBM_SETPOS,     0,settings[4]}) end if
            void = c_func(xSendMessage,{hwnd,TBM_SETRANGEMIN,False,  settings[1]})
            void = c_func(xSendMessage,{hwnd,TBM_SETRANGEMAX,fRedraw,settings[2]})
            return
        elsif objectClass=PROGRESSBAR then
            hwnd = ObjectHwnd[id]
            len = length(settings)
            if len>2 then void = c_func(xSendMessage,{hwnd,PBM_SETSTEP, settings[3],0}) end if
            if len>3 then void = c_func(xSendMessage,{hwnd,PBM_SETPOS,  settings[4],0}) end if
            -- min & max must be 0->65535
            cmpdRange = settings[1] + settings[2] * #10000
            void = c_func(xSendMessage,{hwnd, PBM_SETRANGE, 0, cmpdRange})
            return
        elsif objectClass=UP_DOWN then
            hwnd = ObjectHwnd[id]
            void = c_func(xSendMessage,{hwnd,UDM_SETRANGE32,settings[1],settings[2]})
            return
        end if
    end if

    -- sort out references to builtin scroll bars
    if sequence(id) then
        fnBar = id[2]
        id = id[1]
    else
        fnBar = SB_CTL
    end if

    -- get the handle
    hwnd = ObjectHwnd[id]

    -- allocate space for the structure
    lpsi = allocate_Scroll()

    -- populate the structure to present the 5 parameters
    poke4(lpsi + SCROLLINFO_cbSize, sizeofstruct(SCROLLINFO))
    poke4(lpsi + SCROLLINFO_fMask,  SIF_ALL)-- THIS WAS PREVIOUSLY ONE OF THE routine parameters
    poke4(lpsi + SCROLLINFO_nMin,       settings) -- single call to insert up to 5 values (MinMaxPagePosTrack)
--  poke4(lpsi + SCROLLINFO_nMax,       max)
--  poke4(lpsi + SCROLLINFO_nPage,  page)
--  poke4(lpsi + SCROLLINFO_nPos,       pos)
--  poke4(lpsi + SCROLLINFO_nTrackPos, trackpos)

    -- make the function call
    void = c_func(xSetScrollInfo, {hwnd, fnBar, lpsi, fRedraw})

end procedure


global function getPos(object id) -- return the position of: ScrollBar, TrackBar or ProgressBar
integer objectClass

    if sequence(id) then -- assume a builtin scroll bar
        -- id MUST be {WinID, flag} where Flag is either SB_HORZ or SB_VERT
        return c_func(xGetScrollPos,{getParentHwnd(id[1]),id[2]})

    end if
    objectClass = ObjectClass[id]
    -- must be a stand-alone control
    if objectClass=SCROLLBAR then -- scroll bar
        return c_func(xGetScrollPos,{ObjectHwnd[id],SB_CTL})

    elsif objectClass=TRACKBAR then -- track bar
        return sendMessage(id,TBM_GETPOS,0,0)

    elsif objectClass=PROGRESSBAR then -- progress bar
        return sendMessage(id,PBM_GETPOS,0,0)

    end if

    return 0

end function


global procedure setPos(object id, atom pos)
    -- set the position of a trackbar or progressbar
atom hwnd, fnBar, lpsi
integer objectClass

    if integer(id) then -- standalone controls

        objectClass = ObjectClass[id]

        if objectClass=TRACKBAR then
            void = c_func(xSendMessage,{ObjectHwnd[id],TBM_SETPOS,0,pos})
            return

        elsif objectClass=PROGRESSBAR then
            void = c_func(xSendMessage,{ObjectHwnd[id],PBM_SETPOS,pos,0})
            return

        end if

    end if

    --NB: stand-alone scroll control will fall through to this point

    -- deal to all kinds of scroll bars from here
    -- sort out where builtin scroll bars are referred to
    if sequence(id) then
        fnBar = id[2]
        id = id[1]
    else
        fnBar = SB_CTL
    end if

    -- get handle
    hwnd = ObjectHwnd[id]

    -- allocate space for the structure
    lpsi = allocate_Scroll()

    -- set this member to retrieve all parameters
    poke4(lpsi + SCROLLINFO_cbSize, sizeofstruct(SCROLLINFO))
    poke4(lpsi + SCROLLINFO_fMask,  SIF_ALL)

    -- attempt to get the scroll parameters
    if not c_func(xGetScrollInfo, {hwnd, fnBar, lpsi}) then
        return
    end if

    -- populate the structure to re-present the parameters
    poke4(lpsi + SCROLLINFO_cbSize, sizeofstruct(SCROLLINFO))
    poke4(lpsi + SCROLLINFO_fMask,  SIF_ALL)

    -- poke the new value
    poke4(lpsi + SCROLLINFO_nPos,       pos)
    poke4(lpsi + SCROLLINFO_nTrackPos, pos)

    -- make the function call to set it all in place
    void = c_func(xSetScrollInfo, {hwnd, fnBar, lpsi, 1}) -- automatically updates scroll bar, unlike setScrollInfo

end procedure


global function makeProgress(integer id)
    -- advance the progress bar one more step. when the max range is exceeded then will reset back to min
    -- returns prev position
    return sendMessage(id,PBM_STEPIT,0,0)
end function


----------------------------------------------------------------------------

procedure subClassControl(integer id, atom hwnd)
atom PrevWndProc
integer objType

    -- certain control types do not get subclassed
    objType = ObjectType[id]
--  if objType=StaticBitmap or objType=Window then--or objType=HyperText then
    if objType=StaticBitmap or objType=Window or objType=ReBarBand then--or objType=HyperText then
        return
    end if

    -- abort if control already subclassed
    if SubProcAddress[id]!=UNDEFINED then
        FatalErr("Control already subclassed.")
    end if

    -- store WndProcAddress & SubProcAddress
    PrevWndProc = c_func(xSetWindowLong,{hwnd,GWL_WNDPROC,SubProcCallBack})
    WndProcAddress[id] = PrevWndProc
    SubProcAddress[id] = SubProcCallBack

end procedure


procedure unsubClassControl(integer id)
atom PrevWndProc
    if SubProcAddress[id]=UNDEFINED then
        return
    end if
    PrevWndProc = WndProcAddress[id]
    void = c_func(xSetWindowLong,{ObjectHwnd[id],GWL_WNDPROC,PrevWndProc})
    SubProcAddress[id] = UNDEFINED
end procedure


-----------------------------------------------------------------------------

global procedure setHandler(object id, integer r_id)
    if integer(id) then
        if id=IDLE then
            IDLEROUTINE = r_id
        else
            HandlerRoutine[id] = r_id
        end if
    else -- set a sequence of id's
        for i=1 to length(id) do
            setHandler( id[i], r_id)
        end for
    end if
end procedure

-----------------------------------------------------------------------------

global function createTimer()
    return addControl(Timer, UNDEFINED, 0, "", 0)
end function


global procedure startTimer(integer TimerId, integer OwnerId, integer msec)
atom pHwnd

    -- ERROR CHECK, can't start a timer before it's previous session has finished
    if ObjectParent[TimerId]!=UNDEFINED then
        void = messageBox("Application Error",sprintf("Timer control %d already started.",TimerId),0)
        return
    end if

    ObjectParent[TimerId] = OwnerId

    pHwnd = ObjectHwnd[OwnerId]

    c_proc(xSetTimer,{pHwnd,TimerId,msec,NULL})

end procedure


global procedure stopTimer(integer id)
atom pHwnd

    if ObjectParent[id]=UNDEFINED then
        return
    end if

    pHwnd = getParentHwnd(id)

    c_proc(xKillTimer, {pHwnd, id})

    ObjectParent[id] = UNDEFINED

end procedure



global procedure setStatusWidths(integer id, object fieldwidths)
integer temp, len, pID, objectType
atom intArray
sequence children

    objectType = ObjectType[id]

    -- id could be child or parent so get real parent control id
    if objectType=StatusBar then
        pID = id
    elsif objectType=StatusField then
        pID = ObjectParent[id]
    else
        WarnErr("Non-Status control referenced.")
        return
    end if

    -- if a single field is referred to then retrieve widths of all sub fields to refresh them
    if integer(fieldwidths) then
        len = fieldwidths
        children = pID & ObjectChildren[pID] -- children is here used as a temp sequence for the id's
        temp = find(id, children)
        if not temp then
            WarnErr("Could not find Status control id within ObjectChildren[].")
            return
        end if
        -- convert seq of id's into their field widths and update for new value
        fieldwidths = repeat(0, length(children))
        for i=1 to length(children) do
            fieldwidths[i] = ObjectExtra[children[i]] -- fieldwidths now has widths
        end for
        fieldwidths[temp] = len -- insert new value
    end if

    len = length(fieldwidths)

    -- check length of sequence
    if len!=length(ObjectChildren[pID])+1 then
        WarnErr("Sequence containing widths of StatusFields does not match Parent control info.")
        return
    end if

    -- convert relative values to absolute values
    for i=2 to len do
        temp = fieldwidths[i]
        if temp then
            temp += fieldwidths[i-1]
        end if
        fieldwidths[i] = temp
    end for

    -- convert to 0-based
--  fieldwidths -= 1
--  fieldwidths = sq_add(fieldwidths,-1)
    for i=1 to length(fieldwidths) do
        fieldwidths[i] = fieldwidths[i]-1
    end for

    -- create populated integer array to be accessed via the message
    intArray = allocate_TextSpace(len * 4) -- proper use for allocate_TextSpace() here?
    poke4(intArray, fieldwidths)

    -- send the message
    void = sendMessage(pID, SB_SETPARTS, len, intArray)

end procedure




global function trackPopupMenu(integer id, integer owner, atom flags)
atom hWnd, hMenu
integer x, y
atom msg_pos

    --flags = TPM_CENTERALIGN

    -- get handles of menu & window
    hMenu = ObjectHwnd[id]
    hWnd = ObjectHwnd[owner]

    -- get the mouse position in *Screen* coords
    msg_pos = c_func(xGetMessagePos,{})
    x = and_bits(msg_pos,#FFFF)
    y = floor(msg_pos/#10000)

    return c_func(xTrackPopupMenu,{hMenu,flags,x,y,0,hWnd,NULL})

end function


global function insertMenu(object item, atom hBitmap, integer pID, integer pos, object flags)
-- insert one menu into another one at the specified position, returns id
-- OR create & insert a *NEW* menuitem into the menu, returns new id

-- if an error occurs then it returns 0

atom hMenu, lpSz, uPos, lpMII
integer id, fMask, fType, fState


    -- inserting into top-level menu? better get id of actual menu
    if ObjectType[pID]=Window then
        pID = ObjectExtra[pID][MENUBAR]
    end if

    -- get the handle of the menu to be changed
    hMenu = ObjectHwnd[pID]

    -- prepare position designator
    if pos=-1 then
        uPos = #FFFFFFFF -- designates append item
    elsif pos=0 or and_bits(flags, MF_BYPOSITION) then -- user wants to specify position
        uPos = pos - 1
    else -- user wants to specify a menuitem id
        uPos = getMenuElementPosZ(pos)
    end if

    -- flags must be atomic
    if sequence(flags) then
        flags = or_all(flags)
    end if

    -- set default and/or basic flag settings
    fMask = MIIM_TYPE+MIIM_ID+MIIM_STATE
    fType = and_bits(flags, MENUINSERTFLAGS_TYPE)
    if ISMENUOWNERDRAWN then
        fType = or_bits(fType, MFT_OWNERDRAW)
    end if

    -- allocate space for the MENUITEMINFO
    lpMII = allocate_Menu()

    -- MENUSEP
    if equal(item, "-") then
        fState = MFS_DISABLED+MFS_UNCHECKED+MFS_UNHILITE
        id = addControl(MenuSep, pID, NULL, "", 0)
        fType = or_bits(fType, MFT_SEPARATOR)
        fType = null_bits(fType, MFT_OWNERDRAW)
        fMask -= MIIM_STATE
        lpSz = 0

    else --menu or menuitem
        fState = and_bits(flags, MENUINSERTFLAGS_STATE)
        fType = or_bits(fType, MFT_STRING)

        -- MENUITEM
        if sequence(item) then
            id = addControl(MenuItem, pID, NULL, item, hBitmap)

        else -- SUBMENU
            id = item
            item = ObjectLabel[id]
            fMask += MIIM_SUBMENU
            poke4(lpMII+MII_hSubMenu,ObjectHwnd[id])
            if ObjectParent[id] and pos!=-1 then -- parent menu still exists AND is not an appendation? oops
                WarnErr("Attempt to insertMenu() was aborted because SubMenu was already owned")
                return 0
            end if

        end if

        -- common to menus & menuitems
        lpSz = allocate_StringZ(item)

    end if

    -- Set structure members
    --mem_set(lpMII,0,sizeofstruct(MENUITEMINFO)) already done by allocate_Menu()
    --poke4(lpMII+cbSize,sizeofstruct(MENUITEMINFO)) already done by allocate_Menu()
    poke4(lpMII+MII_fMask, fMask)
    poke4(lpMII+MII_fType, fType)
    poke4(lpMII+MII_fState, fState)
    poke4(lpMII+MII_wID, id)
    --poke4(lpMII+MII_hSubMenu, hSubMenu) done already
    --poke4(lpMII+MII_hbmpChecked, NULL)
    --poke4(lpMII+MII_hbmpUnchecked, NULL)
    --poke4(lpMII+MII_dwItemData, id)-- needed?
    poke4(lpMII+MII_dwTypeData, lpSz)
--  poke4(lpMII+MII_cch, sLen)


    -- Insert the item into the Menu
    if c_func(xInsertMenuItem,{hMenu,uPos,True,lpMII}) then

        -- store new parent id
        ObjectParent[id] = pID

        -- update the menu bar
        drawMenuBar(id)

        -- exit, success
        return id

    end if

    if ObjectType[id]!=Menu then -- new MenuItem or MenuSep was not created
        eraseControl(id)
    end if

    -- exit, failure
    return 0

end function


global function removeMenu(integer id)
-- A Menu will be detached from it's owner, later it can be reattached to a menu

    if not ObjectParent[id] then -- item not owned anyway
        return 0
    end if

    if ObjectType[id]=Menu then
        if c_func(xRemoveMenu,{getParentHwnd(id),getMenuElementPosZ(id),MF_BYPOSITION}) then
            -- force redraw of the menubar if needed
            drawMenuBar(id)
            ObjectParent[id] = 0
            return True
        end if

    end if

    return False

end function



global function destroyMenu(integer id)
-- Menu: destroys the menu and all associated menuitems, submenus will merely be detached
-- MenuItem: destroyed

atom hMenu
integer mcount, objectType
atom mID

    objectType = ObjectType[id]
    
    if objectType=Menu then

        hMenu = ObjectHwnd[id]

        -- first, destroy any menuitems
        mcount = c_func(xGetMenuItemCount,{hMenu})
        for i=mcount to 1 by -1 do
            mID = c_func(xGetMenuItemID,{hMenu,i-1})
            if mID!=#FFFFFFFF then -- valid id obtained
                if ObjectType[mID]=Menu then
                    void = removeMenu(mID)
                else
                    void = destroyMenu(mID)
                end if
            end if
        end for

        -- second, destroy the menu
        void = c_func(xDestroyMenu,{hMenu})
        eraseControl(id)
        return True

    elsif objectType=MenuItem
       or objectType=MenuSep then

        void = c_func(xRemoveMenu,{getParentHwnd(id),id,MF_BYCOMMAND})
        eraseControl(id)
        return True

    end if

    return False

end function



------------------------------------------------------------------------

function createMenu(integer pID, sequence text, atom hBitmap, object flags)

integer id
atom hMenu, hPopup

    -- ensure flags are in a single atom
    if sequence(flags) then
        flags = or_all(flags)
    end if

    -- NEED TO MAKE A WINDOW MENU FIRST?
    -- if owner exists and is a menuless window then must create a menubar first
    if pID 
    and ObjectType[pID]=Window 
    and ObjectExtra[pID][MENUBAR]=UNDEFINED then

        -- make a menubar
        hMenu = c_func(xCreateMenu,{})
        if hMenu=NULL then
            WarnErr("Window MenuBar could not be created")
            return 0
        end if

        -- attach it to the window
        if not c_func(xSetMenu,{ObjectHwnd[pID],hMenu}) then
            void = c_func(xDestroyMenu,{hMenu})
            WarnErr("MenuBar could not be attached to window")
            return 0
        end if

        -- create new object and set variables
        id = addControl(Menu, pID, hMenu, "", 0) --NB: this hidden menu does not have a name
        -- set the id into Annexa of owner window
        ObjectExtra[pID][MENUBAR] = id

    end if

    -- VERY IMPORTANT, ensure correct parent menu is referenced
    if pID and ObjectType[pID]=Window then
        pID = ObjectExtra[pID][MENUBAR]
    end if

    -- ATTEMPT TO MAKE A POPUP MENU
    hPopup = c_func(xCreatePopupMenu,{})

    -- no, exit
    if not hPopup then
        WarnErr("Popup Menu could not be created.")
        return 0
    end if

    -- get id for new menu & set the menu text
    id = addControl(Menu, pID, hPopup, text, hBitmap)

    -- exit if menu is not yet owned
    if not pID then
        return id
    end if

    -- append the menu to an owner, NB: insertMenu() also sets the ownerdrawn flag
    id = insertMenu(id, hBitmap, pID, -1, flags)


    -- exit
    return id

end function


function createTabItem(integer pID, sequence text, atom imgIndex, atom flags)
integer tcount, id, len
atom lpTC_ITEM, lpSz

    if flags then end if    --DEV suppress warning

    -- get the number of items in the parent Tab Control
    tcount = sendMessage(pID, TCM_GETITEMCOUNT, 0, 0)

    -- reserve space for the structure & text label
    len = sizeofstruct(TC_ITEM)
    lpTC_ITEM = allocate_TextSpace(len)
    mem_set(lpTC_ITEM, 0, len)

    lpSz = allocate_StringZ(text)

    -- get the new id for the tab item
    id = addControl(TabItem, pID, NULL, text, imgIndex)

    if imgIndex then
        if ObjectImage[pID]=0 then
            void = sendMessage(pID,TCM_SETIMAGELIST,0,hILsmall)
            ObjectImage[pID] = hILsmall
        end if
    end if

    -- fill the structure
    poke4(lpTC_ITEM + TC_ITEM_mask,         TCIF_TEXT+TCIF_IMAGE)
    poke4(lpTC_ITEM + TC_ITEM_pszText,      lpSz)
    poke4(lpTC_ITEM + TC_ITEM_cchTextMax,   length(text)+1)
    poke4(lpTC_ITEM + TC_ITEM_iImage,       imgIndex-1)
    poke4(lpTC_ITEM + TC_ITEM_lParam,       id)

    -- attempt to insert a new tab item
    if sendMessage(pID, TCM_INSERTITEMA, tcount, lpTC_ITEM)=-1 then
        eraseControl(id)
        return 0
    end if

    return id

end function



function registerClass(sequence classname, atom classstyle, atom wndproc, atom icon_handle, atom cursor_handle, atom brush)
atom szAppName
atom wndclass
atom regdclass

    -- construct & populate a WNDCLASSEX structure
    szAppName = allocate_StringZ(classname)
    wndclass = allocate(sizeofstruct(WNDCLASSEX))
    poke4(wndclass + WNDCLASSEX_cbSize,             sizeofstruct(WNDCLASSEX))
    poke4(wndclass + WNDCLASSEX_style,              classstyle)
    poke4(wndclass + WNDCLASSEX_lpfnWndProc,        wndproc) -- default message handler
    poke4(wndclass + WNDCLASSEX_cbClsExtra,         0) -- no more than 40 bytes for win95
    poke4(wndclass + WNDCLASSEX_cbWndExtra,         0) -- "		"      "		"        "
    poke4(wndclass + WNDCLASSEX_hInstance,          instance())
    poke4(wndclass + WNDCLASSEX_hIcon,              icon_handle)    -- (32 x 32)
    poke4(wndclass + WNDCLASSEX_hIconSm,            icon_handle)    -- (16 x 16)
    poke4(wndclass + WNDCLASSEX_hCursor,            cursor_handle)
    poke4(wndclass + WNDCLASSEX_hbrBackground,      brush)
    poke4(wndclass + WNDCLASSEX_lpszMenuName,       NULL)
    poke4(wndclass + WNDCLASSEX_lpszClassName,      szAppName)

    -- attempt to register the WNDCLASSEX structure
    regdclass = c_func(xRegisterClassEx,{wndclass})

    free(wndclass)

    return regdclass -- could be NULL at times

end function



integer nextWinClass
        nextWinClass=1
atom hwIcon
    hwIcon = c_func(xLoadIcon,{instance(),allocate_StringZ("exw")})
    if hwIcon=0 then
        hwIcon = c_func(xLoadIcon,{instance(),10})
        if hwIcon=0 then
            hwIcon = c_func(xLoadIcon,{NULL,IDI_APPLICATION})
        end if
    end if


constant RBBsize = sizeofstruct(REBARBANDINFO)

procedure addToReBarBand(integer id, integer band)
-- internal routine: final step of creating a control on a ReBarBand
--
-- Note: win32lib requires you to:
--      create a ReBar (RB),
--      create a ReBarBand (RBB) with parent RB,
--      create control C with parent **RB**,
--      addToBand(C,RBB).
--
-- whereas arwen is more direct:
--      create a ReBar (RB),
--      create a ReBarBand (RBB) with parent RB,
--      create control C with parent RBB.
--
-- (hence this routine should NOT be global)
--
-- technically win32lib has a point: ReBarBands are rather virtual,
--  and the real parent of control C is indeed the ReBar, but the
--  arwen approach is to make more logical sense, albeit not what
--  is actually going on behind the scenes.
--

integer bandIndex
sequence size, txt
atom hWndRebar, RBB

    if ObjectType[band]!=ReBarBand then ?9/0 end if
    -- (child/id can be anything, even another ReBar)

    size = getWindowRect(id)
    hWndRebar = getParentHwnd(band)
    bandIndex = c_func(xSendMessage,{hWndRebar, RB_IDTOINDEX, band, 0})
    txt = getText(id)

    RBB = allocate(RBBsize)
    poke4(RBB+REBARBANDINFO_cbSize,     RBBsize)
    poke4(RBB+REBARBANDINFO_fMask,      RBBIM_CHILD+RBBIM_CHILDSIZE+RBBIM_TEXT)
    poke4(RBB+REBARBANDINFO_fStyle,     0)
    poke4(RBB+REBARBANDINFO_clrFore,    0)
    poke4(RBB+REBARBANDINFO_clrBack,    0)
    poke4(RBB+REBARBANDINFO_lpText,     allocate_StringZ(txt))
    poke4(RBB+REBARBANDINFO_cchTextMax, length(txt))
    poke4(RBB+REBARBANDINFO_iImage,     0)
    poke4(RBB+REBARBANDINFO_hwndChild,  ObjectHwnd[id])
    poke4(RBB+REBARBANDINFO_cxMinChild, 0)
    poke4(RBB+REBARBANDINFO_cyMinChild, size[4]-size[2])
    poke4(RBB+REBARBANDINFO_cx,         size[3]-size[1])
    poke4(RBB+REBARBANDINFO_hbmBack,    0)
    poke4(RBB+REBARBANDINFO_wID,        id)
    poke4(RBB+REBARBANDINFO_cyChild,    0)
    poke4(RBB+REBARBANDINFO_cyMaxChild, 0)
    poke4(RBB+REBARBANDINFO_cyIntegral, 0)
    poke4(RBB+REBARBANDINFO_cxIdeal,    0)
    poke4(RBB+REBARBANDINFO_lParam,     0)
    poke4(RBB+REBARBANDINFO_cxHeader,   0)

    void = c_func(xSendMessage,{hWndRebar, RB_SETBANDINFO, bandIndex, RBB})
    free(RBB)

end procedure


--constant ccNames = {
--                  "LISTVIEW",
--                  "TREEVIEW",
--                  "BAR",
--                  "TAB",
--                  "UPDOWN",
--                  "PROGRESS",
--                  "HOTKEY",
--                  "ANIMATE",
--                  "DATE",
--                  "COMBOEX",
--                  "REBAR",
--                  "INTERNET",
--                  "PAGESCROLLER",
--                  "NATIVEFNTCTL"
--                 }

integer ccinit
        ccinit = 0

global procedure CCinit()
integer dwICC, ICCsize
atom ICC
--sequence lNames
if ccinit=0 then
    ccinit = 1
    ICCsize = sizeofstruct(INITCOMMONCONTROLSEX)
    ICC = allocate(ICCsize)
--
--  lNames = {}
    poke4(ICC+INITCOMMONCONTROLSEX_dwSize, ICCsize)
    dwICC = 1
--  for i=1 to length(ccNames) do
    for i=1 to 14 do
        poke4(ICC+INITCOMMONCONTROLSEX_dwICC, dwICC)
        if c_func(xInitCommonControlsEx, {ICC})=0 then
--          lNames &= '\t' & ccNames[i] & '\n'
--          ?ccNames[i]
            WarnErr(sprintf("Common control initialisation %d failed.",i))
        end if
        dwICC *= 2
    end for
--  if length(lNames)>0 then
--      WarnErr("The following Common Control Classes cannot be used...\n" &
--              lNames & "\nYou may need to install the latest 'comctl32.dll'")
--  end if
    free(ICC)
end if
end procedure



global function create(integer objType, object lbl, object hBitmap, atom pID, atom x, atom y, atom nWidth, atom nHeight, object style)

    -- nb: 'face' represents either the text label or is a handle to a bitmap image

atom pHwnd, hwnd, lpszClassName, lpszWindowName, lpRect, hFont, lpStruct
object dwStyle, dwExStyle
sequence classname, styles
integer id, junk, scroll_flag, objectClass

    -- subclassing edit controls of combo boxes
atom scHwnd, tmp
integer scID

object lvColumns
atom lvStyleEx

integer mask
integer rbbID

sequence createWindowParams
integer eCode, ePrev

atom RBB
--DEV:
--atom dbg

    rbbID = 0       -- PL 20/5/09 ReBar(Band) handling
    if pID then
        if ObjectType[pID]=ReBarBand then
            rbbID = pID                             -- properly added to band later
            pID = ObjectParent[pID]
        elsif ObjectType[pID]=ReBar then
            if objType!=ReBarBand then ?9/0 end if  -- (see note in addToReBarBand)
        end if
    end if


-------------------------------------
-- specifically deal to Menu elements
-------------------------------------

    if objType=Menu then
        return createMenu(pID, lbl, hBitmap, style)

    elsif objType=MenuItem then
        return insertMenu(lbl, hBitmap, pID, -1, style)

    end if

---------------------------
-- PREPARE DEFAULT SETTINGS
---------------------------

    -- prepare style flags
    lvStyleEx = 0
    if sequence(style) then
        dwStyle = style[1]
        dwExStyle = style[2]
        if sequence(dwStyle) then
            dwStyle = or_all(dwStyle)
        end if
        if sequence(dwExStyle) then
            dwExStyle = or_all(dwExStyle)
        end if
        if objType=ListView then
            lvStyleEx = dwExStyle
            dwExStyle = 0
        end if
    else
        dwStyle = style
        dwExStyle = 0
    end if
    styles = getClassStyles(objType)
--if objType=TabControl then
--  ?styles
--end if
    dwStyle = or_bits(dwStyle, styles[1])
    dwExStyle = or_bits(dwExStyle, styles[2])

    -- get valid parent handle
    if pID then
        pHwnd = ObjectHwnd[pID]
    else
        pHwnd = NULL
    end if

    -- get class name
    classname = getClassName(objType)

-------------------------
-- PRE-CREATION SETTINGS
-------------------------


    -- TABITEM - TabItems are dealt with entirely from here (create a tab item, ie, a tab on a tab control)
    if objType=TabItem then
        -- make the control
        id = createTabItem(pID, lbl, hBitmap, style)
        -- store id with the parent tab control
        if id then
            ObjectExtra[id] = 1 -- default setting is "enabled"
--          ObjectChildren[pID] &= id
            ObjectChildren[pID] = ObjectChildren[pID] & id  -- 2.4 bug
            void = setAccelerator(id, lbl) --PL
            setTextColour(id, Black)
        end if
        -- exit
        return id

    -- TAB-OWNED CONTROL
    elsif pID and ObjectType[pID]=TabItem then
        -- adjust the coordinate values to properly sit in the client area of the tab control
        hwnd = ObjectHwnd[ObjectParent[pID]]
        lpRect = allocate_Rect()
        void = c_func(xGetClientRect,{hwnd,lpRect})
        void = c_func(xSendMessage,{hwnd,TCM_ADJUSTRECT,0,lpRect})
        x += peek4s(lpRect)
        y += peek4s(lpRect+4)
        -- make the control but the 'grandfather' tabcontrol will be the parent, in Window's eyes
        id = create(objType, lbl, hBitmap, ObjectParent[pID], x, y, nWidth, nHeight, style)
        ObjectParent[id] = pID -- reverse wrong side-effect of above call

        -- make control invisible if it is not on the first tab
        if find(pID, ObjectChildren[ObjectParent[pID]])!=1 then
            setVisible(id, False)
        end if
        -- add control to the list maintained by the TabItem
        ObjectChildren[pID] &= id --? ObjectChildren[pID]
        -- exit
        return id

    -- TOOLBAR SEP
    elsif objType=ToolSep then
        ObjectExtra[pID] += 10 -- toolbar separator - only thing to do is advance boundary
        return 0

    -- TOOLBAR ITEM
    elsif pID and ObjectType[pID]=ToolBar then -- must be a toolbar item
        --DEV 20/5
        -- but not if the ToolBar is on a ReBar (??!!??)
        if ObjectType[ObjectParent[pID]]!=ReBar then
-- PL 27/08/13:
            tmp = x+nWidth
            ObjectExtra[pID] += x
--          x += ObjectExtra[pID]
            x = ObjectExtra[pID]
--          y = 5
--          ObjectExtra[pID] += nWidth
            ObjectExtra[pID] += tmp
        end if

    -- SCROLLBAR (H)
    elsif objType=HScroll then
        scroll_flag = and_bits(dwStyle, SBS_BOTTOMALIGN)
        dwStyle = xor_bits(dwStyle, scroll_flag)
        if scroll_flag and not nHeight then
            nHeight = c_func(xGetSystemMetrics,{SM_CYHSCROLL})
        end if

    -- SCROLLBAR (V)
    elsif objType=VScroll then
        scroll_flag = and_bits(dwStyle, SBS_RIGHTALIGN)
        dwStyle = xor_bits(dwStyle, scroll_flag)
        if scroll_flag and not nWidth then
            nWidth = c_func(xGetSystemMetrics,{SM_CXVSCROLL})
        end if

    -- STATUSBAR
    elsif objType=StatusBar then
        if sequence(style) and length(style)=3 and style[3]=0 then
            dwStyle -= and_bits(dwStyle,SBARS_SIZEGRIP)
        end if
        --dwStyle = or_bits(dwStyle, SBARS_SIZEGRIP) -- force the size grip to always exist

    -- STATUSFIELD -- dealt with entirely from here
    elsif objType=StatusField then
        id = addControl(StatusField, pID, NULL, lbl, hBitmap)
        ObjectChildren[pID] &= id
        ObjectExtra[id] = nWidth
        setStatusWidths(id, nWidth)
        return id

    -- WINDOW
    elsif objType=Window then

        classname &= sprintf("%d",nextWinClass)
        nextWinClass += 1
        -- register new class if very first Window
--      if PrimaryWindowID=UNDEFINED then
        if not registerClass(classname,
                             vWindowClassStyle,
                             WndProcCallBack,
                             hwIcon,
                             loadCursor(IDI_APPLICATION),
                             COLOR_BTNFACE+1) then  -- NB: other brushes have restrictions
                                                    --  (see GetStockObject in win32.hlp)
            FatalErr("Registration of new window class: "& classname &" failed.")
        end if
--      end if

        if pID then
            dwStyle = or_bits(dwStyle, WS_CLIPSIBLINGS)
        end if

    elsif objType=ListView then
        lvColumns = lbl
        lbl = ""

    elsif objType=ReBar then
        if not ccinit then CCinit() end if

    end if


----------------------
---- PICTURE CONTROLS?
----------------------
--  -- deal with picture controls (currently all picturebuttons plus static bitmaps)
--  -- update: Now Menus, MenuItems, TabItems, Windows
--  if isPictCtrl(objType) then
--      hBitmap = face
--      lbl = ""
--  else -- all other controls
--      hBitmap = 0
--      lbl = face
--  end if


----------------------
-- CREATE THE CONTROLS
----------------------

    -- allocate space for strings & call creation routine
    lpszClassName = allocate_StringZ(classname)
    lpszWindowName = allocate_StringZ(lbl)
    if objType=ReBarBand then
        hwnd = 0
    else
--      ?{dwExStyle,     -- extended style
--        peek_string(lpszClassName),   -- window class name
--        lpszClassName,    -- window class name
--        peek_string(lpszWindowName), -- window caption or Button text etc..
--        lpszWindowName, -- window caption or Button text etc..
--        dwStyle,      -- window style
--        x,                -- initial x position
--        y,                -- initial y position
--        nWidth,       -- initial x size
--        nHeight,      -- initial y size
--        pHwnd,            -- parent window handle
--        NULL,         -- window menu handle OR user id for child windows
--        NULL,         -- program instance handle - Legacy of Win16 apps. 0 will work too.
--        NULL}         -- creation parameters
--      if getc(0) then end if

--c_proc(xSetLastError,{7})

if 01 then  -- PL 05/09/2010 (the demo program edita/f.exw failed under exw (ok on Phix)
            --                apparently because it didn't open_dll("shell32.dll")... ???)
        createWindowParams = {dwExStyle,        -- extended style
                              lpszClassName,    -- window class name
                              lpszWindowName,   -- window caption or Button text etc..
                              dwStyle,          -- window style
                              x,                -- initial x position
                              y,                -- initial y position
                              nWidth,           -- initial x size
                              nHeight,          -- initial y size
                              pHwnd,            -- parent window handle
                              NULL,             -- window menu handle OR user id for child windows
                              NULL,             -- program instance handle - Legacy of Win16 apps. 0 will work too.
                              NULL}             -- creation parameters
--?createWindowParams
        ePrev = 0
        while 1 do
            hwnd = c_func(xCreateWindowEx, createWindowParams)
            if hwnd!=NULL then exit end if
--  ERROR_TLW_WITH_WSCHILD = 1406,
--  ERROR_CANNOT_FIND_WND_CLASS = 1407,
--  ERROR_CLASS_DOES_NOT_EXIST = 1411,
            eCode = c_func(xGetLastError,{})
            if ePrev=0
            and (eCode=ERROR_CANNOT_FIND_WND_CLASS or
                 eCode=ERROR_CLASS_DOES_NOT_EXIST) then
                ePrev = eCode
                if not registerClass(classname,0,WndProcCallBack,NULL,NULL,COLOR_BTNFACE+1) then
                    -- (the [2] is just so you know it's this message not the one above)
                    FatalErr("Registration[2] of new window class: "& classname &" failed.")
                end if
            else
                printf(1,"Control creation routine failed with error code %d.\n",eCode)
--              return 0
                ?9/0
            end if
        end while

else -- old code:
        hwnd = c_func(xCreateWindowEx, {
                                        dwExStyle,      -- extended style
                                        lpszClassName,  -- window class name
                                        lpszWindowName, -- window caption or Button text etc..
                                        dwStyle,        -- window style
                                        x,              -- initial x position
                                        y,              -- initial y position
                                        nWidth,         -- initial x size
                                        nHeight,        -- initial y size
                                        pHwnd,          -- parent window handle
                                        NULL,           -- window menu handle OR user id for child windows
                                        NULL,           -- program instance handle - Legacy of Win16 apps. 0 will work too.
                                        NULL})          -- creation parameters
--?hwnd
        if hwnd=NULL then
            --?getLastError()
            ?9/0
            WarnErr("Control creation routine failed.")
            return 0
        end if
end if
    end if

    -- add new object to internally maintained object list
    id = addControl(objType, pID, hwnd, lbl, hBitmap)
    objectClass = ObjectClass[id]

-------------------------------------
-- KEEP A COPY OF THE WNDPROC ADDRESS
-------------------------------------
    -- store certain necessary address info in the windows structure of the control
    if objType!=StaticBitmap then

        -- store the current WndProcAddress of the new control
--PL 1/2/09:
--      WndProcAddress[id] = c_func(xGetWindowLong, {hwnd, GWL_WNDPROC})
        tmp = c_func(xGetWindowLong, {hwnd, GWL_WNDPROC})
        WndProcAddress[id] = tmp
        -- store new id into the controls user_data area
        setID(hwnd, id)

    end if

----------------------------------------
-- SUBCLASS ANY WIN32-RECOGNIZED CONTROL
----------------------------------------
    -- subclass control if necessary
    subClassControl(id, hwnd)

----------------------------------------
-- ACCELERATOR KEY SET?
----------------------------------------

    if find('&', lbl) then
        void = setAccelerator(id, lbl)
    end if



-------------------------
-- POST-CREATION SETTINGS
-------------------------
--ANSI_FIXED_FONT   - Courier - Windows fixed-pitch (monospace) system font.
--ANSI_VAR_FONT -- Arial -  Windows variable-pitch (proportional space) system font.
--DEVICE_DEFAULT_FONT - large Courier -     Windows NT only: Device-dependent font.
--DEFAULT_GUI_FONT - Arial too -    Windows 95 only: Default font for user interface objects such as menus and dialog boxes.
--OEM_FIXED_FONT - bold Courier -   Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font.
--SYSTEM_FONT - System font - . By default, Windows uses the system font to draw menus, dialog box controls, and text
--  . In Windows versions 3.0 and later, the system font is a proportionally spaced font; earlier versions of
--   Windows used a monospace system font.
--SYSTEM_FIXED_FONT - like system font but has constant char width

    -- set a default stock font for the controls
    hFont = c_func(xGetStockObject,{DEFAULT_GUI_FONT})

    -- set this into all controls other than windows
    if objType!=Window then
        void = sendMessage(id, WM_SETFONT, hFont, True)
    end if

    -- WINDOW
    if objType=Window then

        -- store the Private DC
        if and_bits(vWindowClassStyle, CS_OWNDC) then
--PL 1/2/09:
--          ObjectExtra[id][PRIVATEDC] = c_func(xGetDC,{hwnd})
            tmp = c_func(xGetDC,{hwnd})
            ObjectExtra[id][PRIVATEDC] = tmp
--          void = selectObject(ObjectExtra[id][PRIVATEDC], hFont) -- select a stock font into this dc
            void = selectObject(tmp, hFont) -- select a stock font into this dc
        end if

        if hBitmap then
            void = sendMessage(id, WM_SETICON, 1, hBitmap)
        end if

        -- catch the handle of the first window created
        if PrimaryWindowID=UNDEFINED then
            PrimaryWindowID = id
        end if

        -- STANDARD (builtin)SCROLL BARS
        if and_bits(dwStyle, WS_HSCROLL) then
            setScrollInfo({id,SB_HORZ},{1,100,10,1},1)
        end if
        if and_bits(dwStyle, WS_VSCROLL) then
            setScrollInfo({id,SB_VERT},{1,100,10,1},1)
        end if


    -- SCROLL CONTROL
    elsif objectClass=SCROLLBAR then

        -- put in a default set of scroll values
        setScrollInfo(id, {1, 100, 10, 1}, 1)
        -- store the scroll bar id's for auto-resizing & repositioning
        if objType=HScroll and scroll_flag=SBS_BOTTOMALIGN then -- horizontal scroll bar
            ObjectExtra[pID][HSCROLL] = id
        elsif objType=VScroll and scroll_flag=SBS_RIGHTALIGN then -- vertical scroll bar
            ObjectExtra[pID][VSCROLL] = id
        end if


    -- TRACKBAR CONTROL
    elsif objectClass=TRACKBAR then
        -- use this message to init track bars ranges
        setScrollInfo(id, {1, 100, 10, 1}, True)


    -- TOOLBAR
    elsif objType=ToolBar then
        ObjectExtra[pID][TOOLBAR] = id
        if nWidth and nHeight then -- set a particular size for the buttons
--          void = sendMessage(id, TB_SETBUTTONSIZE, 0, (nWidth-4) * #10000 + nHeight-4)
            void = sendMessage(id, TB_SETBITMAPSIZE, 0, nWidth * #10000 + nHeight)
--          void = sendMessage(id, TB_SETBITMAPSIZE, 0, nHeight * #10000 + nWidth)
            void = sendMessage(id, TB_AUTOSIZE, 0, 0)
        end if


    -- STATUS BAR
    elsif objType=StatusBar then
        ObjectExtra[pID][STATUSBAR] = id
        ObjectExtra[id] = nWidth


    -- LIST CONTROL
    elsif objectClass=LIST then
        ObjectExtra[id] = dwStyle


    -- COMBO CONTROL
    elsif objectClass=COMBO then
        -- ensure the height of the edit control is great enough
        junk = 8 + sendMessage(id, CB_GETITEMHEIGHT, 0, 0) -- min height of selection field
        if nHeight<junk then -- oops, must increase height of selection field
            nHeight = junk
            void =  c_func(xMoveWindow,{hwnd,x,y,nWidth,nHeight,False})
        end if

        -- subclass the edit control so that the handler can receive any messages
        if and_bits(dwStyle, CBS_DROPDOWNLIST)!=CBS_DROPDOWNLIST then -- (this type of combo has edit control)

            -- get handle of the edit control
            scHwnd = c_func(xGetWindow,{ hwnd, GW_CHILD}) -- NB: ComboDropDown=edit   ComboBox=list
            -- (special case: ComboBox)
            if and_bits(dwStyle, CBS_SIMPLE) then -- must be ComboBox
                scHwnd = c_func(xGetWindow,{ scHwnd, GW_HWNDNEXT}) -- get edit handle NOT list handle
            end if

--          -- this just to test that edit control was correctly found, del later
--          hFont = c_func(xGetStockObject,{SYSTEM_FONT})
--          void = c_func(xSendMessage,{scHwnd,WM_SETFONT,hFont,True})

            scID = addControl(EditText, id, scHwnd, "", 0) -- create a dummy control to store the SubProcAddress
--PL 1/2/09:
--          WndProcAddress[scID] = c_func(xGetWindowLong, {scHwnd, GWL_WNDPROC}) -- store original WndProcAddress
            tmp = c_func(xGetWindowLong, {scHwnd, GWL_WNDPROC}) -- store original WndProcAddress
            WndProcAddress[scID] = tmp
            setID(scHwnd, scID)
            subClassControl(scID, scHwnd)
            ObjectExtra[id] = scID -- store the id of the edit control where the parent control can access it if needed
            ObjectChildren[id] = {scID} -- store the id of the edit control where the parent control can access it if needed
        end if


    elsif objectClass=BUTTON then
        -- deal with any picture button controls
        if hBitmap then
            void = sendMessage(id, BM_SETIMAGE, IMAGE_BITMAP, hBitmap)
        end if


    elsif objectClass=HYPERTEXT then
        -- make font underlined
        lpStruct = allocate(sizeofstruct(LOGFONT))
        if getObject(hFont,sizeofstruct(LOGFONT),lpStruct) then
            poke(lpStruct+LOGFONT_lfUnderline, 1)
            hFont = c_func(xCreateFontIndirect,{lpStruct})
            if not hFont then
                hFont = c_func(xGetStockObject,{DEFAULT_GUI_FONT})
            end if
        end if
        free(lpStruct)
        -- repaint control, couldn't do this before
        void = c_func(xInvalidateRgn,{hwnd,0,1})

    elsif objType=ListView then
        if and_bits(LVS_REPORT, dwStyle)!=0 then
            for i=1 to length(lvColumns) do
                if not sequence(lvColumns[i]) then       -- no text, just width
                    lvColumns[i] = {"",lvColumns[i],0}
                elsif length(lvColumns[i])=0 then        -- prevent crash...
                    lvColumns[i] = {"",100,0}
                elsif not sequence(lvColumns[i][1]) then -- just text (eg {"a","b"}
                    lvColumns[i] = {lvColumns[i],100,0}
                elsif length(lvColumns[i]) = 1 then      -- just text (eg b in {{"a",100,0},{"b"}})
                    lvColumns[i] = {lvColumns[i][1],100,0}
                elsif length(lvColumns[i]) = 2 then      -- add default alignment
                    lvColumns[i] = append(lvColumns[i],0)
                elsif length(lvColumns[i])!= 3 then ?9/0
                end if
                insertLVColumn(id,lvColumns[i],i)
            end for
        end if
        ObjectExtra[id][1] = dwStyle
        ObjectExtra[id][2] = length(lvColumns)
        if lvStyleEx then
            void = sendMessage(id, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, lvStyleEx)
        end if

    elsif objectClass=PROGRESSBAR then

    elsif objType=ReBarBand then

        if ObjectType[pID]!=ReBar then ?9/0 end if  -- DEV ReBarBand parent must be a ReBar

        dwStyle = or_bits(dwStyle,RBBS_CHILDEDGE+RBBS_GRIPPERALWAYS)
        mask = RBBIM_ID+RBBIM_SIZE+RBBIM_TEXT+RBBIM_STYLE
        RBB = allocate(RBBsize)
        poke4(RBB+REBARBANDINFO_cbSize,     RBBsize)
        poke4(RBB+REBARBANDINFO_fMask,      mask)
        poke4(RBB+REBARBANDINFO_fStyle,     dwStyle)
        poke4(RBB+REBARBANDINFO_clrFore,    0)
        poke4(RBB+REBARBANDINFO_clrBack,    0)
        poke4(RBB+REBARBANDINFO_lpText,     lpszWindowName)
        poke4(RBB+REBARBANDINFO_cchTextMax, length(lbl))
        poke4(RBB+REBARBANDINFO_iImage,     0)
        poke4(RBB+REBARBANDINFO_hwndChild,  0)
        poke4(RBB+REBARBANDINFO_cxMinChild, 0)
        poke4(RBB+REBARBANDINFO_cyMinChild, 0)
        poke4(RBB+REBARBANDINFO_cx,         nWidth)
        poke4(RBB+REBARBANDINFO_hbmBack,    0)
        poke4(RBB+REBARBANDINFO_wID,        id)
        poke4(RBB+REBARBANDINFO_cyChild,    0)
        poke4(RBB+REBARBANDINFO_cyMaxChild, 0)
        poke4(RBB+REBARBANDINFO_cyIntegral, 0)
        poke4(RBB+REBARBANDINFO_cxIdeal,    0)
        poke4(RBB+REBARBANDINFO_lParam,     0)
        poke4(RBB+REBARBANDINFO_cxHeader,   0)

        if not sendMessage(pID, RB_INSERTBAND, -1, RBB) then
            ?9/0    --DEV error inserting band...
        end if
        free(RBB)

    end if

    -- store id of child
    if pID and ObjectType[pID]!=TabControl then -- TabControl "children" really grandchildren, stored elsewhere
        ObjectChildren[pID] &= id
    end if

    -- store font handle
    ObjectFont[id] = hFont

    if rbbID then
        -- complete processing of items added to a ReBarBand
        addToReBarBand(id,rbbID)
    end if

    -- exit with new control id
    return id

end function


---------------------------------------------------------------

constant ADD=1, REMOVE=2
procedure changeStyle(object id, object styles, integer flag)
--
-- used by addStyle/removeStyle
-- add/remove the specified styles from the control(s) and redisplay.
--
-- id is any control-id or a list of them.
-- styles is either an atom or a sequence of length 2, much like the
--  last parameter of create(), except not applying getClassStyles().
-- flag is either ADD or REMOVE, as defined above.
--
atom style, hwnd
object exstyle
    if sequence(id) then
        for i=1 to length(id) do
            changeStyle(id[i],styles,flag)
        end for
        return
    end if
    hwnd = getHwnd(id)
    if sequence(styles) then
        if length(styles)!=2 then ?9/0 end if
        -- ^^ you must pass either atom styles or {styles,ex_styles}.
        --  A few examples:
        --      {{WS_DLGFRAME, WS_SYSMENU},0}
        --      or_all({WS_DLGFRAME,WS_SYSMENU}) (same as above)
        --      or_bits(WS_DLGFRAME,WS_SYSMENU) (same as above)
        --      WS_DLGFRAME+WS_SYSMENU (same as above, but see below)
        --      {0, WS_EX_CLIENTEDGE}
        --      {TBSTYLE_FLAT,WS_EX_STATICEDGE}
        --      {{WS_CHILD,WS_THICKFRAME},WS_EX_CLIENTEDGE}
        --      {{WS_THICKFRAME,WS_MINIMIZEBOX,WS_MAXIMIZEBOX},0}
        --      {WS_THICKFRAME+WS_MINIMIZEBOX+WS_MAXIMIZEBOX,0}
        --      WS_THICKFRAME+WS_MINIMIZEBOX+WS_MAXIMIZEBOX
        --  (The last 3 are equivalent, but take care since eg
        --   WS_OVERLAPPEDWINDOW+WS_BORDER is #14F0000 (wrong!),
        --   whereas or_bits(WS_OVERLAPPEDWINDOW,WS_BORDER) is
        --   #CF0000, much more likely what you were after, tho
        --   in fact WS_OVERLAPPEDWINDOW == #CF0000 and would
        --   therefore be smarter than using or_bits anyway.)
        --
        exstyle = styles[2]
        if sequence(exstyle) then
            exstyle = or_all(exstyle)
        end if
        style = c_func(xGetWindowLong,{hwnd, GWL_EXSTYLE})
        if flag=ADD then
            style = or_bits(style,exstyle)
        else -- REMOVE
            style -= and_bits(style,exstyle)
        end if
        void = c_func(xSetWindowLong,{hwnd,GWL_EXSTYLE,style})
        styles = styles[1]
        if sequence(styles) then
            styles = or_all(styles)
        end if
    end if
    if getObjectType(id)=StatusBar then
        if and_bits(styles,SBARS_SIZEGRIP) then ?9/0 end if
        -- Attempts to add/remove a statusbar sizegrip are doomed
        --  to failure: Windows just ignores you.. While this may
        --  have been fixed in later versions of windows, for old
        --  versions the only way to achieve this is to have two
        --  statusbars, one visible and one not.
    end if
    style = c_func(xGetWindowLong,{hwnd, GWL_STYLE})
    if flag=ADD then
        style = or_bits(style,styles)
    else -- REMOVE
        style -= and_bits(style,styles)
    end if
    void = c_func(xSetWindowLong,{hwnd,GWL_STYLE,style})
    void = c_func(xSetWindowPos,{hwnd,0,0,0,0,0,SWP_UPDATECACHE})
end procedure

global procedure addStyle(object id, object styles)
-- add the specified styles to the control(s) and redisplay.
    changeStyle(id,styles,ADD)
end procedure

global procedure removeStyle(object id, object styles)
-- remove the specified styles from the control(s) and redisplay.
--  eg removeStyle(win,WS_THICKFRAME+WS_MINIMIZEBOX+WS_MAXIMIZEBOX) makes
--    win fixed-size with no minimise/maximise buttons on the titlebar
--    and prevents the cursor from changing over the borders to a sizer.
    changeStyle(id,styles,REMOVE)
end procedure

--DEV wherever this is currently used, we could/should inline & remove this?)
global procedure fixWindow(object id)
-- make the specified window fixed-size; remove the minimise and maximise buttons
-- from the titlebar and prevent cursor changing over the borders/resize dragging.
-- (window can still be moved, just not resized)
    changeStyle(id, WS_THICKFRAME+WS_MINIMIZEBOX+WS_MAXIMIZEBOX, REMOVE)
--atom style, hwnd
--  if sequence(id) then
--      for i=1 to length(id) do
--          fixWindow(id[i])
--      end for
--      return
--  end if
--  hwnd = getHwnd(id)
--  style = c_func(xGetWindowLong,{hwnd, GWL_STYLE})
----    if getObjectType(id)=StatusBar then
----        -- sadly, you cannot do this, Windows just ignores you...
----        -- StatusBars must be created without the sizegrip,
----        -- which you do with create(StatusBar,,...{?,?,0}).
----        style -= and_bits(style,SBARS_SIZEGRIP)
----    else
--  style -= and_bits(style,WS_THICKFRAME+WS_MINIMIZEBOX+WS_MAXIMIZEBOX)
----    end if
--  void = c_func(xSetWindowLong,{hwnd,GWL_STYLE,style})
--  void = c_func(xSetWindowPos,{hwnd,0,0,0,0,0,SWP_UPDATECACHE})
end procedure

-- Tool tips
global integer
    tooltipControl     -- id of tooltip control
    -- defaults
    tooltipControl  = 0

atom toolTipHwnd
--   toolTipHwnd=0

global procedure setHint(object id, sequence text)
atom TI
    if not tooltipControl then
--      toolTipHwnd = c_func(xCreateWindowEx,{NULL,allocate_StringZ(TOOLTIPS_CLASSA),NULL,0,
--                                          CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
--                                          CW_USEDEFAULT,NULL,NULL,instance(),NULL})
        tooltipControl = create(ToolTip,"",0,0,0,0,0,0,0)
        toolTipHwnd = getHwnd(tooltipControl)
    end if
    TI = allocate(sizeofstruct(TOOLINFO))
    poke4(TI + TI_cbSize,   sizeofstruct(TOOLINFO))
    poke4(TI + TI_uFlags,   TTF_IDISHWND+TTF_SUBCLASS)
    poke4(TI + TI_hwnd,     toolTipHwnd)
    poke4(TI + TI_lpszText, allocate_StringZ(text))
    if atom(id) then
--          -- get handle of the edit control
--          scHwnd = c_func(xGetWindow,{ hwnd, GW_CHILD}) -- NB: ComboDropDown=edit   ComboBox=list
--          ObjectExtra[id] = scID -- store the id of the edit control where the parent control can access it if needed
        poke4(TI + TI_uId, getHwnd(id))
        void = c_func(xSendMessage,{toolTipHwnd,TTM_ADDTOOLA,0,TI})
        if ObjectClass[id]=COMBO and ObjectExtra[id]!=UNDEFINED then
--      if ObjectType[id]=ComboDropDown then
            poke4(TI + TI_uId, getHwnd(ObjectExtra[id]))
            void = c_func(xSendMessage,{toolTipHwnd,TTM_ADDTOOLA,0,TI})
        end if
    else
        for i=1 to length(id) do
            poke4(TI + TI_uId, getHwnd(id[i]))
            void = c_func(xSendMessage,{toolTipHwnd,TTM_ADDTOOLA,0,TI})
            if ObjectClass[id[i]]=COMBO and ObjectExtra[id[i]]!=UNDEFINED then
--          if ObjectType[id[i]]=ComboDropDown then
                poke4(TI + TI_uId, getHwnd(ObjectExtra[id[i]]))
                void = c_func(xSendMessage,{toolTipHwnd,TTM_ADDTOOLA,0,TI})
            end if
        end for
    end if
    free(TI)
end procedure

--global procedure replaceHint(atom id, sequence text)
--  if toolTipHwnd then
--      poke4(ti + TI_uId, getHwnd(id))
--      poke4(ti + TI_lpszText, allocate_StringZ(text))
----        void = c_func(xSendMessage,{toolTipHwnd,TTM_DELTOOLA,0,ti})
--      void = c_func(xSendMessage,{toolTipHwnd,TTM_SETTOOLINFO,0,ti})
--  end if
----    setHint(id,text)
--end procedure


global function destroy(object id)
integer objType, objectClass, pID, junk
atom hWnd
sequence temp

    if sequence(id) then -- list of controls
        junk = 0
        for i=1 to length(id) do
            junk += destroy(id[i])
        end for
        return junk

    else -- single instance

        --DEV 21/11:
        if id=-1 then return False end if
        --  get flags + hwnd
        objType = ObjectType[id]
        objectClass = ObjectClass[id]
        hWnd = ObjectHwnd[id]

        -- test if id is valid/live
        if objType=UNDEFINED then -- test if id is valid, maybe more testing could occur here?
            return False
        end if

        -- don't fully know what to do about this one yet, but slowly getting there..
        if objType=Window then

            -- PL 21/11 nicked from statusbar handling.
            pID = ObjectParent[id]
            if pID then
                temp = ObjectChildren[pID]
                junk = find(id, temp)
                if not junk then
                    WarnErr("Attempt to destroy Window aborted. Parent's id list is in error.")
                    return False
                end if
                temp = temp[1..junk-1] & temp[junk+1..length(temp)]
                ObjectChildren[pID] = temp
            end if

            -- destroy menu, tool/status/scroll bar of window NOT PRIVATEDC
            void = destroy(ObjectExtra[id][1..NUMMANAGEDWINDOWCONTROLS])
            -- destroy all other child controls of the window
            void = destroy(ObjectChildren[id])


        elsif objectClass=MENU then
            return destroyMenu(id)

        elsif objectClass=COMBO then
--PL 31/07/2013 (test added)
if ObjectExtra[id]!=UNDEFINED then
            eraseControl(ObjectExtra[id]) -- erase the id of the edit control associated with the list part
end if

--*******
        elsif objType=ToolBar then -- finish this one sometime
--*******

        elsif objType=TabControl then
            temp = ObjectChildren[id] -- id's of all child tab items
            void = destroy(temp)

        elsif objType=TabItem then
            -- destroy all controls asociated with the tabitem
            temp = ObjectChildren[id] -- list of id's of all controls associated with the TabItem
            void = destroy(temp)
            -- destroy the tabitem itself in Windows
            pID = ObjectParent[id]
            junk = find(id, ObjectChildren[pID])
            if not junk then
                WarnErr("Attempt to destroy TabItem aborted. Parent's child id list is in error.")
                return False
            end if
            void = c_func(xSendMessage, {ObjectHwnd[ObjectParent[id]], TCM_DELETEITEM, junk-1, 0})
            -- remove the control from the parent's children list
            temp = ObjectChildren[pID]
            temp = temp[1..junk-1] & temp[junk+1..length(temp)]
            ObjectChildren[pID] = temp
            -- erase the control from ARWEN
            eraseControl(id)
            -- exit because tabitems are not actual controls (hWnd) that windows can delete
            return True

        elsif objType=StatusBar then
            -- destroy all sub-fields first
            temp = ObjectChildren[id]
            for i=1 to length(temp) do
                eraseControl(temp[i])
            end for

        elsif objType=StatusField then
            pID = ObjectParent[id]
            temp = ObjectChildren[pID]
            junk = find(id, temp)
            if not junk then
                WarnErr("Attempt to destroy StatusField aborted. Parent's id list is in error.")
                return False
            end if
            temp = temp[1..junk-1] & temp[junk+1..length(temp)]
            ObjectChildren[pID] = temp
            eraseControl(id)
--DEV PL 21/11 removed:
--          for i=1 to length(temp) do
--              temp[i] = ObjectExtra[temp[i]] -- convert existing field ids into field widths
--          end for
--          setStatusWidths(pID, temp)  --DEV??
            return True

--PL 30/7/2013 (fixes problems with pgdemo/Amend())
        else
            pID = ObjectParent[id]
            temp = ObjectChildren[pID]
            junk = find(id, temp)
            if junk then
                temp = temp[1..junk-1] & temp[junk+1..length(temp)]
                ObjectChildren[pID] = temp
            end if
        end if

        -- unsubclass then destroy the window (control) and then delete it from the object list maintained by ARWEN
        unsubClassControl(id)
        void = c_func(xDestroyWindow,{hWnd})
        eraseControl(id)

    end if

    return True

end function



global procedure drawDisabledText(atom lpText, atom hDC, atom lpRect, atom flags)
sequence rect
    rect = peek4s({lpRect,4})
    poke4(lpRect, sq_add(rect,1))
--  void = c_func(xSetBkMode,{hDC,TRANSPARENT})
    void = c_func(xSetTextColor,{hDC,c_func(xGetSysColor,{COLOR_3DHILIGHT})})
    c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})
    poke4(lpRect, rect)
    void = c_func(xSetBkMode,{hDC,TRANSPARENT})
    void = c_func(xSetTextColor,{hDC,c_func(xGetSysColor,{COLOR_GRAYTEXT})})
    c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})
end procedure


-- HYPERTEXT COLORS, BRUSHES etc..

atom ArrowCursor, HandCursor, NoCursor
ArrowCursor = loadCursor(IDC_ARROW)
HandCursor = loadCursor("hand.cur") -- loadCursor(IDC_NO)
NoCursor = loadCursor("no.cur")

atom  hBrush, TxtBack
TxtBack = c_func(xGetSysColor,{COLOR_3DFACE})
hBrush = c_func(xCreateSolidBrush,{TxtBack})


procedure drawHyperTextControl
    (integer id, atom hwnd, atom hDC, atom lpRect, integer action, integer state)
-- action & state are both multi-flag values
atom lpText, hFont

    if and_bits(action, ODA_DRAWENTIRE) then
        if hwnd then end if     --DEV suppress warning

        -- erase background first
        void = c_func(xFillRect,{hDC,lpRect,hBrush})

        lpText = allocate_StringZ(ObjectLabel[id])
        hFont = ObjectFont[id]

        hFont = selectObject(hDC, hFont)

        if and_bits(state, ODS_DISABLED) then
            drawDisabledText(lpText, hDC, lpRect, DT_SINGLELINE)

        else
            void = c_func(xSetBkMode,{hDC,TRANSPARENT})
            void = c_func(xSetTextColor,{hDC,BrightBlue})
            c_proc(xDrawText,{hDC,lpText,-1,lpRect,DT_SINGLELINE})

        end if

        hFont = selectObject(hDC, hFont)

        if and_bits(state, ODS_FOCUS) then
            void = c_func(xDrawFocusRect,{hDC,lpRect})
        end if

    elsif and_bits(action, ODA_FOCUS) then
        void = c_func(xDrawFocusRect,{hDC,lpRect})

    end if

end procedure

procedure drawMenus(integer id, atom hwnd, integer state, integer action, atom hDC, atom lpRect)
atom lpText, flags
integer len, iconX, iconY, textX
sequence rect

    -- flags
integer isSelected, isTopLevel, isDisabled, isChecked

-- ACTIONS
--ODA_DRAWENTIRE    The entire control needs to be drawn.
--ODA_FOCUS         The control has lost or gained the keyboard focus. 
--                   The itemState member should be checked to determine whether the control has the focus.
--ODA_SELECT        The selection status has changed. 
--                   The itemState member should be checked to determine the new selection state.

-- STATE AFTER ACTION
--ODS_CHECKED   The menu item is to be checked. This bit is used only in a menu.
--ODS_COMBOBOXEDIT  The drawing takes place in the selection field (edit control) of an ownerdrawn combo box.
--ODS_DEFAULT   The item is the default item.
--ODS_DISABLED  The item is to be drawn as disabled.
--ODS_FOCUS The item has the keyboard focus.
--ODS_GRAYED    The item is to be grayed. This bit is used only in a menu.
--ODS_SELECTED  The menu item's status is selected.

integer iconspace

    iconspace = 28

    rect = peek4s({lpRect,4})
    iconX = rect[1]
    iconY = rect[2]
    textX = iconX + iconspace



    -- SET VARIOUS FLAGS
    isTopLevel = isTopLevelMenu(id)
    isSelected = and_bits(state, ODS_SELECTED)
    isDisabled = and_bits(state, ODS_DISABLED)
    isChecked = and_bits(state, ODS_CHECKED)

    -- do we draw the background for the icon and then non-selected non-toplevel text?
    if not isTopLevel then
        if not isSelected then
            if hwnd or action then end if   --DEV suppress warnings
            len = rect[3]
            rect[3] = rect[1] + iconspace - 5

            poke4(lpRect, rect)
            void = c_func(xFillRect,{hDC,lpRect,MENUBRUSH_ICON})

            rect[1] = rect[3]--+1
            rect[3] = len
            poke4(lpRect, rect)

            -- blank the rect
            void = c_func(xFillRect,{hDC,lpRect,MENUBRUSH_NORMAL})

        else -- do selected stuff
            void = c_func(xFillRect,{hDC,lpRect,MENUBRUSH_SELECT})
            void = c_func(xFrameRect,{hDC,lpRect,MENUBRUSH_BORDER})

        end if

        rect[1] = textX
        poke4(lpRect, rect)

    elsif isSelected then
        void = c_func(xFillRect,{hDC,lpRect,MENUBRUSH_TOPSELECT})

    else
        void = c_func(xFillRect,{hDC,lpRect,COLOR_MENU+1})

    end if



    -- Draw the MenuSep
    if ObjectType[id]=MenuSep then
        -- prepare the bounds to align left edge of line with left edge of text of any MenuItems
        rect[3] -= 2
        rect[2] += 2
        poke4(lpRect, rect)
        -- draw frame line
        void = c_func(xDrawEdge,{hDC,lpRect,EDGE_ETCHED,BF_TOP})
        -- exit
        return
    end if


    -- allocate space for the text
    lpText = allocate_StringZ(ObjectLabel[id])

    len = 20--c_func(xGetSystemMetrics,{SM_CXMENUCHECK})

    -- set formatting flags
    if not isTopLevel then
        flags = DT_LEFT+DT_VCENTER+DT_SINGLELINE
    else
        flags = DT_CENTER+DT_VCENTER+DT_SINGLELINE
    end if

--  DRAW DISABLED TEXT
    if isDisabled then -- draw text that has been disabled
--          if not isSelected then
--              MENUCOLOUR_DISABLED
--              drawDisabledText(lpText,hDC,lpRect,flags)
--          else
--              void = c_func(xSetBkMode,{hDC,TRANSPARENT})
--              void = c_func(xSetTextColor,{hDC,#AAAAAA})
--              c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})
--          end if

        void = c_func(xSetBkMode,{hDC,TRANSPARENT})
        void = c_func(xSetTextColor,{hDC,MENUCOLOUR_DISABLED})
        c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})

-- DRAW DEFAULT TEXT
    else -- ODS_DEFAULT, draw text
        if isTopLevel and isSelected then
            void = c_func(xSetTextColor,{hDC,BrightWhite})
        else
            void = c_func(xSetTextColor,{hDC,Black})
        end if
        void = c_func(xSetBkMode,{hDC,TRANSPARENT})
        c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})

    end if


            -- draw frame
----            void = c_func(xDrawEdge,{hDC,lpRect,BDR_SUNKENOUTER,BF_TOPLEFT})
----            void = c_func(xDrawEdge,{hDC,lpRect,BDR_SUNKENINNER,BF_RIGHT})

--          void = c_func(xDrawEdge,{hDC,lpRect,EDGE_ETCHED,BF_RECT})

    end procedure

sequence drawTabColours, drawTabBrushes
         drawTabColours={} drawTabBrushes={}
integer k
atom colour,brush

procedure drawTabItems(atom hDC, atom lParam, atom lpRect, integer action, integer state)
integer id, control, flags, x, y
atom hwnd, lpText
sequence coords

    -- prepare text formatting flags
    flags = DT_CENTER+DT_VCENTER+DT_SINGLELINE

    hwnd = peek4u(lParam+DIS_hwndItem)
    control = peek4u(lParam+DIS_itemID) + 1
    id = getID(hwnd)
    if control>length(ObjectChildren[id]) then
        if action then end if   --DEV suppress warnings
        WarnErr("error here")
        return
    end if
    id = ObjectChildren[id][control]
    lpText = allocate_StringZ(ObjectLabel[id])

    -- get the standard place for the rectangle
    coords = peek4s({lpRect,4})

    colour = ObjectBackColour[id]
    if colour=UNDEFINED then
--      colour = COLOR_MENU+1
--      colour = COLOR_BTNFACE+1        -- 31/12/09
--14/3/13
        if and_bits(state, ODS_SELECTED) then
            colour = COLOR_BTNFACE+1
        else
            colour = COLOR_INACTIVECAPTION+1
        end if
--colour=25 -- yellowy
--colour=24 -- black (yuk)
--colour=23 -- grey
--colour=22 -- dark grey (yuk)
--colour=21 -- grey
--colour=20 -- dark grey (yuk)
--colour=19 -- dark grey (yuk)
--colour=18 -- med grey (yuk)
--colour=17 -- med light grey (yuk)
--colour=16 -- grey
--colour=15 -- grey
--colour=14 -- blue (yuk)
--colour=13 -- med light grey (yuk)
--colour=12 -- grey
--colour=11 -- med light grey (yuk)
--colour=10 -- dark grey (yuk)
--colour=9 -- dark grey (yuk)
--colour=8 -- dark grey (yuk)
--colour=7 -- med grey (yuk)
--colour=6 -- grey
--colour=5 -- grey
--colour=4 -- cyan (yuk)    -- but maybe
--colour=3 -- darker cyan (yuk)
--colour=2 -- dark grey (yuk)
--colour=1 -- dark grey (yuk)

--  COLOR_SCROLLBAR = 0,
--  COLOR_BACKGROUND = 1,
--  COLOR_DESKTOP = 1,
--  COLOR_ACTIVECAPTION = 2,
--  COLOR_INACTIVECAPTION = 3,
--  COLOR_MENU = 4,
--  COLOR_WINDOW = 5,
--  COLOR_WINDOWFRAME = 6,
--  COLOR_MENUTEXT = 7,
--  COLOR_WINDOWTEXT = 8,
--  COLOR_CAPTIONTEXT = 9,
--  COLOR_ACTIVEBORDER = 10,
--  COLOR_INACTIVEBORDER = 11,
--  COLOR_APPWORKSPACE = 12,
--  COLOR_HIGHLIGHT = 13,
--  COLOR_HIGHLIGHTTEXT = 14,
--  COLOR_BTNFACE = 15,
--  COLOR_3DFACE = 15,
--  COLOR_BTNSHADOW = 16,
--  COLOR_3DSHADOW = 16,
--  COLOR_GRAYTEXT = 17,
--  COLOR_BTNTEXT = 18,
--  COLOR_INACTIVECAPTIONTEXT = 19,
--  COLOR_BTNHIGHLIGHT = 20,
--  COLOR_BTNHILIGHT = 20,
--  COLOR_3DHILIGHT = 20,
--  COLOR_3DDKSHADOW = 21,
--  COLOR_3DLIGHT = 22,
--  COLOR_INFOTEXT = 23,
--  COLOR_INFOBK = 24,
        
        brush = colour
    else
        k = find(colour,drawTabColours)
        if k then
            brush = drawTabBrushes[k]
        else
            drawTabColours = append(drawTabColours,colour)
            brush = c_func(xCreateSolidBrush, {colour})
            drawTabBrushes = append(drawTabBrushes,brush)
        end if
        void = c_func(xSetBkColor,{hDC,colour})
        void = c_func(xSetBkMode,{hDC,TRANSPARENT} )
--  void = c_func(xFillRect,{hDC,lpRect,colour})
    end if
    -- if the tab is selected then (i) blank the background and (ii) reposition text higher
    if and_bits(state, ODS_SELECTED) then
        poke4(lpRect+12, coords[4]-1)
        void = c_func(xFillRect, {hDC, lpRect, brush})
--      coords -= {1, 1, 1, 1}
        coords = sq_add(coords,-1)
    else
        poke4(lpRect+12, coords[4]+2)
        void = c_func(xFillRect, {hDC, lpRect, brush})
--      coords += {1, 1, 1, 1}
        coords = sq_add(coords,1)
    end if

    if ObjectImage[id] then
        --  drawIcon
        x = coords[1]+3
        y = coords[2]+3
        if and_bits(state, ODS_SELECTED) then
            x += 6
        else
            y -= 2
        end if
        void = c_func(xImageList_Draw, {hILsmall,ObjectImage[id]-1,hDC,x,y,ILD_NORMAL})
        coords = sq_add(coords,{c_func(xGetSystemMetrics, {SM_CXSMICON}),0,0,0})
    end if  

    -- reposition the new coords
    poke4(lpRect, coords)

    if ObjectExtra[id]=0 then -- draw disabled text
        drawDisabledText(lpText, hDC, lpRect, flags)
    else -- draw enabled text
        colour = ObjectTextColour[id]
        void = c_func(xSetBkMode,{hDC,TRANSPARENT})
        void = c_func(xSetTextColor,{hDC,colour})
        c_proc(xDrawText,{hDC,lpText,-1,lpRect,flags})
    end if

end procedure

function proc_DrawItemMessage(atom wParam, atom lParam)
atom hwnd, hDC, lpRect
integer control, action, state, id

-- ACTIONS
--ODA_DRAWENTIRE    The entire control needs to be drawn.
--ODA_FOCUS         The control has lost or gained the keyboard focus. 
--                   The itemState member should be checked to determine whether the control has the focus.
--ODA_SELECT        The selection status has changed.
--                   The itemState member should be checked to determine the new selection state.

-- STATE AFTER ACTION
--ODS_CHECKED   The menu item is to be checked. This bit is used only in a menu.
--ODS_COMBOBOXEDIT  The drawing takes place in the selection field (edit control) of an ownerdrawn combo box.
--ODS_DEFAULT   The item is the default item.
--ODS_DISABLED  The item is to be drawn as disabled.
--ODS_FOCUS The item has the keyboard focus.
--ODS_GRAYED    The item is to be grayed. This bit is used only in a menu.
--ODS_SELECTED  The menu item's status is selected.

    control = peek4u(lParam)
    action = peek4u(lParam + DIS_itemAction)
    state = peek4u(lParam + DIS_itemState)
    hwnd = peek4u(lParam + DIS_hwndItem)
    hDC = peek4u(lParam + DIS_hDC)
    id = peek4u(lParam + DIS_CtlID)

    if not id then
        id = getID(hwnd)
    end if

    lpRect = lParam + DIS_rcItem


    if control=ODT_BUTTON then
        if wParam then end if   --DEV suppress warnings

        if id and ObjectType[id]=HyperText then
            drawHyperTextControl(id, hwnd, hDC, lpRect, action, state)
            return True
--DEV no borders, no text: (for buttons defined with BS_OWNERDRAW)
--elsif id then
----?99
--  colour = ObjectBackColour[id]
--  if colour=UNDEFINED then
--      colour = COLOR_MENU+1
--      brush = colour
--  else
--      k = find(colour,drawTabColours)
--      if k then
--          brush = drawTabBrushes[k]
--      else
--          drawTabColours = append(drawTabColours,colour)
--          brush = c_func(xCreateSolidBrush, {colour})
--          drawTabBrushes = append(drawTabBrushes,brush)
--      end if
--  end if
--  void = c_func(xSetBkColor,{hDC,colour})
----    void = c_func(xSetBkMode,{hDC,TRANSPARENT})
----    void = c_func(xFillRect,{hDC,lpRect,colour})
--  void = c_func(xFillRect,{hDC,lpRect,brush})
--return True
        end if


    elsif control=ODT_COMBOBOX then


    elsif control=ODT_LISTBOX then


    elsif control=ODT_LISTVIEW then


    elsif control=ODT_MENU then
        -- get the id (stored in the itemData member) and call drawing routine
        id = peek4u(lParam + DIS_itemID) -- must ensure that this value is set correctly each time
        drawMenus(id, hwnd, state, action, hDC, lpRect)
        -- exit
        return False -- Huh?

    elsif control=ODT_STATIC then
        if id and ObjectTextColour[id]!=UNDEFINED then
            void = c_func(xSetTextColor,{hDC,ObjectTextColour[id]})
            c_proc(xDrawText,{hDC,allocate_StringZ(ObjectLabel[id]),-1,lpRect,0})
            return True
        end if


    elsif control=ODT_TAB then
        drawTabItems(hDC, lParam, lpRect, action, state)
        return True

    end if

    return False

end function


function proc_MeasureItemMessage(integer wID, atom wParam, atom lParam)

atom hDC, lpRect, hFont, hMenu
object lpText
integer len, height, icon_len, objectType
atom id

    if wParam=0 then -- menu is referred to

        -- get the id of the menu element
        id = peek4u(lParam + MIS_itemID)
        objectType = ObjectType[id]
        if objectType=MenuSep then
--          return False
            len = 30 -- default value
            height = 6 -- 2 pixels either side of a double line

        else -- Menus or MenuItems
--      if ObjectType[wID]=Window then
            lpRect = allocate_Rect()
            lpText = ObjectLabel[id]
            len = length(lpText)
            lpText = allocate_StringZ(lpText)

            hMenu = ObjectHwnd[id]
            hDC = c_func(xGetDC,{hMenu})
            hFont = c_func(xGetCurrentObject,{hDC,OBJ_FONT})
            void = c_func(xReleaseDC,{hMenu,hDC})
            hDC = ObjectExtra[wID][PRIVATEDC]
            hFont = c_func(xSelectObject,{hDC,hFont})
            icon_len = c_func(xGetSystemMetrics,{SM_CXMENUCHECK})
            if c_func(xGetTextExtentPoint32,{hDC,lpText,len,lpRect}) then
                len = peek4s(lpRect)
                height = peek4s(lpRect+4)+6
                --? {len,height}
            else -- probably never need these
                puts(1,"proc_MeasureItemMessage\n")
                ? id
                len *= 7
                height = 25
            end if

            if isTopLevelMenu(id) then
                len += 10 -- border of 5 either side
            else
                len += 40 -- 20 for icon, 10 for submenu cue
            end if

--          void = c_func(xReleaseDC,{hMenu,hDC})

            hFont = c_func(xSelectObject,{hDC,hFont})

        end if

        -- populate the MEASUREITEMSTRUCT structure
        poke4(lParam + MIS_CtlType, ODT_MENU)
        poke4(lParam + MIS_itemID, id)
        poke4(lParam + MIS_itemWidth, len)
        poke4(lParam + MIS_itemHeight, height) -- this value does nothing for top-level menus

        -- this odd return value was the only way I could get the thing to behave properly
        if objectType=MenuSep then
            return False
        end if

        return True

    else -- another sort of control

    end if

    -- exit, default
    return False

end function

function proc_KeyDownMessage(integer id, integer msg, atom wParam, atom lParam)
integer ctrl, shift, objtype, tmp, window

    -- 0 means return 0 upon return to caller
    -- 1 means continue

    if wParam=VK_TAB then -- process tabbing between controls
        if msg or lParam then end if    --DEV suppress warnings

        tmp = id

        id = getFocus()

        -- ensure an actual control/window is referenced
        if not id then
            id = getParentWindow(tmp)
            if not id then
                return 1
            end if
        end if

        -- ensure an owner window is present
        window = getParentWindow(id) -- if id is already a window then will return itself

        objtype = ObjectType[id]

        ctrl = getKeyState(VK_CONTROL)
        shift = getKeyState(VK_SHIFT)

        -- special case: MultiEditText - must always have the CTRL key down to move focus
        if objtype=MultiEditText and not ctrl then
            return 1
        end if

        -- move tab forward or backward depending on the system keys
        Tab_moveFocus(id, window, ctrl, shift)

        return 0

    end if

    return 1

end function

function proc_ScrollMessage(integer id, integer fnBar, atom request)
atom minp, maxp, page, pos, trackpos, max_move
atom temp

integer ssize
atom hwnd, lpsi

    -- get scroll request
    request = and_bits(request, #FFFF)

    -- DEAL WITH TRACK BAR SCROLL ESTABLISHMENT
    if  ObjectClass[id]=TRACKBAR then
        if find(request, TRACKBARREQUESTS) then
            return c_func(xSendMessage, {ObjectHwnd[id], TBM_GETPOS, 0, 0})
        end if
        return {}
    end if

    -- DEAL WITH SCROLL CONTROLS - note they are not automatic, you have to do everything except for EDIT controls
    ------------------------------
    hwnd = ObjectHwnd[id]
    ssize = sizeofstruct(SCROLLINFO)

    -- allocate space for the structure
    lpsi = allocate_Scroll()

    -- set this member to retrieve all parameters
    poke4(lpsi + SCROLLINFO_cbSize, ssize)
    poke4(lpsi + SCROLLINFO_fMask,  SIF_ALL)

    -- make the function call
    void = c_func(xGetScrollInfo, {hwnd, fnBar, lpsi})

    -- exit if the function was unsuccessful
    if not void then
        return {}
    end if

    -- retrieve the values
    minp        = peek4s(lpsi + SCROLLINFO_nMin)
    maxp        = peek4s(lpsi + SCROLLINFO_nMax)
    page        = peek4u(lpsi + SCROLLINFO_nPage)
    pos         = peek4s(lpsi + SCROLLINFO_nPos)
    trackpos = peek4s(lpsi + SCROLLINFO_nTrackPos)

    max_move = maxp - page + 1

    -- default value
    temp = pos

    -- process each scroll request, note dragging has first priority
    if request=SB_THUMBTRACK then--or request=SB_THUMBPOSITION then
        temp = trackpos

--PL 15/7/2012 [DEV] both these are 3... (fixme)
--  elsif request=SB_PAGEDOWN or request=SB_PAGERIGHT then
    elsif request=SB_PAGEDOWN then
        temp += page

--... and both these are 2
--  elsif request=SB_PAGEUP or request=SB_PAGELEFT then
    elsif request=SB_PAGEUP then
        temp -= page

--... and both these are 1
--  elsif request=SB_LINEDOWN or request=SB_LINERIGHT then
    elsif request=SB_LINEDOWN then
        temp += 1

--... and both these are 0
--  elsif request=SB_LINEUP or request=SB_LINELEFT then
    elsif request=SB_LINEUP then
        temp -= 1

    elsif request=SB_BOTTOM then
        temp = max_move

    elsif request=SB_TOP then
        pos = minp

    else -- must be other scroll message that I don't want to process
        return {}

    end if

    -- ensure boundaries are maintained
    if temp<minp then
        temp = minp
    elsif temp>max_move then
        temp = max_move
    end if

    -- exit if no real movement occurred
    if temp=pos then
--      free(lpsi)
        return {}--temp
    end if

    -- update scroll info
    poke4(lpsi + SCROLLINFO_nPos, temp)
    void = c_func(xSetScrollInfo, {hwnd, fnBar, lpsi, True})

    -- exit
    return temp

end function





function proc_SizeMessage(integer id)
atom hwnd, struct, hwndHscroll, hwndVscroll
integer top, extent, breadth, width, height

    hwnd = ObjectHwnd[id]

    -- allocate space for RECT
    struct = allocate_Rect()

    -- get the raw client coordinates of the window
    if c_func(xGetClientRect, {hwnd, struct}) then
        extent = peek4s(struct + 8) -- New Width of client area
        breadth = peek4s(struct + 12) -- New Height of client area
    else
        return 0
    end if

    -- resize the toolbar, if any
    top = 0
    hwnd = ObjectExtra[id][TOOLBAR]
    if hwnd!=UNDEFINED then
        hwnd = ObjectHwnd[hwnd]
        if c_func(xIsWindowVisible,{hwnd}) then
            void = c_func(xSendMessage,{hwnd,WM_SIZE,0,0})
            -- add the height of the toolbar to the y coord
            if c_func(xGetClientRect, {hwnd, struct}) then
                top = peek4s(struct+12)+4
            end if
        end if
    end if

    -- resize the status bar, if any
    hwnd = ObjectExtra[id][STATUSBAR]
    if hwnd!=UNDEFINED then
        hwnd = ObjectHwnd[hwnd]
        if c_func(xIsWindowVisible,{hwnd}) then
            void = c_func(xSendMessage,{hwnd,WM_SIZE,0,0})
            -- deduct the height of the status bar from the y coord
            if c_func(xGetClientRect, {hwnd, struct}) then
                breadth -= peek4s(struct+12)
            end if
        end if
    end if

    -- calculate height of the horizontal scroll bar, if any
    hwndHscroll = ObjectExtra[id][HSCROLL]
    height = 0
    if hwndHscroll!=UNDEFINED then
        hwndHscroll = ObjectHwnd[hwndHscroll]
        if c_func(xIsWindowVisible,{hwndHscroll}) then
            void = c_func(xGetClientRect,{hwndHscroll,struct})
            height = peek4s(struct+12)
            breadth -= height
        end if
    end if

    -- calculate size of the vertical scroll bar, if any
    hwndVscroll = ObjectExtra[id][VSCROLL]
    width = 0
    if hwndVscroll!=UNDEFINED then
        hwndVscroll = ObjectHwnd[hwndVscroll]
        if c_func(xIsWindowVisible,{hwndVscroll}) then
            void = c_func(xGetClientRect,{hwndVscroll,struct})
            width = peek4s(struct+8)
            extent -= width
        end if
    end if

    -- size HScroll if any
    if height then
        void = c_func(xMoveWindow,{hwndHscroll,0,breadth-1,extent,height,True})
    end if

    -- size VScroll if any
    if width then
        void = c_func(xMoveWindow,{hwndVscroll,extent+1,top,width,breadth-top,True})
    end if

    return {0, top, extent, breadth}

end function



function proc_MouseMessage(atom lParam)
integer xPos, yPos

    xPos = and_bits(lParam, #FFFF)  if xPos>32767 then xPos -= 65536 end if
    yPos = floor(lParam / #10000)   if yPos>32767 then yPos -= 65536 end if

    return {xPos, yPos}

end function

--WM_MOUSEMOVE
--fwKeys = wParam;        // key flags
--xPos = LOWORD(lParam);  // horizontal position of cursor
--yPos = HIWORD(lParam);  // vertical position of cursor


global function isMouseMsg(integer msg)
    if msg>=WM_MOUSEMOVE and msg<=WM_MBUTTONDBLCLK then
        return True
    elsif msg=WM_MOUSEHOVER then
        return True
    elsif msg=WM_MOUSELEAVE then
        return True
    elsif msg=WM_MOUSEACTIVATE then
        return True
    end if
    return False
end function


global procedure trackMouseEvent(integer id, atom flags, atom hovertime)
atom hWnd, pTME
integer size

    hWnd = ObjectHwnd[id]
    size = sizeofstruct(TRACKMOUSEEVENT)
    pTME = allocate(size)

    poke4(pTME+TME_cbSize, size)
    poke4(pTME+TME_dwFlags, flags)
    poke4(pTME+TME_hwndTrack, hWnd)
    poke4(pTME+TME_dwHoverTime, hovertime)

    c_proc(xTrackMouseEvent,{pTME})

    free(pTME)

end procedure


global function findMouse()
    return getID(c_func(xGetCapture,{}))
end function

global procedure captureMouse(integer id)
    void = c_func(xSetCapture,{ObjectHwnd[id]})
end procedure


global procedure releaseMouse()
    void = c_func(xReleaseCapture,{})
end procedure

---------------------------

procedure runIdle()-- run IDLE code if one has been set and no msg's are pending
    -- flags parameter in API function can be combination of following:
-- QS_ALLEVENTS An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue.
-- QS_ALLINPUT      Any message is in the queue.
-- QS_HOTKEY        A WM_HOTKEY message is in the queue.
-- QS_INPUT         An input message is in the queue.
-- QS_KEY           A WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue.
-- QS_MOUSE         A WM_MOUSEMOVE message or mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).
-- QS_MOUSEBUTTON   A mouse-button message (WM_LBUTTONUP, WM_RBUTTONDOWN, and so on).
-- QS_MOUSEMOVE A WM_MOUSEMOVE message is in the queue.
-- QS_PAINT         A WM_PAINT message is in the queue.
-- QS_POSTMESSAGE   A posted message (other than those just listed) is in the queue.
-- QS_SENDMESSAGE   A message sent by another thread or application is in the queue.
-- QS_TIMER         A WM_TIMER message is in the queue.

    if IDLEROUTINE!=UNDEFINED then
        while IDLEON do
            if c_func(xGetQueueStatus, {QS_ALLINPUT})>=#FFFF then exit end if
            call_proc(IDLEROUTINE,{})
        end while
    end if

end procedure


-- IDLE system enhancements, courtesy Pete Lomax 1.4.05

global procedure startIdle(integer msec)
    -- msec is the granularity
    if IDLEON=0 and IdleTimer!=UNDEFINED then
        startTimer(IdleTimer, PrimaryWindowID, msec)
    end if
    IDLEON = 1
end procedure


global procedure stopIdle()
    IDLEON = 0
    if IdleTimer!=UNDEFINED then
        stopTimer(IdleTimer)
    end if
end procedure


function HypProcMouse(integer id, atom hwnd, atom msg, atom wParam, atom lParam)
integer isin, iscaptured
sequence temp

    temp = proc_MouseMessage(lParam) -- client coords
    isin = isPointIn(temp[1], temp[2], getClientRect(id))
    iscaptured = (hwnd = c_func(xGetCapture,{}))

    if msg=WM_MOUSEMOVE then
        if wParam then end if   --DEV suppress warnings
        if isin and not iscaptured then
            captureMouse(id)
--PL 1/2/09
--          ObjectExtra[id] = setCursor(HandCursor) -- set new cursor & store old one
            hwnd = setCursor(HandCursor) -- set new cursor,
            ObjectExtra[id] = hwnd       -- & store old one
            return 0
        elsif not isin and iscaptured then
            void = setCursor(ObjectExtra[id])
            releaseMouse()
            return 0
        end if

    end if

    return 1

end function


-- HANDLER FOR PROGRESS BAR CONTROL
--function PrgProc(atom hWnd, atom msg, atom wParam, atom lParam)
--
--  -- special case: dialog box is being initialized, must return TRUE
--  if msg=WM_PAINT then
--
--      return 0
--
--  end if
--
--   -- Default processing for other messages.
--  return c_func(xDefWindowProc, {hWnd, msg, wParam, lParam})
--
--end function


--function DlgProc(atom hwnd, atom msg, atom wParam, atom lParam)
---- return FALSE for messages you don't handle and TRUE for those you do.
--
--  -- special case: dialog box is being initialized, must return TRUE
--  if msg=WM_INITDIALOG then
--      if lParam then end if   --DEV suppress warnings
--      return True
--
--  -- is Dialog Box being destroyed?
--  elsif msg=WM_DESTROY then
--      void = c_func(xEndDialog, {hwnd, False})-- can ONLY be used here
--      -- can abort Close process if returning FALSE
--
--  -- interpret WM_COMMAND  messages
--  elsif msg=WM_COMMAND then
--      wParam = and_bits(wParam, #FFFF)
--
--      if wParam=IDCANCEL then
--          void = c_func(xEndDialog, {hwnd, False})-- can ONLY be used here
--
--      elsif wParam=IDOK then
--          -- MP, CHECK that valid text strings were caught to confirm return flag
--          void = c_func(xEndDialog, {hwnd, True})-- can ONLY be used here
--
--      end if
--
--      return 0
--
----    elsif msg=WM_NCDESTROY then
----        void = postMessage(PrimaryWindowID, WM_ENTERIDLE, 0,0)
----        return 0
--
--  end if
--
--  -- all messages not handled must return FALSE
--  return False
--
--end function

--sequence shown shown={}

--with trace
function SubProc(atom hwnd, atom msg, atom wParam, atom lParam)
integer id, iHandler, objectType, objectClass
atom PrevWndProc
object temp, return_value

    -- prepare defaults for all messages
    id = getID(hwnd) -- IMPORTANT to get this value
    iHandler = HandlerRoutine[id]
    PrevWndProc = WndProcAddress[id]
--if not find(PrevWndProc,shown) then
--  ?PrevWndProc
--  shown = append(shown,PrevWndProc)
--end if
    return_value = 0


---- WM_COMMAND, beware not to handle this msg for combo (not list) controls
    if msg=WM_COMMAND then

        -- interpret parameters..
        temp = 0 -- default
        if lParam=0 then -- menu or accel key
            id = and_bits(wParam, #FFFF)
            if id=wParam then -- menu for sure
                --temp = 0
            else -- accelerator key
                temp = 1
            end if
        else -- control, say, Button
            id = getID(lParam)
            --temp = 0
        end if

        if id then
            objectClass = ObjectClass[id]
            if objectClass!=COMBO
            and (objectClass!=EDIT or ObjectParent[id]=0 or ObjectClass[ObjectParent[id]]!=COMBO) then
                -- call handler if available
                iHandler = HandlerRoutine[id]
                if iHandler!=UNDEFINED then
                    return_value = call_func(iHandler, {id, msg, floor(wParam / #10000), temp})
                    -- only use for return value here..
                    -- if Accelerated then the focus to the control or next available one
                    if temp and equal(return_value, 0) then
                        if Tab_isFocussable(id) then
                            setFocus(id)
                        else
                            moveFocusNextAvailable(id)
                        end if
                    end if
                end if
                return 0
            end if
        end if


    elsif ObjectType[id]=HyperText and isMouseMsg(msg) then
        if not HypProcMouse(id, hwnd, msg, wParam, lParam) then
            return 0
        end if


    elsif msg=WM_PAINT and ObjectType[id]=TabControl then
        -- ensure child controls are also repainted
        temp = getIndex(id)
        if temp then
            temp = ObjectChildren[temp]
            for i=1 to length(temp) do
                void = c_func(xInvalidateRect,{ObjectHwnd[temp[i]],NULL,0})
            end for
        end if


------------------------------ OWNER-DRAWN CONTROLS

    elsif msg=WM_DRAWITEM then
        return_value = proc_DrawItemMessage(wParam, lParam)
        if return_value then
            return True
        end if

------------------------------

-- WM_HSCROLL & WM_VSCROLL  -- Update scroll bar for any scroll messages, incl scrolling tabitems
    elsif (msg=WM_HSCROLL or msg=WM_VSCROLL) then
        objectType = ObjectType[id]
        if objectType=ListView then -- added 20/2/2011
            if and_bits(sendMessage(id, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0),LVS_EX_GRIDLINES) then
                repaintWindow(id,False)
            end if
        elsif objectType!=ListBox
          and objectType!=TreeView
          and objectType!=MultiEditText then

            -- STAND ALONE CONTROLS - Scroll bar OR trackbar controls OR TabControl arrow buttons
            if lParam then
                -- get the id of the control
                id = getID(lParam)
                -- do default processing for TAB arrow buttons the exit, do not trap for user
                if id=0 then -- must be tab control arrow button
                    return c_func(xCallWindowProc, {PrevWndProc, hwnd, msg, wParam, lParam})
                end if
                -- process scrollbar or trackbar messages (say, within TabControls)
                temp = proc_ScrollMessage(id,SB_CTL,wParam)
                -- call user handler if scroll processing was valid
                iHandler = HandlerRoutine[id]
                if atom(temp) and iHandler!=UNDEFINED then
                    void = call_func(iHandler, {id, msg, temp, 0})
                end if
            elsif msg=WM_VSCROLL then       -- VERTICAL Standard Window Scroll bars
                temp = proc_ScrollMessage(id,SB_VERT,wParam)
            else -- msg=WM_HSCROLL          -- HORIZONTAL Standard Window Scroll bars
                temp = proc_ScrollMessage(id,SB_HORZ,wParam) -- scroll bar generally
            end if

            return 0

        end if

-- WM_KEYDOWN or WM_SYSKEYDOWN
    elsif msg=WM_KEYDOWN or msg=WM_SYSKEYDOWN then
        if not proc_KeyDownMessage(id, msg, wParam, lParam) then
            return 0
        end if

-- WM_CHAR for EditText controls - remove annoying bell/click when tabbing
    elsif msg=WM_CHAR and ObjectType[id]=EditText then
        if wParam=VK_TAB then
            return 0
        end if

    elsif msg=WM_SETFOCUS then
        -- save the item being focussed on in the parent window
        if ObjectType[id]!=Window then
            temp = getParentWindow(id)
            if temp then
                ObjectExtra[temp][LASTFOCUS]=id
            end if
        end if
    end if


    -- if a handler has been set up then call it
    if iHandler!=UNDEFINED then

        -- handler has been set up so call it
        return_value = call_func(iHandler, {id, msg, wParam, lParam})

        if sequence(return_value) then
            if length(return_value)=2 then
                wParam = return_value[1]
                lParam = return_value[2]
            elsif length(return_value)=1 then
                return return_value[1]
            else
                FatalErr("Incorrect sequence length returned from handler in SubProc.")
            end if
        end if

    end if

    -- do default processing, if any
    return c_func(xCallWindowProc, {PrevWndProc, hwnd, msg, wParam, lParam})

end function


---------------------------------------------------------------
-- WndProcAddress is called by windows for messages that relate to windows only
-- or to the window owner of some controls

integer lv
function WndProc(atom hwnd, atom msg, atom wParam, atom lParam)
integer id, iHandler, iPart, nCode, item
object temp, return_value
sequence rect
atom struct, hdc
integer frtn

    -- find the control
    id = getID(hwnd)

    -- reject any non-valid id's (these do occur for a time at program commencement)
    if id=0 then
        return c_func(xDefWindowProc, {hwnd, msg, wParam, lParam})
    end if

    iHandler = HandlerRoutine[id]

    return_value = 0


-- IDLE MESSAGES
    if msg=WM_ENTERIDLE then
        runIdle()
        return 0

    elsif msg=WM_TIMER and wParam=IdleTimer then -- do not alter this line!!
        runIdle()
        return 0

    elsif isMouseMsg(msg) then -- mouse event occurred
        temp = proc_MouseMessage(lParam) -- {x, y} coords
        if iHandler!=UNDEFINED then
            return_value = call_func(iHandler, {id, msg, wParam, temp}) -- PL fixed bug here
        end if
        return 0

    elsif msg=WM_PAINT then
        -- get the DC & paint coordinates
        struct = allocate_Paint()
        hdc = c_func(xBeginPaint,{hwnd,struct})
        temp = peek4u({struct+PAINTSTRUCT_rcPaint,4})
        -- extract client paint coords & send to the handler routine with the DC
        if iHandler!=UNDEFINED then
            void = call_func(iHandler, {id, msg, hdc, temp})
        end if
        -- release the DC
        c_proc(xEndPaint, {hwnd, struct})
        return 0

    elsif msg=WM_KEYDOWN 
       or msg=WM_SYSKEYDOWN then
        if iHandler!=UNDEFINED then
            return_value = call_func(iHandler, {id, msg, wParam, lParam})
        end if
        if equal(return_value, 0) then
            if not proc_KeyDownMessage(id, msg, wParam, lParam) then
                return 0
            end if
        end if
        return c_func(xDefWindowProc, {hwnd, msg, wParam, lParam})


    elsif (msg=WM_HSCROLL or msg=WM_VSCROLL) and ObjectType[id]!=ListBox then

        -- Update scroll bar for any scroll messages
        
        if lParam then              -- stand-alone scroll bar controls (includes trackbar controls)
            hwnd = lParam
            id = getID(hwnd)
            iHandler = HandlerRoutine[id]
            iPart = SB_CTL

        elsif msg=WM_VSCROLL then   -- VERTICAL Standard Window Scroll bars
            iPart = SB_VERT

        else                        -- HORIZONTAL Standard Window Scroll bars
            iPart = SB_HORZ

        end if

        -- was legitimate scroll event triggered?
        temp = proc_ScrollMessage(id,iPart,wParam)
        if atom(temp) and iHandler!=UNDEFINED then
            void = call_func(iHandler, {id, msg, temp, 0})
        end if

        return 0


-- COMMAND MESSAGES
    -- intercept & redirect the broad WM_COMMAND msg
    elsif msg=WM_COMMAND then

        -- interpret parameters..
        if lParam=0 then -- menu or accel key
            id = and_bits(wParam, #FFFF)
            if id=wParam then -- menu for sure
                --lParam = 0
            else -- accelerator key
                lParam = 1
            end if
        else -- control, say, Button
            id = getID(lParam)
--          lParam = 0
            lParam = wParam
        end if

        -- call handler if available
        if id then
            iHandler = HandlerRoutine[id]
            if iHandler=UNDEFINED and ObjectParent[id] then
                iHandler = HandlerRoutine[ObjectParent[id]]
            end if
            if iHandler!=UNDEFINED then
                return_value = call_func(iHandler, {id, msg, floor(wParam / #10000), lParam})
            end if
        end if
        return 0


-- NOTIFY MESSAGE (FROM TABCONTROL?)
    elsif msg=WM_NOTIFY then

        -- get handle & id of the control
        hwnd = peek4u(lParam)
        id = getID(hwnd)

        -- get notification code
        nCode = peek4s(lParam + NMHDR_code)

        -- trap notifications if from tab controls
        if id and ObjectType[id] = TabControl
        and (nCode=TCN_SELCHANGING or nCode=TCN_SELCHANGE) then

            -- get the tab item
            iPart = sendMessage(id, TCM_GETCURSEL, 0, 0)
            iPart += 1 -- make 1-based

            iPart = ObjectChildren[id][iPart] -- iPart is now the id of the tabitem

            -- do not allow any clicking change to be made TO a disabled TabItem
            if nCode=TCN_SELCHANGING then

                -- get the coords of the arrow when the message was made
                temp = c_func(xGetMessagePos,{})
                -- populate a structure
                struct = allocate_TextSpace(sizeofstruct(TC_HITTESTINFO))
                poke4(struct+POINT_x, and_bits(temp, #FFFF))
                poke4(struct+POINT_Y, floor(temp/#10000))
                -- convert coords
                void = c_func(xScreenToClient,{hwnd,struct})
                -- test coords to see if a hit was definitely made on a tab
                temp = sendMessage(id, TCM_HITTEST, 0, struct) + 1
                if temp and and_bits(peek4u(struct+TC_HITTESTINFO_flags), TCHT_ONITEM) then -- valid hit
                    temp = ObjectChildren[id][temp] -- temp is now the id of the tabitem
                    if ObjectExtra[temp]=0 then -- has struck a disabled tab item
                        return True -- to prevent change
                    end if
                end if
            end if

            -- attempt to get item handler, if unavailable then get tab control handler
            iHandler = HandlerRoutine[iPart]
            if iHandler=UNDEFINED then
                iHandler = HandlerRoutine[id]
            end if

            -- call the item handler if possible
            if iHandler!=UNDEFINED then
                return_value = call_func(iHandler, {iPart, WM_NOTIFY, nCode, lParam})
            end if

---------------

            -- is the tab closing?
            if nCode=TCN_SELCHANGING and return_value=0 then
                setVisible(ObjectChildren[iPart],False)

            -- is the tab opening?
            elsif nCode=TCN_SELCHANGE then
                setVisible(ObjectChildren[iPart],True)

            end if

            return return_value

---------------

        elsif id and ObjectType[id]=ListView then
            iHandler = HandlerRoutine[id]
            wParam = nCode
            if wParam=LVN_ITEMCHANGED 
-- 5/9/2010 (not ideal, but...)
or wParam=LVN_ITEMACTIVATE
            then
--?{peek4s(lParam + NMLISTVIEW_iItem) + 1}
                ObjectExtra[id][3] = peek4s(lParam + NMLISTVIEW_iItem) + 1  -- save selection
            elsif wParam=LVN_GETDISPINFO then
                frtn = ObjectExtra[id][4]   -- format routine
                if frtn!=-1 then
                    lv = lParam + LVDISPINFO_LVITEM
                    mask = peek4s(lv + LVITEM_mask)
                    item = peek4s(lv + LVITEM_iItem)+1
                    if and_bits(mask,LVIF_IMAGE) then
                        poke4(lv + LVITEM_iImage,call_func(frtn,{item,0}))
                    end if
                    if and_bits(mask,LVIF_TEXT) then
                        lParam = peek4s(lv + LVITEM_iSubItem)+1
                        temp = call_func(frtn,{item,lParam})
                        -- Check the 260 byte limit:
                        if sequence(temp)   -- Status is an atom
                        and length(temp)>260 then
                            temp = temp[1..258]&".."
                        end if
                        poke(peek4s(lv + LVITEM_pszText),temp&0)
                    end if
--                  if and_bits(mask,LVIF_STATE) then
--puts(1,"LVIF_STATE\n")
--                      ?1
--                  end if
                    poke4(lv + LVITEM_state,LV_IS_CHECKED)
                    return 0
                end if
            elsif wParam=LVN_COLUMNCLICK
              and iHandler!=UNDEFINED then
                lParam = peek4s(lParam + NMLISTVIEW_iSubItem) + 1   -- SortColumn
                if lParam=ObjectExtra[id][5] then -- SortColumn=LastSortColumn
                    ObjectExtra[id][5] = -1
                    void = call_func(iHandler,{id,msg,wParam,{lParam,-1}})
                else
                    ObjectExtra[id][5] = lParam
                    void = call_func(iHandler,{id,msg,wParam,{lParam,1}})
                end if
                return 0
            end if
        elsif id and ObjectType[id]=TreeView then
            iHandler = HandlerRoutine[id]
            wParam = nCode
            if wParam = TVN_SELCHANGED then
                ObjectExtra[id][3] = peek4s(lParam + NMTREEVIEW_itemNew + TVITEM_lParam)    -- save selection
            end if
        end if

    elsif msg=WM_CTLCOLOREDIT then
        id = getID(lParam)
        if id then
            iHandler = HandlerRoutine[id]
            -- call user handler
            if iHandler!=UNDEFINED then
                return_value = call_func(iHandler,{id,msg,wParam,lParam})
                if return_value then -- user wants to change color
                    return return_value
                end if
            end if
        end if
        return c_func(xDefWindowProc, {hwnd, msg, wParam, lParam})



    elsif msg=WM_SIZE then

        temp = proc_SizeMessage(id)

        -- call user handler
        if iHandler!=UNDEFINED and sequence(temp) then
            void = call_func(iHandler,{id,msg,wParam,temp})
        end if

        return c_func(xDefWindowProc, {hwnd, msg, wParam, lParam})



    elsif msg=WM_SIZING 
       or msg=WM_MOVING then

        -- ensure that the background processing can still occur
        runIdle()

        -- call the handler, if any
        if iHandler!=UNDEFINED then
            rect = peek4s({lParam,4})
            return_value = call_func(iHandler, {id, msg, wParam, rect})
            -- has user altered the coordinate values?
            if sequence(return_value) then
                poke4(lParam, return_value)
                return 1 -- True
            end if
        end if
        return 0 -- False


    elsif msg=WM_CLOSE then

        if iHandler!=UNDEFINED then
            return_value = call_func(iHandler, {id, msg, wParam, lParam})
            if return_value then
                return 1
            end if
        end if
        if id=PrimaryWindowID then
            void = c_func(xDestroyWindow,{hwnd})
        else
            if ObjectType[id]=Window
            and ObjectParent[id] then
                hwnd = getWindowHwnd(ObjectParent[id])
            else
                hwnd = getWindowHwnd(id)
            end if
            if hwnd!=NULL then c_proc(xSetFocus, {hwnd}) end if
            setVisible(id, False)
        end if
        return 0


    -- MUST handle this message
    elsif msg=WM_DESTROY and id=PrimaryWindowID then

        -- post Quit message
        c_proc(xPostQuitMessage, {0})

        -- delete all DIB sections
--      void = deleteDib(0)

        -- delete all *managed* image lists
--      destroyManagedImageLists()

        -- unsubclass all subclassed controls
        for obj_id=1 to length(ObjectType) do
            unsubClassControl(obj_id)
        end for

        -- destroy all non-attached popup Menus
        for obj_id=1 to length(ObjectType) do
            if ObjectType[obj_id]=Menu and ObjectParent[obj_id]=UNDEFINED then
                void = c_func(xDestroyMenu,{ObjectHwnd[obj_id]})
            end if
        end for

        -- destroy all menu brushes
        void = c_func(xDeleteObject,{MENUBRUSH_BORDER})
        void = c_func(xDeleteObject,{MENUBRUSH_ICON})
        void = c_func(xDeleteObject,{MENUBRUSH_SELECT})
        void = c_func(xDeleteObject,{MENUBRUSH_NORMAL})
        void = c_func(xDeleteObject,{MENUBRUSH_TOPSELECT})

        -- set exit flag
        return  0

    elsif msg=WM_DRAWITEM then
        return_value = proc_DrawItemMessage(wParam, lParam)
        if return_value then
            return True
        end if

    elsif msg=WM_MEASUREITEM then
        return_value = proc_MeasureItemMessage(id, wParam, lParam)
        if return_value then
            return True
        end if

    elsif msg=WM_SETFOCUS then
        -- focus on the saved item rather than the window
        -- (for task switching, eg Alt-Tab)
        if ObjectType[id]=Window then
            temp = ObjectExtra[id][LASTFOCUS]
            if temp!=UNDEFINED then
                if ObjectType[temp]!=Window then
                    setFocus(temp)
                    return 0
                end if
            end if
        end if
    end if


    -- was user handler set up for this window/control?
    if iHandler!=UNDEFINED then -- call user handler
        return_value = call_func(iHandler, {id, msg, wParam, lParam})
        if sequence(return_value) then
            if length(return_value)=1 then
                return return_value[1]
            elsif length(return_value)=2 then
                wParam = return_value[1]
                lParam = return_value[2]
            else
                FatalErr("Incorrect parameters returned from handler.")
            end if
        end if
    end if

    -- do default processing & exit
    return c_func(xDefWindowProc, {hwnd, msg, wParam, lParam})

end function


---------------------------------------------------------------

WndProcCallBack = CallBack(routine_id("WndProc"))
SubProcCallBack = CallBack(routine_id("SubProc"))
--DlgProcCallBack = CallBack(routine_id("DlgProc"))
--PrgProcCallBack = CallBack(routine_id("PrgProc"))

---------------------------------------------------------------



function translateAccelerator()
atom hwnd
integer id, pID, index, vkey


    -- fast out?
    if peek4u(lpMSG+MSG_message)!=WM_SYSKEYDOWN then
        return 0
    end if

    -- genuine ARWEN control?
    hwnd = peek4u(lpMSG)
    id = getID(hwnd)
    if not id then
        return 0
    end if

    -- get the parent window since this is where the accelerator WM_COMMAND will be sent
    pID = getParentWindow(id)
    if not pID then
        return 0
    end if

    -- attempt to find the key in the parent windows list
    vkey = peek4u(lpMSG+MSG_wParam)
    index = find(vkey, ObjectExtra[pID][ACCELKEYS])
    if not index then
        return 0
    end if

    id = ObjectExtra[pID][ACCELIDS][index]

    if not isEnabled(id) then
        return 0
    end if

    id = #10000 + and_bits(id, #FFFF) -- dolly up as if genuine accelerator

    hwnd = ObjectHwnd[pID]

    -- modify message
    poke4(lpMSG,                hwnd)
    poke4(lpMSG+MSG_message,    WM_COMMAND)
    poke4(lpMSG+MSG_wParam,     id)
    poke4(lpMSG+MSG_lParam,     0)

    return 1

end function


function pumpMessage(atom hwnd)

    if IDLEROUTINE!=UNDEFINED then
        while IDLEON do
            if c_func(xPeekMessage,{lpMSG, hwnd, 0, 0, PM_NOREMOVE}) then exit end if
            call_proc(IDLEROUTINE,{})
        end while
    end if

    if c_func(xGetMessage, {lpMSG, NULL, 0, 0})<=0 then
        return 0
    end if

    if not translateAccelerator() then
        c_proc(xTranslateMessage,{lpMSG})
    end if
    void = c_func(xDispatchMessage,{lpMSG}) -- used by xTranslateMessage{} AND translateAccelerator()

    return 1

end function


global procedure doAllEvents()
    void = pumpMessage(0)
end procedure

global procedure doEvents(integer id)
atom hwnd

    if c_func(xGetQueueStatus, {QS_ALLINPUT})>#FFFF then
        -- "" result: hiWord is types of messages currently in the queue

        -- get the correct handle
        if id then
            hwnd = ObjectHwnd[id]
        else
            hwnd = 0
        end if

        -- process message, if any
        if c_func(xPeekMessage, {lpMSG, hwnd, 0, 0, PM_REMOVE}) then
            if not translateAccelerator() then
                c_proc(xTranslateMessage,{lpMSG})
            end if
            void = c_func(xDispatchMessage,{lpMSG}) -- used by xTranslateMessage{} AND translateAccelerator()
        end if
    end if
end procedure

global procedure OverRidePrimaryWindowID(integer id)
    PrimaryWindowID = id
end procedure

sequence cleanupids = {}

global procedure attachCleanUp(integer rid)
    cleanupids = append(cleanupids,rid)
end procedure

global procedure WinMain(integer id, integer sw_style) -- main routine

    -- check to see if any window has been made and abort if there hasn't
    if PrimaryWindowID=UNDEFINED then
        FatalErr("Primary Window has not been created in " & AppClassName & " library.")
    end if

    -- check that correct window is presented
    if PrimaryWindowID!=id then
        -- if you really meant to do this, eg "app.exe" opens a normal input
        -- window, whereas if copied/renamed to "appstat.exe" it displays eg
        -- statistical analysis of some sort, ie the app really does have
        -- two main windows, then use OverRidePrimaryWindowID().
        FatalErr("Primary Window error in " & AppClassName & " library.")
    end if

    -- Officially start the application
    isAppStarted = True

    -- create entry to hold IDLE timer id
    IdleTimer = createTimer()

    -- display window, finally
    openWindow(PrimaryWindowID, sw_style)

    -- reserve scratch space for each message
--    lpMSG = allocate(sizeofstruct(MSG))

    -- Message Loop
    while pumpMessage(NULL) do
        -- iterate all messages for thread
    end while

--  void = destroy(IdleTimer)
    free(lpMSG)
    deallocate_AllMemory() -- free all memory allocated for the scratchpads

    free(LVI)
    free(LV)
    free(lf)
    free(TVI)
    free(TVIS)

    for i=1 to length(cleanupids) do
        call_proc(cleanupids[i],{})
    end for

end procedure


----------------------------------------------------------------------------
