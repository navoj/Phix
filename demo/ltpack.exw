--
-- ltpack.exw
-- ==========
--  Simple test harness used in the development of packed linetables, 
--   may be useful for possible future experimentation/bug-fixing.
--  These routines have now become part of p[w].exe.
--      (function ltpack(sequence linetab) in pemit2.e)
--      (function unpacklt(sequence linetab) in plist.e)
--      (plus "if string(linetab) then -- compiled (deltas packed to string)" in pdiagN.e)

-- DEV/TODO.
--  I think I'm just leaving the last entry as a big +ve number..
--  Suppose (with some poetic licence) I have:
--      1:  function p()
--      2:      mov eax,#01020304
--      3:      jmp :%opRetf
--      4:  end function
--  And that gets me a line table of {0,5,10}. (Check that carefully!) When I pack, I convert
--  offsets to deltas, giving {5,5,10} - last value is pointless and could/should be removed,
--  and of course reconstituted by unpacklt(). Insignificant really, but in the name of total
--  perfection, meanwhile I have several rather more important matters to attend to...!
--
-- Also, not really much to do with this, but, at some point I adopted {-2} as the no-dbg
--  linetab. 0 (and not packing or unpacking) seems like a better choice...
--

-- Snippets of a list.asm on which the following tests were based (note much line cropping):
--/*
;     1 --format PE32
    call #00440831 (:>initFEH)            ;#0043C000: 350 2C480000               v  00 00  1   1      
    call #0043FAB8 (:>initFPU)            ;#0043C005: 350 AE3A0000               v  00 00  1   2      
    call #004409FA (:>initStack)          ;#0043C00A: 350 EB490000               v  00 00  1   3      
;   193 include test\t38bltns.exw -- OK
    mov rdi,495                           ;#0043C00F: 48:307307 EF010000         uv 80 00  1   4      
    call :%opCallOnce (t38bltns.exw)      ;#0043C016: 350 544A0000               v  00 00  1   4      
;   295 ?9/0
    call #0044510B (:%pDiv0)              ;#0043C01B: 350 EB900000               v  00 00  1   5      
;   299 puts1(done)
    mov rcx,1                             ;#0043C020: 48:307301 01000000         uv 02 00  1   6      
    mov rdx,492                           ;#0043C027: 48:307302 EC010000         vu 04 00  1   6      
    call #00440A05 (:%opFrame) (puts1)    ;#0043C02E: 350 D2490000               v  00 00  1   7      
    mov rsi,[#00403350] (done)            ;#0043C033: 48:213065 1673FCFF         uv 40 00  1   8      
    mov [rbp] (s),rsi                     ;#0043C03A: 48:211165 00               uv 00 60  1   9 40   
    add qword[rbx+rsi*4-16],1             ;#0043C03E: 48:203104263 F0 01         u  00 48  3  11    *40*
    mov qword[retaddr],#0043C051          ;#0043C044: 48:307105 20 51C04300      vu 00 20  1  13      
    jmp #0043C0A8 (code:puts1)            ;#0043C04C: 351 57000000               v  00 00  1  14      
;   300 getc0()
    xor rcx,rcx                           ;#0043C051: 48:061311                  uv 02 02  1  15      
    mov rdx,494                           ;#0043C054: 48:307302 EE010000         vu 04 00  1  15      
    call #00440A05 (:%opFrame) (getc0)    ;#0043C05B: 350 A5490000               v  00 00  1  16      
    mov qword[retaddr],#0043C06D          ;#0043C060: 48:307105 20 6DC04300      uv 00 20  1  17      
    jmp #0043C09E (code:getc0)            ;#0043C068: 351 31000000               v  00 00  1  17      
;   301 --
;   302 without warning
;   303 abort(0)
    xor rax,rax                           ;#0043C06D: 48:061300                  uv 01 01  1  18      
    call #0043C307 (:%opAbort)            ;#0043C070: 350 92020000               v  00 00  1  18      
    mov rdi,835                           ;#0043C075: 48:307307 43030000         uv 80 00  1  19      
    call :%opCallOnce (pfileioN.e)        ;#0043C07C: 350 EE490000               v  00 00  1  19      
    mov rdi,941                           ;#0043C081: 48:307307 AD030000         uv 80 00  1  20      
    call :%opCallOnce (pcfuncN.e)         ;#0043C088: 350 E2490000               v  00 00  1  20      
    mov rdi,992                           ;#0043C08D: 48:307307 E0030000         uv 80 00  1  21      
    call :%opCallOnce (pFloatN.e)         ;#0043C094: 350 D6490000               v  00 00  1  21      
    jmp #00440AA9 (:%opRetf)              ;#0043C099: 351 0B4A0000               v  00 00  1  22      
(#9E)
symtab[21]:{T_maintls,S_Proc,1,(K_wdb+K_ran),0,85,P,0,0,0,#0043C000,{0,-191,15,-101,27,-3,32,81,-2,109,158},1,E_none}
--*/
constant T_maintls = 1,S_Proc = 2,K_wdb = 4,K_ran = 8,P = 16,E_none = 32  -- (nb nonsense values)
constant sr = {T_maintls,S_Proc,1,(K_wdb+K_ran),0,85,P,0,0,0,#0043C000,{0,-191,15,-101,27,-3,32,81,-2,109,158},1,E_none}
-- (hand built from the above snippet of a list.asm)
constant tset = {{1,{#0043C000,#0043C005,#0043C00A,#0043C00F-1}},
                 {193,{#0043C00F,#0043C016,#0043C01B-1}},
                 {295,{#0043C01B,#0043C020-1}},
                 {299,{#0043C020,#0043C027,#0043C02E,#0043C033,#0043C03A,#0043C03E,#0043C044,#0043C04C,#0043C051-1}},
                 {300,{#0043C051,#0043C054,#0043C05B,#0043C060,#0043C068,#0043C06D-1}},
                 {303,{#0043C06D,#0043C070,#0043C075,#0043C07C,#0043C081,#0043C088,#0043C08D,#0043C094,#0043C099,#0043C099+4}},
                 {-1,{#0043C000-1,#0043C099+5}}}

constant
--              S_Name  = 1,    -- const/var/rtn name (now a ttidx number or -1)
--              S_NTyp  = 2,    -- Const/GVar/TVar/Nspc/Type/Func/Proc
--              S_FPno  = 3,    -- File and Path number
--              S_State = 4,    -- state flag. S_fwd/S_used/S_set etc
--              S_Nlink = 5,    -- name chain (see below)
--              S_Slink = 6,    -- scope/secondary chain (see below)
--              -- constants and variables [S_NTyp<=S_TVar]
--              S_vtype = 7,    -- variable type [see notes below]
--              S_value = 8,    -- value [see note below]
--              S_Clink = 9,    -- constant chain (S_NTyp=S_Const only, see below)
--              S_Tidx  = 9,    -- thread idx (S_NTyp=S_Tvar only) [BLUFF/DEV]
--              S_ErrV  = 10,   -- {'v', file, line, col}; see pmain.e[-35]
--              S_ConstChain = 10,  -- see notes below (constant ref/count optimisations)
--              S_Init  = 11,   -- Initialised chain (known init if non-0/see S_Const note below)
--              S_ltype = 12,   -- local type (see pltype.e)
--              S_maxlv = 13,   -- last entry for var (see pltype.e)
--              S_gInfo = 14,   -- (see note below)
--              S_gNew  = 15,
--              -- namespaces
--              S_nFno  = 7,    -- namespace fileno [see note below]
--              -- routines [S_NTyp>=S_Type]
--              S_sig   = 7,    -- routine signature, eg {'F',T_integer} (nb S_sig must be = S_vtype)
--              S_Parm1 = 8,    -- first parameter. (idx to symtab, follow S_Slink)
--              S_ParmN = 9,    -- minimum no of parameters (max is length(S_sig)-1)
--              S_Ltot  = 10,   -- total no of parameters, locals, and temporary vars
--                              -- (needed to allocate the stack frame space)
                S_il    = 11,   -- intermediate code (also backpatch list)
                S_ltab  = 12,   -- line table
                S_1stl  = 13    -- first line
--              S_Efct  = 14,   -- side effects
--              S_ErrR  = 15    -- {'R', file, line, col}; see pmain.e[-60]

integer lineno, lastline, returnoffset, linenxt, lti
sequence linetab
atom era
    linetab = sr[S_ltab]
    lastline = linetab[$]
with trace

integer expline
sequence expset
    -- NB this is the old code, see line ~380 for the replacement:
    for ti=2 to length(tset) do
    --?ti
        {expline,expset} = tset[ti]
        for j=1 to length(expset) do
--?{ti,j}
--trace(1)
            era = expset[j]

            lineno = sr[S_1stl]     -- line no of "procedure"/"function"/"type" keyword
--          linetab = sr[S_ltab]
--          lastline = linetab[$]

            if era=-1 then
?9/0 -- (not covered in this testset)
                -- (error occurred inside an opRetf.
                --  btw: for if return else return end if, this
                --  shows error on either return as the latter,
                --  since it is jmp opRetf not call opRetf...).
                returnoffset = lastline-1
            else
                returnoffset = era-sr[S_il]
            end if
            if returnoffset<0 or returnoffset>=lastline then
                lineno = -1
            else
                --
                -- Entries in the line table are negative to indicate a number
                --  of lines which emitted no code, or >=0 for a start offset
                --  relative to S_1stl/S_il. Additionally there is a dummy max 
                --  entry (added at the end of ilxlate) which helps to prevent 
                --  this running off into a subscript out of bounds error.
                -- Skip down the line table until the return address is (b)reached,
                --  - we only know this when we hit the next entry, hence linenxt.
                -- EG if linetab is {-2,0,24,36} then offsets 0..23 are S_1stl+2,
                --  offsets 24..35 are S_1stl+3; we only know that we should have
                --  stopped for an offset of 17 when we hit the 24, and the lineno 
                --  we want is that before the +1 triggered by the 0 (or whatever
                --  line adjustment we made on [2] when we decide to stop on [3]).
                --  Of course if the return offset is 24 then the error occurred
                --  on line S_1stl+2 since no code from S_1stl+3 has executed yet,
                --  whereas conversely if a machine error occurs at offset 24 then 
                --  clearly the problem is on line S_1stl+3 rather than S_1stl+2.
                --  Another example is linetab of {-14,#14,-3,#47...} and offset
                --  of #22. We only know that #14 is the right entry when we hit
                --  the #47, so there'll be a +1 and -(-3) that we must ignore.
                -- Lastly note that [era] is incredibly fiddly to set, especially
                --  for low-level routines several calls deep from user code. If
                --  this yields -1 suspect [era] rather than this code.
                --
                linenxt = lineno
                for i=1 to length(linetab) do
                    lti = linetab[i]
                    if lti<0 then       -- -n lines emitted no code
                        linenxt -= lti
                    else                -- start offset of next line
--                      if returnoffset<=lti then exit end if   -- all done
                        if returnoffset<lti then exit end if    -- all done
                        lineno = linenxt
                        linenxt += 1
                    end if
                end for
            end if
            if lineno!=expline then
                ?{lineno,expline}
                ?9/0
            end if
        end for
    end for

--function offgen(sequence offsets) [now part of ltpack()]
---- (assumes offsets[$] is positive)
--integer last = 0
--  for i=1 to length(offsets) do
--      if offsets[i]>=0 then
--          if last>0 then
--              offsets[last] = offsets[i]-offsets[last]
--          end if
--          last = i
--      end if
--  end for
----    if last then ?9/0 
----        offsets[last] = totalsize-offsets[last]
----    end if
--  return offsets
--end function

function genoff(sequence bytes_generated)
integer base = 0, tmp
    for i=1 to length(bytes_generated) do
        if bytes_generated[i]>0 then
            tmp = base
            base += bytes_generated[i]
            bytes_generated[i] = tmp
        end if
    end for
    return bytes_generated
end function

-- -128(#80): dword follows
-- -127(#81): word follows
function pack(sequence bg)
string res = repeat(' ',length(bg))
string c3 = repeat(#81,3)
string c5 = repeat(#80,5)
string this
sequence chunks = {}
integer bgi
    for i=length(bg) to 1 by -1 do
        bgi = bg[i]
        if bgi>=-126 and bgi<=127 then
            res[i] = and_bits(bgi,#FF)
        else
            if bgi>=-#8000 and bgi<=#7FFF then
                c3[2] = and_bits(floor(bgi/#100),#FF)
                c3[3] = and_bits(bgi,#FF)
                this = c3
            else
                c5[2] = and_bits(floor(bgi/#1000000),#FF)
                c5[3] = and_bits(floor(bgi/#10000),#FF)
                c5[4] = and_bits(floor(bgi/#100),#FF)
                c5[5] = and_bits(bgi,#FF)
                this = c5
            end if
            chunks = append(chunks,this&res[i+1..$])
            res = res[1..i-1]
        end if
    end for
    for i=length(chunks) to 1 by -1 do
        res &= chunks[i]
    end for
    return res
end function

with trace
function ltpack(sequence linetab)
-- (now in pemit2.e)
-- (assumes linetab[$] is positive)
integer last = 0
string res = repeat(' ',length(linetab))
string c3 = repeat(#81,3)
string c5 = repeat(#80,5)
string this
sequence chunks = {}
integer lti, ltl
    -- first convert +ve offsets to deltas 
    --  (nowt sensible to be done with -ve skips)
    for i=1 to length(linetab) do
        lti = linetab[i]
        if lti>=0 then
            if last>0 then
                linetab[last] = lti-ltl
            end if
            last = i
            ltl = lti
        end if
    end for
    -- pack to binary bytes, held in a string
    --  (requiring just over 25%, for 32-bit,
    --   ymmv, and just over 12.5% for 64-bit)
    for i=length(linetab) to 1 by -1 do
        lti = linetab[i]
--#7FE4
--if lti=33362 then trace(1) end if
        if lti>=-126 and lti<=127 then
            res[i] = and_bits(lti,#FF)
        else
--          if lti>=-#8000 and lti<=#7FFFF then
            if lti>=-#8000 and lti<=#7FFF then
                c3[2] = and_bits(floor(lti/#100),#FF)
                c3[3] = and_bits(lti,#FF)
                this = c3
            else
--puts(1,"biggie!\n")
                c5[2] = and_bits(floor(lti/#1000000),#FF)
                c5[3] = and_bits(floor(lti/#10000),#FF)
                c5[4] = and_bits(floor(lti/#100),#FF)
                c5[5] = and_bits(lti,#FF)
                this = c5
            end if
            chunks = append(chunks,this&res[i+1..$])
            res = res[1..i-1]
        end if
    end for
    for i=length(chunks) to 1 by -1 do
        res &= chunks[i]
    end for
    return res
end function

function unpack(sequence pbg)
integer skip = 0, byte
atom word, dword
sequence res = {}
    for i=1 to length(pbg) do
        if skip then
            skip -= 1
        else
            byte = pbg[i]
            if byte>#7F then
                if byte>#81 then
                    res = append(res,byte-#100)
                elsif byte=#81 then
                    word = pbg[i+1]*#100+pbg[i+2]
                    if word>#7FFF then
                        word -= #10000
                    end if
                    res = append(res,word)
                    skip = 2
                elsif byte=#80 then
                    dword = pbg[i+1]*#1000000+pbg[i+2]*#10000+pbg[i+3]*#100+pbg[i+4]
                    if dword>#7FFFFFFF then
                        dword -= #100000000
                    end if
                    res = append(res,dword)
                    skip = 4
                else
                    ?9/0
                end if
            else
                res = append(res,byte)
            end if
        end if
    end for
    return res
end function

function unpacklt(sequence linetab)
-- (now in plist.e)
integer skip = 0, byte
atom word, dword
sequence res = {}
integer base = 0, tmp
    for i=1 to length(linetab) do
        if skip then
            skip -= 1
        else
            byte = linetab[i]
            if byte>#7F then
                if byte>#81 then
                    res = append(res,byte-#100)
                elsif byte=#81 then
                    word = linetab[i+1]*#100+linetab[i+2]
                    if word>#7FFF then
                        word -= #10000
                    end if
                    res = append(res,word)
                    skip = 2
                elsif byte=#80 then
                    dword = linetab[i+1]*#1000000+linetab[i+2]*#10000+linetab[i+3]*#100+linetab[i+4]
                    if dword>#7FFFFFFF then
                        dword -= #100000000
                    end if
                    res = append(res,dword)
                    skip = 4
                else
                    ?9/0
                end if
            else
                res = append(res,byte)
            end if
        end if
    end for
    for i=1 to length(res) do
        if res[i]>0 then
            tmp = base
            base += res[i]
            res[i] = tmp
        end if
    end for
    return res
end function

--constant packedlt = pack(offgen(linetab))
constant packedlt = ltpack(linetab)
    ?packedlt
    if genoff(unpack(packedlt))!=linetab then ?9/0 end if
    if unpacklt(packedlt)!=linetab then ?9/0 end if

    linetab = packedlt

integer thisline, skip
integer base = 0, tmp

    for ti=1 to length(tset) do
--?ti
        {expline,expset} = tset[ti]
        for j=1 to length(expset) do
--?{ti,j}
--trace(1)
            era = expset[j]

--          lineno = sr[S_1stl]     -- line no of "procedure"/"function"/"type" keyword
--          linetab = sr[S_ltab]
--          lastline = linetab[$]

            returnoffset = era-sr[S_il]
            --
            -- Convert the offset to a line number.
            -- A raw line table, as built in pilx86.e, is {skip|offset} where
            --  skip is <0, meaning -n lines emitted no code, and
            --  offset is >=0, a start offset of the next code-emitting line.
            --  There is also a dummy max entry added at the end of ilxlate.
            --  A line table should never have two (or more) skips in a row.
            -- When interpreting, we can just use the raw table directly: skip down the
            --  table until the offset is (b)reached, though we only know that when we 
            --  hit the next entry, as detailed in the following.
            --  Example1: a raw linetab of {-2,0,24,36} means offsets 0..23 are S_1st+2,
            --            24..35 are S_1st+3, and <0/>=36 are out-of-bounds (so leave 
            --            lineno as -1). We only know that we should have stopped for an 
            --            offset of 17 when we hit the 24, and the lineno we want is that 
            --            before the +1 triggered by the 0 (or whatever line adjustment 
            --            we made on [2] when we decide to stop on [3]).
            --  Example2: for a linetab of {-14,#14,-3,#47...} and offset of #22, we only 
            --            know that #14 (S_1st+14) is the right entry when we hit the #47
            --            (S_1st+18), so there is a +1 and -(-3) that we must ignore.
            --            Note that while an exception at offset #47 means S_1st+18, a 
            --            return address of #47 would be the last call made by S_1st+14;
            --            hence add -1 when using a return address to report an error.
            -- When compiling, the linetab is packed: the offsets are converted to deltas
            --  (so most will be <=127) then #81,#80 used as lead-ins for word,dword to
            --  hold values that will not fit in a byte, and lastly stored as a "string"
            --  of binary (#00..#FF) bytes, making it just over 25% of the size, on 32
            --  bit systems, and just over 12.5% on 64 bit systems (ie worth having).
            --  A fairly straightforward decode of the next raw value (into lti) is
            --  followed by the same logic as above, except that when we start with a
            --  raw table we can test lastline directly, but not when unpacking it.
            -- Lastly note that [era] is incredibly fiddly to set, especially for
            --  low-level routines isolated several calls deep from user code. If
            --  the following yields -1, first suspect [era] rather than this code.
            --
            if string(linetab) then -- compiled (deltas packed to string)
                lineno = -1
                if returnoffset>=0 then
                    thisline = sr[S_1stl]
                    linenxt = thisline
                    skip = 0
                    base = 0
                    for i=1 to length(linetab) do
                        if skip then
                            skip -= 1
                        else
                            lti = linetab[i]
                            if lti>#7F then
                                if lti>#81 then
                                    lti = lti-#100
                                elsif lti=#81 then
                                    lti = linetab[i+1]*#100+linetab[i+2]
                                    if lti>#7FFF then
                                        lti -= #10000
                                    end if
                                    skip = 2
                                elsif lti=#80 then
                                    lti = linetab[i+1]*#1000000+linetab[i+2]*#10000+linetab[i+3]*#100+linetab[i+4]
                                    if lti>#7FFFFFFF then
                                        lti -= #100000000
                                    end if
                                    skip = 4
                                else
                                    ?9/0    -- (sanity check, should never happen)
                                end if
                            end if
                            if lti<0 then       -- -n lines emitted no code
                                linenxt -= lti
                            else                -- start offset of next line
                                tmp = base
                                base += lti
                                lti = tmp
--                              if returnoffset<=lti then exit end if   -- all done
                                if returnoffset<lti then
                                    lineno = thisline
                                    exit
                                end if  -- all done
                                thisline = linenxt
                                linenxt += 1
                            end if
                        end if
                    end for
                end if
            else -- interpreted (raw linetab, a dword-sequence, not converted to deltas/packed)
                lineno = sr[S_1stl]
                lastline = linetab[$]
                if returnoffset<0 or returnoffset>=lastline then
                    lineno = -1
                else
                    linenxt = lineno
                    for i=1 to length(linetab) do
                        lti = linetab[i]
                        if lti<0 then       -- -n lines emitted no code
                            linenxt -= lti
                        else                -- start offset of next line
--                          if returnoffset<=lti then exit end if   -- all done
                            if returnoffset<lti then exit end if    -- all done
                            lineno = linenxt
                            linenxt += 1
                        end if
                    end for
                end if
            end if
            if lineno!=expline then
                ?{lineno,expline}
                ?9/0
            end if
        end for
    end for


constant e820 = {-637,0,-23,5,6,-2,12,13,14,-71,20,-78,21,27,29,-2,31,35,37,39,44,46,-1,48,53,58,60,66,68,71,74,75,81,91,93,98,
                 100,-1,110,116,117,-3,123,-1,124,-42,132,-11,133,136,142,146,152,158,161,-1,163,169,172,175,178,180,183,185,
                 192,203,209,220,226,227,-1,228,-3,234,238,242,245,248,-1,252,-55,258,-4,263,264,266,269,275,-1,281,283,285,287,
                 293,298,302,306,-1,308,310,-2,312,314,-1,318,321,323,326,332,338,340,-33,342,-2,344,-5,347,350,353,357,359,361,
                 365,367,369,-1,372,376,-1,378,381,383,385,-1,388,392,395,397,401,405,-33,407,-4,412,413,416,420,423,426,430,437,
                 443,447,450,452,454,458,460,-1,463,-21,467,-14,470,473,477,481,-3,485,486,487,488,493,497,-23,499,501,-6,502,504,
                 509,-1,514,521,523,525,532,533,534,535,-7,536,541,542,543,544,-1,545,550,552,-1,559,562,564,567,569,-41,573,-9,
                 574,575,-10,576,-1,577,-4,583,584,590,-26,592,-1,594,-1,599,607,-11,613,619,622,628,635,637,644,646,647,-1,648,
                 -24,654,-1,659,661,-2,667,671,675,679,683,-1,687,-17,693,-3,695,699,701,703,710,716,-8,720,-3,722,723,-1,724,-1,
                 725,731,737,740,745,-1,750,752,754,756,759,-1,761,762,-23,763,767,769,775,782,784,790,792,795,798,-4,800,-1,806,
                 810,812,814,819,821,828,829,-1,830,-3,836,841,-8,843,-2,848,-45,854,-3,856,862,866,-7,869,-3,874,-1,880,881,882,
                 889,900,906,913,919,920,-1,921,-20,927,931,-4,933,-2,935,938,942,-7,946,-9,952,953,954,956,-1,958,961,964,970,
                 976,979,981,987,993,999,1002,1008,-19,1009,-3,1014,1016,1019,-6,1022,-3,1028,1032,-1,1035,1038,1040,1045,-19,
                 1050,1056,1057,1058,1061,1068,1079,1085,1092,1098,1099,1100,-1,1101,-22,1107,1111,1116,1118,-1,1120,1124,1127,-1,
                 1131,-2,1135,-20,1141,1142,1143,1145,1147,1150,-13,1151,-7,1157,-1,1158,1164,-2,1167,1171,1174,1177,-1,1180,-13,
                 1183,-3,1188,1189,1190,1191,1192,1199,1206,1212,1219,1225,1232,1238,1239,-1,1240,-32,1246,1253,1259,1266,1273,-8,
                 1277,-12,1283,1287,1289,-19,1295,-1,1300,1301,1302,1303,-12,1304,-5,1309,1312,1315,1317,1319,1323,1325,1327,-1,
                 1330,1337,1343,1347,-1,1349,1352,1354,1356,-32,1359,1363,-3,1366,1369,1371,1373,1376,1379,1385,1389,1392,1395,
                 1399,1405,1409,1413,-41,1417,-3,1419,1425,1428,1431,1434,1440,-12,1446,-7,1447,-1,1450,1456,1462,1468,1474,1477,
                 1482,-1,1487,-1,1489,1491,1493,1496,-2,1498,1504,1507,-24,1513,1515,1516,-4,1517,-11,1523,1524,1527,-4,1530,-2,
                 1532,1533,1534,1535,1536,1537,1538,1543,-10,1546,-3,1547,1554,1560,1567,1574,1581,1587,1594,1600,1601,-1,1602,-22,
                 1608,1612,1615,1618,1621,1624,1627,1630,-10,1633,-10,1639,-1,1642,-7,1643,-1,1645,1651,1652,1655,1660,1662,1668,
                 1672,1674,1677,1680,1683,1690,1694,1701,-32,1702,-7,1703,-1,1705,1711,1712,1716,1721,1723,1729,1731,1735,1738,
                 1741,1744,1747,1754,1758,1765,-35,1766,-17,1767,-1,1768,1771,1774,1777,1780,1782,1785,1788,1791,1793,-1,1795,1796,
                 1798,1800,1802,1804,1806,1808,1814,1816,1821,1823,-1,1828,-38,1829,-3,1830,1836,1838,1842,1847,1849,1852,1854,
                 1857,1858,-1,1859,1862,1864,1869,-1,1871,-1,1875,1880,1885,1887,1893,1896,1899,1905,1908,1915,1917,1920,-38,1921,
                 -15,1922,1925,1932,1934,-1,1935,-1,1942,-1,1945,-4,1948,1949,-23,1952,1956,-2,1958,1962,-1,1968,1970,1975,1980,
                 -13,1981,-3,1983,1987,-1,1993,1996,1999,-10,2004,-4,2005,2009,-1,2015,-1,2022,-1,2025,-1,2027,-14,2030,-1,2032,
                 2035,2038,2041,2044,2047,2048,2053,2054,2056,2058,2060,2062,-23,2064,2067,2069,2075,2077,2082,2085,2087,-12,2094,
                 -1,2096,2097,2104,-1,2107,-2,2110,-2,2112,2113,-16,2120,-3,2124,-3,2126,2130,-1,2136,2137,2140,2145,2150,-17,2151,
                 -2,2153,-3,2156,-3,2158,2162,-1,2168,-2,2169,2172,2175,2180,-19,2181,-4,2186,2190,-1,2196,2199,2202,-9,2204,-143,
                 2209,2214}

function offsets_to_bytes_generated(sequence offsets, integer totalsize)
integer last = 0
    for i=1 to length(offsets) do
        if offsets[i]>=0 then
            if last>0 then
                offsets[last] = offsets[i]-offsets[last]
            end if
            last = i
        end if
    end for
    if last then
        offsets[last] = totalsize-offsets[last]
    end if
    return offsets
end function

function bytes_generated_to_offsets(sequence bytes_generated)
integer base = 0, tmp
    for i=1 to length(bytes_generated) do
        if bytes_generated[i]>0 then
            tmp = base
            base += bytes_generated[i]
            bytes_generated[i] = tmp
        end if
    end for
    return bytes_generated
end function

sequence bg, test, packedbg, unpackedbg
    bg = offsets_to_bytes_generated(e820, 2222) -- (2222 is a made up total)
    test = bytes_generated_to_offsets(bg)
    if test!=e820 then ?9/0 end if

    packedbg = pack(bg)
    unpackedbg = unpack(packedbg)
    if unpackedbg!=bg then ?9/0 end if
    ?length(bg)*4       -- 3280+20 = 3300
    ?length(packedbg)   -- 824+17+3 = 844 = 25.57%
    --?packedbg

?unpacklt({15,239,76,253,25,116})   -- {0,-17,15,-3,91,116} -- ={#0,-17,#F,-3,#5B,#74}
                                    -- {  -18,10,-2,84,339}

-- 9/2/15:
--constant t6222 = 
--  {255,50,255,54,54,53,54,54,62,61,62,62,62,53,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
--      62,62,62,53,62,62,62,61,62,62,62,61,62,62,58,57,58,58,58,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,58,57,58,58,62,61,62,62,62,61,58,54,54,255,61,62,62,62,61,
--      255,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,255,57,58,58,58,57,62,62,62,61,62,255,50,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,
--      62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
--      62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,255,62,62,255,54,53,54,54,54,53,58,58,58,57,58,58,58,61,62,62,62,61,
--      62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,255,62,62,62,61,62,62,255,62,61,62,62,62,61,255,62,62,62,61,62,255,54,54,53,54,54,58,57,58,58,58,61,62,62,62,61,62,
--      62,62,61,62,62,62,61,62,62,62,255,61,62,62,62,61,62,62,62,61,62,58,58,57,58,58,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,
--      62,61,62,62,62,61,62,62,58,61,62,58,255,62,61,62,62,62,61,58,58,58,57,58,58,58,57,58,58,255,58,57,58,58,58,61,62,62,62,61,62,62,255,58,57,58,58,58,255,61,62,62,62,61,62,62,62,
--      61,62,62,62,61,62,62,62,255,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,255,61,62,62,62,61,62,62,62,61,62,62,255,62,61,62,62,62,61,62,62,62,61,62,62,62,61,255,
--      62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,255,62,
--      62,62,61,62,255,58,58,57,58,58,255,62,61,62,62,62,61,62,62,62,61,62,62,67,129,130,83}
--sequence u6222 = unpack(t6222)    -- bug: u6222[$]<0
--  ?u6222

constant lt0 = {-1,0,-1,50,103,157,211,265,318,380,442,504,565,627,681,743,804,866,928,990,1051,1113,1175,1237,1298,1360,1422,1484,1545,1607,1669,
1731,1792,1854,1908,1970,2031,2093,2155,2217,2278,2340,2402,2464,2525,2583,2641,2699,2756,2814,2876,2938,2999,3061,3123,3185,3246,3308,3370,3432,
3493,3555,3617,3679,3740,3802,3864,3926,3987,4045,4103,4161,4218,4280,4342,4404,4465,4527,4589,4647,4700,-1,4754,4816,4878,4939,5001,-1,5063,5125,
5186,5248,5310,5372,5433,5495,5557,5619,5680,5742,5804,5866,5927,5989,6051,6113,6174,6236,6298,6360,6421,-1,6483,6541,6599,6656,6714,6772,6834,6895,
6957,7019,-1,7081,7130,7192,7254,7316,7377,7439,7501,7563,7624,7686,7748,7810,7871,7933,7995,8057,8118,8180,8242,8304,8365,8427,8489,8551,8612,8674,
8736,8798,8859,8921,8983,9045,9106,9168,9230,9292,9353,9415,9477,9539,9600,9662,9724,9786,9847,9909,9971,10033,10094,10156,10218,10280,10341,10403,
10465,10527,10588,10650,10712,10774,10835,10897,10959,11021,11082,11144,11206,11268,11329,11391,11453,11515,11576,11638,11700,11762,11823,11885,11947,
12009,12070,12132,12194,12256,12317,12379,12441,12503,12564,12626,12688,12750,12811,12873,12935,12997,13058,13120,13182,13244,13305,13367,13429,13491,
13552,13614,13676,13738,13799,13861,13923,13985,14046,14108,-1,14170,14232,-1,14293,14347,14401,14455,14508,14562,14616,14674,14731,14789,14847,14905,
14962,15020,15082,15144,15205,15267,15329,15391,15452,15514,15576,15638,15699,15761,15823,15885,15946,16008,16070,16132,16193,16255,16317,16379,16440,
16502,-1,16564,16626,16687,16749,16811,16873,-1,16934,16996,17058,17120,17181,17243,-1,17305,17367,17428,17490,17552,-1,17614,17667,17721,17775,17829,
17882,17940,17998,18056,18113,18171,18233,18295,18356,18418,18480,18542,18603,18665,18727,18789,18850,18912,18974,19036,19097,-1,19159,19221,19283,
19344,19406,19468,19530,19591,19653,19715,19777,19834,19892,19950,20008,20065,20127,20189,20251,20312,20374,20436,20498,20559,20621,20683,20745,20806,
20868,20930,20992,21053,21115,21177,21239,21300,21362,21424,21486,21547,21609,21671,21733,21794,21856,21918,21980,22041,22103,22165,22227,22288,22350,
22412,22474,22535,22593,22655,22717,-1,22774,22836,22898,22960,23021,23083,23145,23203,23260,23318,23376,23434,23491,23549,23607,23665,-1,23722,23780,
23838,23896,23953,24011,24073,24135,24196,24258,24320,24382,-1,24443,24501,24559,24617,24674,-1,24732,24794,24856,24917,24979,25041,25103,25164,25226,
25288,25350,25411,25473,25535,25597,25658,-1,25720,25782,25844,25905,25967,26029,26091,26152,26214,26276,26338,26399,26461,26523,26585,26646,26708,
26770,26832,26893,-1,26955,27017,27079,27140,27202,27264,27326,27387,27449,27511,27573,-1,27634,27696,27758,27820,27881,27943,28005,28067,28128,28190,
28252,28314,28375,28437,-1,28499,28561,28622,28684,28746,28808,28869,28931,28993,29055,29116,29178,29240,29302,29363,29425,29487,29549,29610,29672,
29734,29796,29857,29919,29981,30043,30104,30166,30228,30290,30351,30413,30475,30537,30598,30660,30722,30784,30845,30907,30969,31031,31092,31154,31216,
31278,31339,31401,31463,31525,31586,31648,31710,31772,31833,31895,-1,31957,32019,32080,32142,32204,-1,32266,32323,32381,32439,32497,-1,32554,32616,
32678,32740,32801,32863,32925,32987,33048,33110,33172,33234,33295,33362}
--32678,32740,#8021,#805F,#809D,#80DB,#8118,#8156,#8194,#81D2,#820F,#8252}
--constant ltu = 
--{-1,0,-1,50,103,157,211,265,318,380,442,504,565,627,681,743,804,866,928,990,1051,1113,1175,1237,1298,1360,1422,1484,1545,1607,1669,1731,1792,1854
--,1908,1970,2031,2093,2155,2217,2278,2340,2402,2464,2525,2583,2641,2699,2756,2814,2876,2938,2999,3061,3123,3185,3246,3308,3370,3432,3493,3555,3617
--,3679,3740,3802,3864,3926,3987,4045,4103,4161,4218,4280,4342,4404,4465,4527,4589,4647,4700,-1,4754,4816,4878,4939,5001,-1,5063,5125,5186,5248,531
--0,5372,5433,5495,5557,5619,5680,5742,5804,5866,5927,5989,6051,6113,6174,6236,6298,6360,6421,-1,6483,6541,6599,6656,6714,6772,6834,6895,6957,7019,
---1,7081,7130,7192,7254,7316,7377,7439,7501,7563,7624,7686,7748,7810,7871,7933,7995,8057,8118,8180,8242,8304,8365,8427,8489,8551,8612,8674,8736,87
--98,8859,8921,8983,9045,9106,9168,9230,9292,9353,9415,9477,9539,9600,9662,9724,9786,9847,9909,9971,10033,10094,10156,10218,10280,10341,10403,10465
--,10527,10588,10650,10712,10774,10835,10897,10959,11021,11082,11144,11206,11268,11329,11391,11453,11515,11576,11638,11700,11762,11823,11885,11947,
--12009,12070,12132,12194,12256,12317,12379,12441,12503,12564,12626,12688,12750,12811,12873,12935,12997,13058,13120,13182,13244,13305,13367,13429,1
--3491,13552,13614,13676,13738,13799,13861,13923,13985,14046,14108,-1,14170,14232,-1,14293,14347,14401,14455,14508,14562,14616,14674,14731,14789,14
--847,14905,14962,15020,15082,15144,15205,15267,15329,15391,15452,15514,15576,15638,15699,15761,15823,15885,15946,16008,16070,16132,16193,16255,163
--17,16379,16440,16502,-1,16564,16626,16687,16749,16811,16873,-1,16934,16996,17058,17120,17181,17243,-1,17305,17367,17428,17490,17552,-1,17614,1766
--7,17721,17775,17829,17882,17940,17998,18056,18113,18171,18233,18295,18356,18418,18480,18542,18603,18665,18727,18789,18850,18912,18974,19036,19097
--,-1,19159,19221,19283,19344,19406,19468,19530,19591,19653,19715,19777,19834,19892,19950,20008,20065,20127,20189,20251,20312,20374,20436,20498,205
--59,20621,20683,20745,20806,20868,20930,20992,21053,21115,21177,21239,21300,21362,21424,21486,21547,21609,21671,21733,21794,21856,21918,21980,2204
--1,22103,22165,22227,22288,22350,22412,22474,22535,22593,22655,22717,-1,22774,22836,22898,22960,23021,23083,23145,23203,23260,23318,23376,23434,23
--491,23549,23607,23665,-1,23722,23780,23838,23896,23953,24011,24073,24135,24196,24258,24320,24382,-1,24443,24501,24559,24617,24674,-1,24732,24794,
--24856,24917,24979,25041,25103,25164,25226,25288,25350,25411,25473,25535,25597,25658,-1,25720,25782,25844,25905,25967,26029,26091,26152,26214,2627
--6,26338,26399,26461,26523,26585,26646,26708,26770,26832,26893,-1,26955,27017,27079,27140,27202,27264,27326,27387,27449,27511,27573,-1,27634,27696
--,27758,27820,27881,27943,28005,28067,28128,28190,28252,28314,28375,28437,-1,28499,28561,28622,28684,28746,28808,28869,28931,28993,29055,29116,291
--78,29240,29302,29363,29425,29487,29549,29610,29672,29734,29796,29857,29919,29981,30043,30104,30166,30228,30290,30351,30413,30475,30537,30598,3066
--0,30722,30784,30845,30907,30969,31031,31092,31154,31216,31278,31339,31401,31463,31525,31586,31648,31710,31772,31833,31895,-1,31957,32019,32080,32
--142,32204,-1,32266,32323,32381,32439,32497,-1,32554,32616,32678,32740,32801,32863,32925,32987,33048,33110,33172,33234,33295,-32174}
--ltu[$]<0
sequence ltp = ltpack(lt0)
--puts(1,"ltp = ")
--ppEx(ltp,{pp_StrFmt,1})
--ltp = {255,50,255,53,54,54,54,53,62,62,62,61,62,54,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,54,62,61,62,62,62,61,62,62,62,61,58,58,58,57,58,
-- 62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,58,58,58,57,62,62,
-- 62,61,62,62,58,53,54,255,62,62,61,62,62,255,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,62,62,61,62,255,58,58,57,58,58,62,61,62,62,62,
-- 255,49,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,
-- 62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,
-- 61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,
-- 62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,255,62,61,255,54,54,54,
-- 53,54,54,58,57,58,58,58,57,58,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,62,255,62,61,62,62,62,61,255,62,62,62,61,62,62,
-- 255,62,61,62,62,62,255,53,54,54,54,53,58,58,58,57,58,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,255,62,62,61,62,62,62,61,62,62,62,57,58,58,58,
-- 57,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,58,62,62,57,255,62,62,62,
-- 61,62,62,58,57,58,58,58,57,58,58,58,57,255,58,58,58,57,58,62,62,61,62,62,
-- 62,61,255,58,58,58,57,58,255,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
-- 62,255,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,255,62,
-- 62,61,62,62,62,61,62,62,62,61,255,62,62,62,61,62,62,62,61,62,62,62,61,62,
-- 62,255,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,
-- 62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,62,62,61,62,
-- 62,62,61,62,62,62,61,62,62,255,62,61,62,62,62,255,57,58,58,58,57,255,62,62,
-- 62,61,62,62,62,61,62,62,62,61,67,129,130,82}

sequence ltu = unpacklt(ltp)

--ltu = unpacklt(ltp)
if ltu[$]<0 then
?lt0
?ltu
    puts(1,"ltu[$]<0\n")
?9/0
end if

constant lt1 = {-2}
ltp = ltpack(lt1)
ltu = unpacklt(ltp)
?{lt1,ltp,ltu}
ppEx(ltp,{pp_StrFmt,1})
    
    if getc(0) then end if

